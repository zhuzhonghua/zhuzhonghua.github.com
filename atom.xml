<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[GNO Blog]]></title>
  <link href="http://zhuzhonghua.github.com/atom.xml" rel="self"/>
  <link href="http://zhuzhonghua.github.com/"/>
  <updated>2012-06-07T13:50:48+08:00</updated>
  <id>http://zhuzhonghua.github.com/</id>
  <author>
    <name><![CDATA[zhuzhonghua]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在mingw环境下编译最新版本gcc gdb]]></title>
    <link href="http://zhuzhonghua.github.com/blog/2012/06/07/mingw-gcc-gdb-environment/"/>
    <updated>2012-06-07T13:40:00+08:00</updated>
    <id>http://zhuzhonghua.github.com/blog/2012/06/07/mingw-gcc-gdb-environment</id>
    <content type="html"><![CDATA[<p>由于比较喜欢GCC的东西，又必须做WIN下的程序，但是考虑到效率问题  <br/>
1，使用LINUX交叉编译MINGW下的程序  <br/>
2，直接使用MINGW和MSYS编译WIN程序</p>

<p>使用交叉编译的方法，在网上搜到的比较麻烦，而且又不是做嵌入式开发，必须用交叉编译;  <br/>
所以决定使用第二种方法。</p>

<p>目前已经成功编译了GDB7.4.1和最新的BINUTILS，还有MPC，MPFR，等GCC需要依赖的库。  <br/>
晚上回去看一下GCC4.7.0的编译情况。</p>

<p>不过在公司已经使用MINGW-GET拿到了GDB7.4和GCC4.6.2,而且使用正常。</p>

<p>目前是使用VIM做编辑器，使用EMACS做调试器（是不是有点小奢侈啊），幸好这两个神器都有WIN版本。</p>

<p>感谢GNU，感谢上帝。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sicp-parsk]]></title>
    <link href="http://zhuzhonghua.github.com/blog/2012/06/05/sicp-parsk/"/>
    <updated>2012-06-05T17:15:00+08:00</updated>
    <id>http://zhuzhonghua.github.com/blog/2012/06/05/sicp-parsk</id>
    <content type="html"><![CDATA[<p>SCIP上的一个习题  <br/>
用递归输出PARSK三角，也有叫杨辉三角的  <br/>
个人认为，使用递归更简单一些，不过作为练习，就这样了  <br/>
上代码</p>

<pre><code>(defun parsk(n)
  (if (= n 1)
      (let ((ret (list 1)))
    (echo-list ret)
    ret)
    (let ((resn (list 1))
      (resn-1 (parsk (- n 1))))
      (do ((i 0 (+ i 1)))
      ((&gt; i (- (length resn-1) 2)) 'done)
    (setq resn (append resn (list (+ (nth i resn-1)
                     (nth (+ i 1) resn-1))))))
      (setq resn (append resn (list 1)))
      (echo-list resn)
      resn)))
</code></pre>

<p>其中ECHO-LIST是个辅助函数，输出LIST</p>

<pre><code>(defun echo-list(lst)
  (progn
    (dolist (obj lst)
      (format t "~A " obj))
    (format t "~%")))
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[lisp-recursive-iteration]]></title>
    <link href="http://zhuzhonghua.github.com/blog/2012/06/05/lisp-recursive-iteration/"/>
    <updated>2012-06-05T12:51:00+08:00</updated>
    <id>http://zhuzhonghua.github.com/blog/2012/06/05/lisp-recursive-iteration</id>
    <content type="html"><![CDATA[<p>在common lisp 中，尾递归的概念确实很好<br></p>

<p>废话不多说，先上代码<br></p>

<p>以著名的斐波那契数列为例：<br></p>

<p>1，递归版<br></p>

<pre><code>(defun fib(n)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          (t (+ (fib (- n 1))
                (fib (- n 2))))))
</code></pre>

<p>2，迭代版（尾递归）<br></p>

<pre><code>(defun fib(n)
    (fib-iter 1 0 n))

(defun fib-iter(a b count)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1))))
</code></pre>

<p>使用第二种方式，可以减少堆栈空间的使用</p>
]]></content>
  </entry>
  
</feed>
