<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>非著名程序</title>
 <link href="http://zhuzhonghua.github.com/atom.xml" rel="self"/>
 <link href="http://zhuzhonghua.github.com"/>
 <updated>2012-11-15T21:01:28+08:00</updated>
 <id>http://zhuzhonghua.github.com</id>
 <author>
   <name>zhonghua</name>
   <email>secondsquare@gmail.com</email>
 </author>

 
 <entry>
   <title>swf文件格式9之字体和文本(fonts and text)</title>
   <link href="http://zhuzhonghua.github.com/essays/2012/11/13/swf-spec-9-font-text"/>
   <updated>2012-11-13T00:00:00+08:00</updated>
   <id>http://zhuzhonghua.github.com/essays/2012/11/13/swf-spec-9-font-text</id>
   <content type="html">&lt;p&gt;SWF8文件格式说明支持多种画文本的方法。在SWF6和之后的文件中，所有的文本都使用Unicode编码表示，消除了文本和字符串不同地区之间的区别。这里提醒一下，尽管FP是完全支持Unicode的，但是它仅仅能画从左到右的简单脚本，目前还不支持Hebrew，Arabic，Thai和其它复杂脚本。&lt;/p&gt;

&lt;h1 id='id1'&gt;字型文本和设备文本&lt;/h1&gt;

&lt;p&gt;swf文件格式支持两种文本：字型文本和设备文本。字型文本通过在swf中嵌入字符形状，设备文本使用的是播放平台的文本渲染能力。&lt;/p&gt;

&lt;p&gt;字型文本在所有平台上看起来都一样。可以通过图形使用标准反锯齿，也可以在swf8之后，通过使用高级文本渲染引擎实现。使用字型文本会比设备文本产生更大的swf文件，尤其是在一个很大的字符集里使用了很多字符。&lt;/p&gt;

&lt;p&gt;设备字体通过操作系统本身实现反锯齿，不同平台表现不一样。有两种方式指定设备文本：直接的通过字体名称在系统中查找，一个特殊的字体名称，映射到平台的高可用字体，尽量选择相近的字体。&lt;/p&gt;

&lt;p&gt;字型文本字符通过DefineFont，DefineFont2，DefineFont3标签定义。设备文本字体通过DefineFont和DefineFontInfo标签一起定义，或者直接通过DefineFont2定义。定义设备文本字体的DefineFont2，如果用在动态文本中的话，不需要包含任何字符图像，尽管包含进来更好，为了防止在任何平台上的任何时刻，字符是否可用。DefineFont和DefineFont2标签可以同时为某些文本提供字型文本，为其它提供设备文本支持，只要提供了图像和字符编码。&lt;/p&gt;

&lt;h1 id='id2'&gt;静态文本和动态文本&lt;/h1&gt;

&lt;p&gt;文本可以被定义为静态的，或者在swf4之后，动态的。动态文本可以在运行时改变，并且还可以变为可编辑。动态文本可以模拟几乎静态文本的所有特性。除了静态文本精确的单个字符的位置，不考虑实现难度和版本兼容性。动态文本还有很多格式化的功能，静态文本没有的。丰富的格式化功能是HTML－文本标记的一个子集。&lt;/p&gt;

&lt;p&gt;静态文本通过DefineText定义。动态文本通过DefineEditText定义。这两个标签都可以引用DefineFont或者DefineFont2来获取字符来源。DefineEditText使用的DefineFont2，而不是DefineFont。DefineText既可以使用DefineFont也可以使用DefineFont2。&lt;/p&gt;

&lt;p&gt;DefineEditText提供了一个标记，来指明使用字型文本还是设备文本。DefineText并没有。这意味着在静态文本中，swf文件格式没办法指明使用字型文本还是设备文本。这个问题由运行时标记解决。一般，所有静态文本都使用字型文本。当FP插件被嵌入到HTML页面中，一个叫devicefont的HTML标签选项会让FP把所有静态文本都渲染成设备文本。字型文本所有后备。DefineEditText能够指明使用静态文本还是字型文本的能力是被认为好于DefineText的另一个原因。&lt;/p&gt;

&lt;h1 id='id3'&gt;字型文本&lt;/h1&gt;

&lt;h2 id='id4'&gt;字型定义&lt;/h2&gt;

&lt;p&gt;字型是在一个称为EMSquare的标准坐标空间里定义的。相同的字型集合被使用于每一个给定的字体大小。为了以不同的大小渲染字型，FP通过把EM坐标缩放到点阵坐标。&lt;img alt='glyphdef' src='/assets/glyphdefinitions.png' /&gt;&lt;/p&gt;

&lt;p&gt;字行字体－不使用高级文本渲染引擎－没有包含任何提高小字体大小的指示信息。然而反矩阵会很好的提高缩小字体的易读性。在12点的大小时(看作100％)，字型文本还是易读的。12点或更低，在渲染可读文本时，建议采用高级反锯齿效果。这会提供小字体大小的优秀文本质量，还包含其它字体元信息来提高渲染效果。&lt;/p&gt;

&lt;p&gt;TTF可以很好的转为SWF字型。一个简单的算法是使用Quadratic Bezier 曲线替换Quadratic B－splines。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;p&gt;左边是TTF中Arial的字符b的字型。它是由弯曲的和直线的边组成。方块指示的是on-curve点，x指示的是off-curve点。黑圈是字型的参考点。蓝色边框线指示的是字型的轮廓。&lt;/p&gt;

&lt;h2 id='em_square'&gt;EM Square&lt;/h2&gt;

&lt;p&gt;EMSquare 是想象的空间，用于字型大小和对齐。EMSquare足够大，包含了所有字型，包括重音字型。包括字体的上部，下部，还有一些额外空间来避免文本线的冲突。&lt;img alt='emsquare' src='/assets/emsquare.png' /&gt;&lt;/p&gt;

&lt;p&gt;SWF字型是在1024＊1024的空间中定义的。其它来源的字型(如TTF)会有不同的EMSquare。为了使用这些字型，应该缩放到1024大小。&lt;/p&gt;

&lt;h2 id='ttfswf'&gt;把TTF转换为SWF字型&lt;/h2&gt;

&lt;p&gt;TTF字型是使用Quadratic B－Splines定义的，这可以很容易的转换为SWF字型的Quadratic Bezier曲线。&lt;/p&gt;

&lt;p&gt;一个TTF B－splines是由一个在on-curve点和很多off-curve点，再跟着一个on-curve点组成的。两个off-curve点的中点保证在曲线上。SWF的Bezier曲线是由一个on-curve点和一个off-curve点，再跟一个on-curve点。&lt;/p&gt;

&lt;p&gt;从TTF到SWF曲线的转换就是在两个off-curve点的中点插入一个on-curve点。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;p&gt;下面是4个点的B－splines，P0和P3是on-curve点，P1和P2是连续的off-curve点。&lt;img alt='bsplines' src='/assets/bsplines.png' /&gt;&lt;/p&gt;

&lt;p&gt;这个曲线可以由两个Bezier曲线组成，在P1和P2的中点插入M，结果就是两个Bezier曲线，P0P1M和MP2P3。&lt;/p&gt;

&lt;p&gt;完整的转换过程描述如下：&lt;/p&gt;

&lt;p&gt;1，Y坐标反向（TTF中Y向上，SWF中Y向下）&lt;br /&gt;2，把TTF中EMSquare坐标缩放到SWFEMSquare坐标中。&lt;br /&gt;3，在每对off-curve的中点插入on-curve点。&lt;/p&gt;

&lt;h2 id='id5'&gt;字距和差值信息&lt;/h2&gt;

&lt;p&gt;字距指的是两个字型之间的水平距离。有些字体系统在每个字体定义时都存储了字距信息。SWF文件存储的是每个字型实例(字型文本块的每个字符)的字距信息。这样成为差值。&lt;img alt='kerning' src='/assets/kerning.png' /&gt;&lt;/p&gt;

&lt;p&gt;在前面的例子里，A字型和V字型重叠了。这种情况下，差值要比A的宽度窄。&lt;/p&gt;

&lt;h2 id='id6'&gt;高级文本渲染引擎&lt;/h2&gt;

&lt;p&gt;字型可以使用普通的FP渲染器渲染，或者在SWF8之后，使用高级文本渲染引擎渲染。&lt;/p&gt;

&lt;p&gt;高级文本渲染引擎是一种在FP渲染器里的高质量文本渲染器。对于文本来说，这个高级系统相对一般的渲染器有如下优势：&lt;/p&gt;

&lt;p&gt;+ 即使小字体也可读&lt;br /&gt;+ 即使小字体看起来也美观&lt;br /&gt;+ 对于非常清晰的文本(左对齐的动态文本)支持像素对齐&lt;br /&gt;+ 提高了字型字体的性能&lt;br /&gt;+ 支持液晶屏幕的子像素渲染&lt;/p&gt;

&lt;p&gt;高级文本渲染引擎的一个局限是，它没有字型文本那样的动画效果。&lt;/p&gt;

&lt;p&gt;高级文本渲染引擎使用Continuous Stroke Modulation(CSM)参数来调整表现。CSM是一种笔画粗细和边缘锐度的连续调整。CSM使用两种渲染参数：内部和外部切断。这些参数的最佳值是有很大的主观性，并且依赖于用户的喜好，照明条件，显示属性，字样，前景和背景颜色，还有大小。然而大部分情况下，可以通过一小部分内插值的方法来实现高质量类型。&lt;/p&gt;

&lt;p&gt;创建高级反锯齿边缘的功能，有外切断(在这之下，边缘不画)和内切断(在这之上，边缘不透明)。在两个切断值之间是一个线性函数，从外切断的0到内切断的最大值。&lt;/p&gt;

&lt;p&gt;调整内外切断的值会影响笔画粗细和边缘锐度。两个参数之间的空间是经典的反锯齿方法的过滤半径的两倍。窄一些的空间提供了更锐利的边缘，而宽一些的空间提供了更柔和的边缘。空间是0时，生成的图像是双层图像；当空间很大时，会生成像水一样的边缘。一般的，在小字体情况下，用户喜欢锐利的，高对比度的边缘；而对于动画效果的文本和大字体，喜欢更柔和的边缘。&lt;/p&gt;

&lt;p&gt;外切断是负值，内切断是正值，中点一般在0左右。把中点调向负的方向，会增加笔画粗细；调向正的方向，会减少笔画粗细。外切断应该永远小于等于内切断。&lt;/p&gt;

&lt;p&gt;FP创建了一个CSM的表格，为每个高级反锯齿字体提供文本大小和文本颜色的功能。这个表格提供了一个CSM设置的集合，包含了很大范围的字体大小。你还可以定义一个用户自定义的表格，来代替默认值，使用AS的函数，setAdvancedAntiAliasingTable()&lt;/p&gt;

&lt;h2 id='definefont__definetext'&gt;DefineFont 和 DefineText&lt;/h2&gt;

&lt;p&gt;在SWF文件格式支持的四种文本类型中，最复杂的是静态字型文本。其它类型使用的是定义静态字型文本的简单变形。&lt;/p&gt;

&lt;p&gt;静态字型文本使用两个TAG定义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DefineFont定义字型集合&lt;/li&gt;

&lt;li&gt;DefineText定义使用那个字体显示的文本字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DefineFont标签定义了所有用户DefineText的字型。DefineFont包含了一组SHAPERECORD，描述了字型的边缘。这些SHAPERECORD同样用于DefineShape，定义非文本内容。为了把文件大小降到最低，只有使用的字型才会包含进来。DefineText存储的是实际要显示的文本字符串，由字型下标表示。还有文本的包围盒，转换矩阵，属性如颜色，大小。&lt;/p&gt;

&lt;p&gt;DefineText包含了一组TEXTRECORD。TEXTRECORD记录了字体，颜色，大小，还有下一个字符的XY坐标。这个类型会应用到接下来的所有字符，直到另一个TEXTRECORD。TEXTRECORD还包含一组下标，引用了当前字体的字型表。字符不是由字符编码引用，而是由字型表的下标引用。字型数据还包含文本中每个字符的差值。&lt;/p&gt;

&lt;h2 id='id7'&gt;静态字型文本举例&lt;/h2&gt;

&lt;p&gt;考虑一下使用24大小，以Arial字体显示bob。&lt;/p&gt;

&lt;p&gt;首先使用DefineFont定义字型。字型表有两个SHAPERECORD。0位置是小写B的形状，1位置是小写o的形状。(第二个b重复了，不需要再定义)DefineFont还包括一个唯一ID，接下来的DefineText可以引用。&lt;/p&gt;

&lt;p&gt;第二，使用DefineText定义文本。TEXTRECORD设置第一个字符的位置，选择Arial字体，设置大小为24，这样字体被缩放到正确大小。(字型是在EMSquare坐标系中定义的，大小是DefineText的一部分)还包含一组GLYPHENTRY。每一个GLYPHENTRY都引用字体形状数组的一个下标。在这个例子里，第一个GLYPHENTRY引用下标0(对应字符b)，第二个引用下标1(o)，第三个引用下标0(b)。每个GLYPHENTRY还包含差值来精确定位字型的位置。&lt;/p&gt;

&lt;p&gt;下面的图描述了DefineText如何与DefineFont交互。&lt;br /&gt;&lt;img alt='definetextfont' src='/assets/definetextfont.png' /&gt;&lt;/p&gt;

&lt;h1 id='id8'&gt;字体标签&lt;/h1&gt;

&lt;h2 id='definefont'&gt;DefineFont&lt;/h2&gt;

&lt;p&gt;DefineFont定义了特定字体的每个字型的边框形状。只有在DefineText中使用的字型才会被定义。DefineFont不能用于动态文本。动态文本需要DefineFont2。&lt;/p&gt;

&lt;p&gt;最低文件版本是SWF1。&lt;/p&gt;

&lt;p&gt;&lt;img alt='definefont' src='/assets/definefont.png' /&gt;&lt;/p&gt;

&lt;p&gt;字体ID唯一标识了这个字体。可以用于DefineText引用。在SWF文件中字体ID也必须唯一。&lt;/p&gt;

&lt;p&gt;如果DefineFontInfo和DefineFont一起，要注意DefineFont中的字型顺序要和DefineFontInfo中的字符顺序一致，以字符码排序。OffsetTable和GlyphShapeTable一起使用。这两个表有相同数量的条目，offsets中的顺序和shape中的顺序，一一顺序对应。OffsetTable指定了在GlyphShapeTable中的位置。每一个Offset条目存储的是offset table开始到相应shape的差值(BYTES)。因为GlyphShapeTable与OffsetTable相邻，那么每个表格中的条目数量(字体定义的字型数目)可以通过offsettable中的第一个条目除以2得到。&lt;/p&gt;

&lt;p&gt;在GlyphShapeTable中的每一个SHAPE的第一个STYLECHANGERECORD不使用LineStyle和LineStyles字段。另外这种情况下，这两个字段都被设为1。&lt;/p&gt;

&lt;h2 id='definefontinfo'&gt;DefineFontInfo&lt;/h2&gt;

&lt;p&gt;DefineFontInfo定义的是字型字体到设备字体的一个映射。提供了一个字体名和样式，传到平台的文本的渲染引擎，还有一个字符编码表格指定了相应字体的字型，这样可以把DefineText的字型下标转换为字符串。&lt;/p&gt;

&lt;p&gt;DefineFontInfo并不会强制把字型文本转换为设备文本。它仅仅是可以这样做。实际是根据devicefont的值或者DefineText中的UseOutlines的值来决定。如果设备字体不可用，FP会继续用字型字体。&lt;/p&gt;

&lt;p&gt;最低版本要求是SWF1。&lt;/p&gt;

&lt;p&gt;&lt;img alt='definefontinfo' src='/assets/definefontinfo1.png' /&gt; &lt;img alt='definefontinfo' src='/assets/definefontinfo2.png' /&gt;&lt;/p&gt;

&lt;p&gt;CodeTable中的条目必须是字码的升序排序。同时CodeTable中条目的顺序必须和引用的DefineFont中的字型顺序一致。这也要求DefineFont中的字型顺序要保持一致。&lt;/p&gt;

&lt;p&gt;SWF6和之后的文件都要求Unicode文本编码。这样所有的字符编码表都用的是UCS－2(UCS－2是第一个UTF－16的64K字符码)。这种编码为每个字符使用固定2字节大小。这就是说，如果DefineFontInfo出现在SWF6或之后的文件中，那么FontFlagsWideCodes一定被设为1，FontFlagsShiftJIS和FontFlagsANSI一定设为0，CodeTable一定使用的是UI16的UCS－2的编码组成。&lt;/p&gt;

&lt;p&gt;另外一点是在SWF6和之后的文件中，字体名一定是用UTF8编码的。在SWF5或之前，文件名是以平台特定的方式编码的，使用系统的码页。平台会使用当前的码页来显示，导致不一样的平台之间的不一致结果。如果平台是ANSI系统，字体名称就是ANSI字符串。如果平台是日本的Shift－JIS系统，字体名就会被翻译为Shift－JIS字符串。还有很多其他平台的码页。这种本地依赖非常不好，这也是为什么SWF6转向了统一编码。需要注意的是DefineFontInfo中的字体名不是空字符串结尾的。而是通过FontNameLen来定义长度的。FontNameLen指定了FontName需要的字节数，这不一定要和字符数量一致，因为有些编码，每个字符会使用多于1个字节。&lt;/p&gt;

&lt;p&gt;字体名是逐字使用的，直接传入平台的字体系统，定位字体。然而有很多特殊的间接字体名是,根据不同平台映射到不同的字体的。这些间接映射是硬编码到平台特定的FP中的，这些字体是在平台默认字体和最可用字体之间选择的。或者这样考虑，间接映射是为了让所有平台看起来尽可能一致。&lt;/p&gt;

&lt;p&gt;下面的表就是支持的间接映射字体名。&lt;/p&gt;

&lt;p&gt;&lt;img alt='western' src='/assets/westernfonts.png' /&gt;&lt;br /&gt;&lt;img alt='japanese' src='/assets/japanesefonts.png' /&gt;&lt;/p&gt;

&lt;h2 id='definefontinfo2'&gt;DefineFontInfo2&lt;/h2&gt;

&lt;p&gt;当生成SWF6或之后的文件时，建议使用DefineFontInfo2，而不是DefineFontInfo。DefineFontInfo2和DefineFontInfo是一样的，除了它增加了一个language code字段。如果使用DefineFontInfo，这个字段被认为是0，这将会导致，平台不一样，表现不一样。&lt;/p&gt;

&lt;p&gt;最小的版本要求是SWF6。&lt;/p&gt;

&lt;p&gt;&lt;img alt='definefontinf2' src='/assets/definefontinfo22.png' /&gt;&lt;/p&gt;

&lt;h2 id='definefont2'&gt;DefineFont2&lt;/h2&gt;

&lt;p&gt;DefineFont2扩展了DefineFont功能。包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;OffsetTable中32位的条目，可以有多于64K的字型字体。&lt;/li&gt;

&lt;li&gt;合并DefineFontInfo的功能，映射到设备字体。&lt;br /&gt;+ 提高了动态文本的字体规格。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DefineFont2是唯一能用于动态文本的标签。&lt;/p&gt;

&lt;p&gt;最小的版本要求是SWF3。&lt;/p&gt;

&lt;p&gt;&lt;img alt='definefont2' src='/assets/definefont21.png' /&gt;&lt;br /&gt;&lt;img alt='definefont2' src='/assets/definefont22.png' /&gt;&lt;br /&gt;&lt;img alt='definefont2' src='/assets/definefont23.png' /&gt;&lt;br /&gt;&lt;img alt='definefont2' src='/assets/definefont24.png' /&gt;&lt;/p&gt;

&lt;p&gt;在SWF6和之后的文件中，DefineFont2和DefineFontInfo一样，要求Unicode。CodeTable(还有OffsetTable，GlyphTable， FontAdvanceTable)必须以字码顺序排序。如果DefineFont2仅仅用于动态文本，并且也不需要字型渲染，那么NumGlyphs被设置为0，并且忽略所有相关条目。这样会减少DefineFont2的大小。没有字型的DefineFont2不能够显示静态文本(需要字型索引)和字型文本(需要字型形状定义)。&lt;/p&gt;

&lt;p&gt;布局信息(ascent, descent, leading, advance table, bounds table, kerning table)仅仅对动态文本有用。此信息代替了用于静态字型文本的每个字符的布局信息。DefineFont2中的布局信息是相当标准的字体规格信息，可以从标准的字体定义中抽取，如TTF。&lt;/p&gt;

&lt;p&gt;就像在DefineFont里一样，DefineFont2里每个SHAPE的第一个STYLECHANGERECORD也不使用LineStyle和LineStyles字段，并且也被设置为1。&lt;/p&gt;

&lt;p&gt;DefeinFont2还保留了字体边框表和字距表。这些信息在FP7之后就不用了，但是必须被保留下来，为了DefineFont2的一致性。为FontBoundTable提供一个最小的RECT，把KerningCount永远设置为0，这样可以让FontKerningTable忽略掉。&lt;/p&gt;

&lt;h2 id='definefont3'&gt;DefineFont3&lt;/h2&gt;

&lt;p&gt;DefineFont3是和DefineFontAlignZones一起在SWF8中引入的。当使用高级反锯齿功能时，DefineFontAlignZones是可选的，但是推荐使用；它会修改DefineFont3的行为。&lt;/p&gt;

&lt;p&gt;DefineFont3扩展了DefineFont2的功能，通过把GlyphShapeTable中的SHAPE坐标提高20倍。所有的EMSquare坐标在导出时，都乘以20，这样就可以精确到1/20个单位。这可以定义更精确的字型，有更好的可视效果。&lt;/p&gt;

&lt;p&gt;最低的版本要求是SWF8。&lt;/p&gt;

&lt;p&gt;&lt;img alt='definefont3' src='/assets/definefont31.png' /&gt; &lt;br /&gt;&lt;img alt='definefont3' src='/assets/definefont32.png' /&gt; &lt;img alt='definefont3' src='/assets/definefont33.png' /&gt; &lt;img alt='definefont3' src='/assets/definefont34.png' /&gt;&lt;/p&gt;

&lt;h2 id='definefontalignzones'&gt;DefineFontAlignZones&lt;/h2&gt;

&lt;p&gt;DefineFongAlignZones可以修改DefineFont3。高级文本渲染引擎使用alignment zones来建立字型边界，实现像素对齐。alignment zones对于高质量的字体很重要。&lt;/p&gt;

&lt;p&gt;Alignment Zones为每个有很强横竖感的字型都定义了一个包围盒。盒子是通过x坐标，粗细，y坐标，高度描述的。高度或粗细很小时，被设置为0。&lt;/p&gt;

&lt;p&gt;例如考虑一下字母I。&lt;/p&gt;

&lt;p&gt;&lt;img alt='I' src='/assets/definefontalignzonesi.png' /&gt;&lt;/p&gt;

&lt;p&gt;I在底部和顶部有很强烈的水平感。在主干的边缘，而不是在条形顶部或者衬线上，有很强烈的垂直感。在字母中心块上的强烈横竖感，决定了alignment zones。&lt;/p&gt;

&lt;p&gt;最低的版本要求是SWF8。&lt;/p&gt;

&lt;p&gt;&lt;img alt='definefontalignmentzones' src='/assets/definefontalignmentzones.png' /&gt;&lt;br /&gt;&lt;img alt='zonerecord' src='/assets/zonerecord.png' /&gt;&lt;br /&gt;&lt;img alt='zonedata' src='/assets/zonedata.png' /&gt;&lt;/p&gt;

&lt;h3 id='kerning_record'&gt;Kerning Record&lt;/h3&gt;

&lt;p&gt;Kerning Record定义的是在EMSquare坐标系中，两个字型的距离。某对字型更近或更远的话，看起来会更美观。FontKerningCode1和FontKerningCode2是两边的字符编码。FontKerningAdjustment字段有符号的整数，会加在左边字符的差值上。&lt;/p&gt;

&lt;p&gt;&lt;img alt='kerningrecord' src='/assets/kerningrecord.png' /&gt;&lt;/p&gt;

&lt;h2 id='definefontname'&gt;DefineFontName&lt;/h2&gt;

&lt;p&gt;DefineFontName包含了嵌入在SWF文件里的字体名和版权信息。&lt;/p&gt;

&lt;p&gt;最低的版本要求是SWF9。&lt;/p&gt;

&lt;p&gt;&lt;img alt='definefontname' src='/assets/definefontname1.png' /&gt;&lt;br /&gt;&lt;img alt='definefontname' src='/assets/definefontname2.png' /&gt;&lt;/p&gt;

&lt;h1 id='id9'&gt;静态文本标签&lt;/h1&gt;

&lt;h2 id='definetext'&gt;DefineText&lt;/h2&gt;

&lt;p&gt;DefineText定义了一块静态文本。描述了字体，大小，颜色和每个字符的精确位置。&lt;/p&gt;

&lt;p&gt;最低的版本要求是SWF1。&lt;/p&gt;

&lt;p&gt;&lt;img alt='definetext' src='/assets/definetext.png' /&gt;&lt;/p&gt;

&lt;p&gt;TextBounds字段是一个矩形区域，包含了这个文本块的所有字符。&lt;/p&gt;

&lt;p&gt;GlyphBits和AdvanceBits定义了用于GlyphIndex和GlyhAdvance字段(GLYPHRECORD中的条目里的)的位数。&lt;/p&gt;

&lt;h3 id='textrecord'&gt;TextRecord&lt;/h3&gt;

&lt;p&gt;一个TEXTRECORD指定了接下来的文本样式。可以被用于选择字体，改变字体颜色，改变大小，插入换行，或者设置下一个字符的XY坐标。直到下一个TEXTRECORD出现。&lt;/p&gt;

&lt;p&gt;TEXTRECORD还定义了文本的所有字符。字符是通过索引到当前字体的字型表，而不是字符编码。每一个TEXTRECORD都包含一组字符，共享相同的样式，并且在同一行上。&lt;/p&gt;

&lt;p&gt;&lt;img alt='textrecord' src='/assets/textrecord.png' /&gt;&lt;/p&gt;

&lt;p&gt;FondID字段用于选择前面定义的字体。唯一标识DefineFont或者DefineFont2的ID。&lt;/p&gt;

&lt;p&gt;TextHeight字段定义了字体的高度，用TWIPS单位。如50像素就是TextHeight＝1000。&lt;/p&gt;

&lt;p&gt;XOffset字段定义了文本框矩形左边到字型引用点(EMSquare中第一个曲线段偏离的点)的偏移。一般引用点都在底部，接近字型的左边(参看GlyphText的例子)。XOffset一般用来创建缩进文本或者非左对齐文本。如果没有指定XOffset，那就默认0。&lt;/p&gt;

&lt;p&gt;YOffset字段定义了文本矩形上边到字型引用点的偏移。这个字段一般用于插入断行，把文本移动到新行的开始。&lt;/p&gt;

&lt;p&gt;GlyphCount字段定义了字符个数，还有GLYPHENTRY表格的大小。&lt;/p&gt;

&lt;h3 id='glyphentry'&gt;GlyphEntry&lt;/h3&gt;

&lt;p&gt;GlyphEntry描述的是单个字符，由一个引用到当前字体字型表的索引和差值组成。差值就是当前字符引用点到下一个字符引用点的水平距离。&lt;/p&gt;

&lt;p&gt;&lt;img alt='glyphentry' src='/assets/glyphentry.png' /&gt;&lt;/p&gt;

&lt;h2 id='definetext2'&gt;DefineText2&lt;/h2&gt;

&lt;p&gt;DefineText2几乎和DefineText是一样的。唯一的区别是在DefineText2中的TEXTRECORD使用RGBA来定义字体颜色。这可以产生半透明甚至全透明的字符。&lt;/p&gt;

&lt;p&gt;由DefineText2定义的文本永远使用字型渲染。设备文本永远不包含透明性。&lt;/p&gt;

&lt;p&gt;最小的版本要求是SWF3。&lt;/p&gt;

&lt;p&gt;&lt;img alt='definetext2' src='/assets/definetext21.png' /&gt;&lt;br /&gt;&lt;img alt='definetext2' src='/assets/definetext22.png' /&gt;&lt;/p&gt;

&lt;h1 id='id10'&gt;动态文本标签&lt;/h1&gt;

&lt;h2 id='defineedittext'&gt;DefineEditText&lt;/h2&gt;

&lt;p&gt;DefineEditText定义的是动态文本对象，或者文本域。&lt;/p&gt;

&lt;p&gt;文本域和AS里的变量名关联在一起。可以读写变量内容，并且和显示保持一致。如果ReadOnly没有设置，那么用户就可以交互的修改内容。&lt;/p&gt;

&lt;p&gt;这里使用的字体一定是DefineFont2定义的，而不能是DefineFont。&lt;/p&gt;

&lt;p&gt;最低的版本要求是SWF4。&lt;/p&gt;

&lt;p&gt;&lt;img alt='defineedittext' src='/assets/defineedittext1.png' /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt='defineedittext' src='/assets/defineedittext2.png' /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt='defineedittext' src='/assets/defineedittext3.png' /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt='defineedittext' src='/assets/defineedittext4.png' /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt='defineedittext' src='/assets/defineedittext5.png' /&gt;&lt;/p&gt;

&lt;p&gt;如果HTML字段设置了，InitialText的内容就会被解释为HTML的一个子集。下面是所有支持的标签。&lt;/p&gt;

&lt;p&gt;&lt;img alt='html' src='/assets/html1.png' /&gt;&lt;br /&gt;&lt;img alt='html' src='/assets/html1.png' /&gt;&lt;/p&gt;

&lt;h2 id='csmtextsettings'&gt;CSMTextSettings&lt;/h2&gt;

&lt;p&gt;除了高级文本渲染，渲染引擎还支持修改文本域的标签。CSMTextSetting会修改前面的DefineText，DefineText2，DefineEditText。CSMTextSettings可以打开或者关闭文本域的反锯齿，还可以用于定义quality和option。&lt;/p&gt;

&lt;p&gt;最低的版本要求是SWF8。&lt;/p&gt;

&lt;p&gt;&lt;img alt='csmtextsetting' src='/assets/csmtextsettings1.png' /&gt;&lt;br /&gt;&lt;img alt='csmtextsetting' src='/assets/csmtextsettings2.png' /&gt;&lt;br /&gt;&lt;img alt='csmtextsetting' src='/assets/csmtextsettings3.png' /&gt;&lt;/p&gt;

&lt;p&gt;粗细和锐度字段会应用到特定文本域，这会覆盖那个文本域的默认值。&lt;/p&gt;

&lt;p&gt;在渲染时，通过如下方式计算：&lt;/p&gt;

&lt;p&gt;&lt;img alt='csmtextsettingcalc' src='/assets/csmtextsettingcalc.png' /&gt;&lt;/p&gt;

&lt;p&gt;计算时使用字体大小会生成更加线性的缩放效果，并且进行很明显的文本缩放时，线性缩放会生成不好的近似效果。进行文本缩放时最好使用默认表格作为反锯齿表格。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>使用jekyll时，发现liquid的一个小问题</title>
   <link href="http://zhuzhonghua.github.com/essays/2012/10/27/jekyll-liquid-assign-bug"/>
   <updated>2012-10-27T00:00:00+08:00</updated>
   <id>http://zhuzhonghua.github.com/essays/2012/10/27/jekyll-liquid-assign-bug</id>
   <content type="html">&lt;p&gt;想实现的效果是正序排列，而不是默认的逆序排列。&lt;/p&gt;

&lt;p&gt;使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;site.posts | sort:&amp;quot;date&amp;quot;   &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;能够达到效果。&lt;/p&gt;

&lt;p&gt;但是使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assign pages_list = site.posts | sort:&amp;quot;date&amp;quot;   &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就不行。&lt;/p&gt;

&lt;p&gt;在github的liquid项目里也提了issue, &lt;a href='https://github.com/Shopify/liquid/issues/154'&gt;https://github.com/Shopify/liquid/issues/154&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;有人回答说，把空格去掉，也就是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assign pages_list = site.posts|sort:&amp;quot;date&amp;quot;   &lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是经过测试，还是不行。&lt;/p&gt;

&lt;p&gt;我使用的是jekyll-bootstrap，从github上clone下来的。&lt;/p&gt;

&lt;p&gt;目前，我使用的是如下方式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for item in site.posts reversed     
endfor    &lt;/code&gt;&lt;/pre&gt;</content>
 </entry>
 
 <entry>
   <title>珍爱生命，使用Python</title>
   <link href="http://zhuzhonghua.github.com/essays/2012/07/19/zhenaishengming-shiyongpython"/>
   <updated>2012-07-19T00:00:00+08:00</updated>
   <id>http://zhuzhonghua.github.com/essays/2012/07/19/zhenaishengming-shiyongpython</id>
   <content type="html">

&lt;p&gt;今天在写测试程序时，用到了Python的多线程。&lt;/p&gt;

&lt;p&gt;首先声明，在真实环境中不要使用Python的多线程，如果要用，那也得用C写的扩展。&lt;/p&gt;

&lt;p&gt;碰到一个所有人都会遇到的问题，要结束，强制结束某一个线程。&lt;/p&gt;

&lt;p&gt;网上也查了很多资料，一般都是要DIY设计，通过信号啊，变量啊，等等。&lt;/p&gt;

&lt;p&gt;我宁愿用异常让整个程序退出，也不愿这么写。&lt;/p&gt;

&lt;p&gt;当然Python的设计哲学是不建议强制结束线程的。&lt;/p&gt;

&lt;p&gt;在查看Thread的所有方法时，发现了一个_Thread__stop()的方法，果然好用。&lt;/p&gt;

&lt;p&gt;在此做个记录。&lt;/p&gt;

&lt;p&gt;再次声明，这只是在测试时，为了简单，直接，才使用的方法。&lt;/p&gt;

&lt;p&gt;如果在真实环境中使用，后果自负。&lt;/p&gt;

&lt;p&gt;======分割线==================
C++真的不适合网络游戏开发。&lt;/p&gt;

&lt;p&gt;我们先建立几个共识，这样分析起来比较方便。&lt;/p&gt;

&lt;p&gt;1，C++代码要比Python代码效率不止高一点两点，有人做过测试，大概是20倍左右。&lt;/p&gt;

&lt;p&gt;2，看代码的时间要比写代码的时间多很多，而且大部分时间在改BUG。&lt;/p&gt;

&lt;p&gt;3，最经常出现的，也是最痛苦的BUG，内存泄露，空指针，野指针，内存写坏。&lt;/p&gt;

&lt;p&gt;4，团队里上面这些BUG也许只占5%，但是会占用95%的时间，而且有些BUG是在正式运营的时候才出现的，所以你知道这造成的影响。而且即使出现了这些BUG，一时半会也不一定能改掉。&lt;/p&gt;

&lt;p&gt;5，Python写起来要比C++写起来快。&lt;/p&gt;

&lt;p&gt;6，如果你用了线程，那么就和3一样了。&lt;/p&gt;

&lt;p&gt;如果我做一个策划的需求，使用Python要比使用C++写的快，不止快一点。&lt;/p&gt;

&lt;p&gt;而且你也知道，策划的需求变化是随时的，经常的，如果使用C++来应对这种变化，明显是慢的。&lt;/p&gt;

&lt;p&gt;但是如果使用Python来做，就会很快了；而且策划也可以配合修改。&lt;/p&gt;

&lt;p&gt;使用C++改BUG时，如果是碰到野指针，内存写坏，内存泄露，那你就祈祷吧。&lt;/p&gt;

&lt;p&gt;使用Python就不会出现这个问题。&lt;/p&gt;

&lt;p&gt;而且改其他的BUG，Python也更容易修改，当然也更快了。&lt;/p&gt;

&lt;p&gt;使用C++很容易写出Hard-Test的代码，于是正确性就有问题了。&lt;/p&gt;

&lt;p&gt;这方面可以参考PG的H&amp;amp;P。&lt;/p&gt;

&lt;p&gt;当然C++的优势在效率，而且可以利用多核的优势。&lt;/p&gt;

&lt;p&gt;在此奉劝使用多线程的C++使用者，能用多进程，就不要用多线程。&lt;/p&gt;

&lt;p&gt;于是我可以使用多进程的方式来利用多核的优势。&lt;/p&gt;

&lt;p&gt;效率上达不到要求，那我就多开几个进程，来保证业务及时完成。&lt;/p&gt;

&lt;p&gt;这样确实硬件成本增加了，要多买几台机器来多运行几个进程。&lt;/p&gt;

&lt;p&gt;可是这多出来的几个硬件成本，相对于研发的成本不知道省了多少。&lt;/p&gt;

&lt;p&gt;包括待遇，时间，以及过长时间带来的其它非研发人员的成本，
以及使用C++导致的BUG带来的各种损失，包括不能及时改掉BUG带来的时间损失，以及程序出错带来的运营损失。等。&lt;/p&gt;

&lt;p&gt;所以从总体上来看，这其实是节省了成本。&lt;/p&gt;

&lt;p&gt;而且按照这种思路，以大局考虑，总体考虑，来分析下面的问题。&lt;/p&gt;

&lt;p&gt;二八原理，当分析程序的效率时，只需要找出那20%的代码，来优化，就可以达到很好的效果。&lt;/p&gt;

&lt;p&gt;而且按照上帝的说法，过早优化是万恶之源。&lt;/p&gt;

&lt;p&gt;所以可以使用C++写扩展来改写那20%的代码，就可以达到优化的目的。&lt;/p&gt;

&lt;p&gt;而且从总体上来看，这才是优化之道。&lt;/p&gt;

&lt;p&gt;这样看来，使用Python代替C++的前提是你得有一个可以多进程代替多线程的服务器机制。&lt;/p&gt;

&lt;p&gt;C++有自己的优势，而且使用C++的人，尤其是使用C++写服务器的人，天生对内存和效率敏感。&lt;/p&gt;

&lt;p&gt;总结下来，C++适合写稳定的，不会随便改动的代码，比如网络层。而Python适合写经常变化的代码，比如策划的需求。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>爱惜小拇指，远离Emacs，伟大的Emacs  ASCII图模式</title>
   <link href="http://zhuzhonghua.github.com/essays/2012/07/18/emacs-ascii"/>
   <updated>2012-07-18T00:00:00+08:00</updated>
   <id>http://zhuzhonghua.github.com/essays/2012/07/18/emacs-ascii</id>
   <content type="html">

&lt;p&gt;今天介绍一下Emacs的ASCII图模式。&lt;/p&gt;

&lt;p&gt;我经常会在工作的时候，手边有一个笔记，写写画画，把自己的思路写出来。&lt;/p&gt;

&lt;p&gt;有时候要画框架图，又很想跟同事分享，总不能拿个本子，到处晃荡。而且还得保证不能弄丢，弄脏。&lt;/p&gt;

&lt;p&gt;这时候Emacs的ASCII图模式出场了。&lt;/p&gt;

&lt;p&gt;最终的结果是个平文本，你拿着平文本想干什么干什么，给别人分享，发表，保存，只要你做的事情支持平文本就行。&lt;/p&gt;

&lt;p&gt;别人的电脑上也不用装什么特别的软件，Notepad就可以了。&lt;/p&gt;

&lt;p&gt;随便打开一个文件，M-x edit-picture就可以进入这个模式。&lt;/p&gt;

&lt;p&gt;ASCII图就是线，各种线，就和我们在笔记上画图一个效果。&lt;/p&gt;

&lt;p&gt;向左画条线，使用C-c &amp;lt;就可以一直向左画。向右你猜一下。向上其实你可以猜到。  &lt;br/&gt;
向下是，C-c .  &lt;br/&gt;
左上是，C-c ` 就是主键盘区左上那个   &lt;br/&gt;
右上是，C-c &amp;#8217; 就是主键盘区双引号那个  &lt;br/&gt;
如果左下是 C-c /    你猜猜右下是那个&lt;/p&gt;

&lt;p&gt;八个方向都有了，你可以想往哪画就往哪画了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>我贡献一个makefile.template</title>
   <link href="http://zhuzhonghua.github.com/essays/2012/07/17/wogongxianyigemakefiletemplate"/>
   <updated>2012-07-17T00:00:00+08:00</updated>
   <id>http://zhuzhonghua.github.com/essays/2012/07/17/wogongxianyigemakefiletemplate</id>
   <content type="html">

&lt;p&gt;伟大的Makefile，伟大的Make， 伟大的GNU&lt;/p&gt;

&lt;p&gt;只不过规则前面的Tab有时很让人蛋疼，不知道是只能这样？还是有其他更好的替代方案？不知道，留待以后更聪明的人解答吧。&lt;/p&gt;

&lt;p&gt;Make会生成一堆的中间文件，如果和原文件混杂在一起，就会比较混乱，所以一般期望的是中间文件单独放在一起。&lt;/p&gt;

&lt;p&gt;在网上也查了很多资料，当然会查到云风的博客上，我这里提供另外一种思路。&lt;/p&gt;

&lt;p&gt;原来依赖&lt;em&gt;.o的，现在一律依赖build/&lt;/em&gt;.o&lt;/p&gt;

&lt;p&gt;原来的&lt;em&gt;.o生成规则，现在一律是build/&lt;/em&gt;.o生成规则。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TMP=build    

sources:=main.cpp    

OBJS=$(sources:%.cpp=$(TMP)/%.o)

DEST:$(OBJS)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来是一些依赖关系，使用sed流操作，把依赖关系生成到单独的文件中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#.o:.cpp
include $(sources:%.cpp=$(TMP)/%.d1)
#.d:.cpp
include $(sources:%.cpp=$(TMP)/%.d2)

$(TMP)/%.d1:%.cpp Makefile
    set -e;rm -f $@;\
    g++ -MM $(CPPFLAGS) $&amp;lt; &amp;gt; $*.$$$$;\
    sed 's,\($*\)\.o[ :]*,$(TMP)/$*.o : ,g' &amp;lt; $*.$$$$ &amp;gt; $*.$$$$.$$$$;\
    rm -f $*.$$$$; \
    sed '$$a\   g++ -c $&amp;lt; -o $(TMP)/$*.o $(CPPFLAGS)' &amp;lt; $*.$$$$.$$$$ &amp;gt; $@; \
    rm -f $*.$$$$.$$$$

$(TMP)/%.d2:%.cpp Makefile
    set -e;rm -f $@;\
    g++ -MM $(CPPFLAGS) $&amp;lt; &amp;gt; $@.$$$$;\
    sed 's,\($*\)\.o[ :]*,$(TMP)/$*.d1 $@ : ,g' &amp;lt; $@.$$$$ &amp;gt; $@;\
    rm -f $@.$$$$; \
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，所有的中间文件都在build/下面，也不会污染代码目录了&lt;/p&gt;

&lt;p&gt;=========分割线=======================&lt;/p&gt;

&lt;p&gt;出现个问题，如果makefile更新，d1，d2文件也要更新，所以要在d1和d2文件的依赖后面添加Makefile&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>游戏里嵌入语音系统</title>
   <link href="http://zhuzhonghua.github.com/essays/2012/07/16/youxiliqianruyuyinxitong"/>
   <updated>2012-07-16T00:00:00+08:00</updated>
   <id>http://zhuzhonghua.github.com/essays/2012/07/16/youxiliqianruyuyinxitong</id>
   <content type="html">

&lt;p&gt;中国的玩家一般都会使用YY作为语音交流系统。&lt;/p&gt;

&lt;p&gt;我说的不是这个。&lt;/p&gt;

&lt;p&gt;今天听到同事，在说游戏里一个好玩的人，看到游戏里红名的人，就一顿爆揍，之后说一句“汝知错否？！”&lt;/p&gt;

&lt;p&gt;配合上当时的情景，确实挺好玩。&lt;/p&gt;

&lt;p&gt;我突然想到，如果这句搞笑的话，在游戏里是用语音的形式播放给周围的玩家，是不是更好玩一些？&lt;/p&gt;

&lt;p&gt;现在游戏里的声音，基本上都是固定好的，比如砍人，比如碰撞，这些声音都是事先录制好的。&lt;/p&gt;

&lt;p&gt;如果多一些随机的，玩家自己的声音，是不是要有趣一些？！&lt;/p&gt;

&lt;p&gt;前段时间比较火的Tom猫，就是用户自己的声音，换个人说出来，就体现出一些好玩的事情。&lt;/p&gt;

&lt;p&gt;当然它还有一些其它玩法。&lt;/p&gt;

&lt;p&gt;如果这些声音再配合上不同的语调，语气，。。。。&lt;/p&gt;

&lt;p&gt;我只是在这里瞎想，不知道有没有公司已经做出这样的系统出来了。&lt;/p&gt;

&lt;p&gt;李开复先生就是靠语音系统成名的，而且现在也有很多成熟的技术，我知道的就有读电子书的软件。&lt;/p&gt;

&lt;p&gt;所以技术上，应该是可行的。&lt;/p&gt;

&lt;p&gt;在此留作Memo，将来自己有机会去主持这样一个游戏的时候，可以试着加入这样的系统。&lt;/p&gt;

&lt;p&gt;======分割线=========================================================
Next day 更新。&lt;/p&gt;

&lt;p&gt;Siri不是挺火的么？！然后很多公司都去做这样的语音助手。&lt;/p&gt;

&lt;p&gt;如果游戏里也加入这样的语音助手，不知道会怎么样？&lt;/p&gt;

&lt;p&gt;但目前看到，这是将来的一个技术发展方向。&lt;/p&gt;

&lt;p&gt;所以如果想玩，还是有很多东西可以继续玩的。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>在Vim中爬行</title>
   <link href="http://zhuzhonghua.github.com/essays/2012/07/13/zai-vimzhong-pa-xing"/>
   <updated>2012-07-13T00:00:00+08:00</updated>
   <id>http://zhuzhonghua.github.com/essays/2012/07/13/zai-vimzhong-pa-xing</id>
   <content type="html">

http://www.rudism.com/s/vimcreep
HackerNews 精彩评论
http://news.ycombinator.com/item?id=4235876&lt;/p&gt;

&lt;p&gt;一切从足够无知开始。在大学第一年，你尝试过几次，但Nano和Pico很容易且很接近你高中时期在Windows和Mac上的使用体验。但随着时间的推移，而且随着你在大学计算机课程上获得更多的经验，你开始注意到一些事情：所有真正伟大的程序员-用4行代码搞定你用10页代码搞定的任务；一天写了很多可笑并且丰富的类工程，而你却好几个星期挣扎在基础上-没有人使用Nano或者Pico。&lt;/p&gt;

&lt;p&gt;你熬夜很晚来完成午夜要完成的任务，碰巧瞥了安静的超级程序员的肩膀一瞥。你的眼睛闪烁发光，看着显示器上一行一行的亮光，在深夜的计算机实验室，你看到了让人敬畏的不可能的代码模式和文本操作，在屏幕上闪过。&lt;/p&gt;

&lt;p&gt;“你如何做到的？”你怀疑的问道。&lt;/p&gt;

&lt;p&gt;简单的回应了永远改变你的生活的一声：“Vim”&lt;/p&gt;

&lt;p&gt;起初，你很沮丧，没有效果。你的浏览器的历史基本上是一个完整在线VIM文档的索引;你的使用Nano和Pico的朋友觉得你疯了；您的使用Emacs的朋友乞求你改变主意；你花了点钱买了一个Vim小抄本为方便参考。即使过了好几个星期的训练后，你仍想要去拿鼠标，然后停下来，意识到，你必须开网页，再学习正确的方法来执行一些平凡的任务，你以前甚至从未想过。&lt;/p&gt;

&lt;p&gt;但是，随着时间的推移，你挣扎地越来越少。你不知道什么时候发生的，但Vim不再是一个障碍。相反，它大大超过你的预期。它不再是单纯的文字编辑器，绑定了快捷键，它已经成为你身体的延伸。而且是，作为一个程序员，你的本质延伸。&lt;/p&gt;

&lt;p&gt;单独编辑源代码，现在看起来没有充分的使用VIM。你把它装在家里的所有机器上，并用它来写一切，从电子邮件到英语试卷。你在便携设备上安装了一个便携式版本，连同一个很好调试过的，定制过的.vimrc，这样你可以在你去过的任何地方带着vim，陪着你，安慰你，让你觉得你有有一点家的感觉在你的口袋里，无论你在哪里。&lt;/p&gt;

&lt;p&gt;VIM进入了你在线生活的每部分。不满足于ViewSourceWith的少量功能，你开始使用Vimperator，然后Pentadactyl。你以前只是在网上冲浪。现在，你就是网络。当你决定写一个iPhone应用程序，你做的第一件事是把XCode的默认编辑器设为MacVim。当你找到了一份工作，写.NET代码，你马上购买了为Visual Studio定制的ViEmu（不满意他的免费表弟，VsVim）。&lt;/p&gt;

&lt;p&gt;深夜，当你在你的小房间，让你的键盘奴隶一样的，勤奋的工作，完成一个第二天早上截止的项目，你对自己笑了，因为你知道没有普通的程序员可以在截止日期前完成手头的任务。你录制了宏，你用一个手指轻轻的挪动了整个代码块，你使用了几十个寄存器，你改写和重构整个组件，甚至没有看你的鼠标一眼。这时候，你注意到了您的显示器的反射。瞪着大眼的同事从后面看过来你的肩膀。你停了下来，让他知道，你知道他的存在。&lt;/p&gt;

&lt;p&gt;“你如何做到的？”他问道，的声音充满了敬畏。&lt;/p&gt;

&lt;p&gt;你微微一笑，准备说出一个字，那曾经改变了你的生活。你的同事应该选择追逐，这个字会引导他进入相同的兔子洞，一个无限组合，无限可能的天地，产生一个高效的形式，那以前只在他最疯狂的梦想中出现过。他提醒你自己，很多年前站在漆黑的实验室，当你说出这个字时，你感觉到他有一丝激动。&lt;/p&gt;

&lt;p&gt;“VIM”。&lt;/p&gt;

&lt;p&gt;：WQ&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>dota2 valve Bram Cohen BT</title>
   <link href="http://zhuzhonghua.github.com/essays/2012/07/11/dota2-valve-braham-cohen-bt"/>
   <updated>2012-07-11T00:00:00+08:00</updated>
   <id>http://zhuzhonghua.github.com/essays/2012/07/11/dota2-valve-braham-cohen-bt</id>
   <content type="html">

&lt;p&gt;新闻说，Dota2的中国代理给完美了。   &lt;br/&gt;
多么伟大的游戏，希望完美别浪费了。&lt;/p&gt;

&lt;p&gt;只是很多人担心它的收费问题。确实它不像普通的MMO游戏，或者FPS游戏可以卖道具。  &lt;br/&gt;
并且听说它还要免费玩，那就不能通过时间收费了。  &lt;br/&gt;
以前看到别人玩过，说是要靠卖英雄，有些英雄不免费供给玩家用。  &lt;br/&gt;
最新的消息，他们说这会影响游戏的平衡。   &lt;br/&gt;
于是他们要通过商城卖装饰，来盈利。&lt;/p&gt;

&lt;p&gt;这是一个点，而且我以前也看到过一个游戏，强大的Avatar系统。
通过切身体验，我会感觉别人的装饰很好玩，很有感。&lt;/p&gt;

&lt;p&gt;或许他们应该通过限时装饰来收费，这样能多赚一些钱。  &lt;br/&gt;
而且现实生活中也有这样的情景，女人喜欢买很多衣服。&lt;/p&gt;

&lt;p&gt;在这里我构想另一种收费方式。付费战场和免费战场。&lt;/p&gt;

&lt;p&gt;付费战场满足人民币玩家花钱的欲望，获得快感。而且让人民币玩家和人民币玩家对抗，产生对抗快感。  &lt;br/&gt;
人民币玩家还可以赠送免费玩家道具来帮助人民币玩家在游戏里和别人对抗。 &lt;br/&gt;
现实生活中就有很多这样的场景，我就曾经玩街机时，被人赠送游戏币，陪玩。&lt;/p&gt;

&lt;p&gt;免费战场还是按照原来的方式吸引人气，通过装饰挣钱。
或许付费战场还可以分等级，有些道具很贵只能在有些战场能用。&lt;/p&gt;

&lt;p&gt;人法地，地法天，天法道，道法自然。  &lt;br/&gt;
如果没有思路了，可以参考一下现实生活中的例子。&lt;/p&gt;

&lt;p&gt;IceFrog原来在Valve工作，哎，暴雪怎么没开发一个Dota类型的网游呢？！  &lt;br/&gt;
不过如果暴雪开发的话，又要耗时好几年，跳几次票，才能出来。 &lt;br/&gt;
不知道这种开发方式好，还是不好。&lt;/p&gt;

&lt;p&gt;Valve没有上市，只有250名员工。很多人猜测它的盈利利润其实远远超过了Google这样的巨型公司了。  &lt;br/&gt;
闷声赚大钱的典范。
而且它的文化是，没有老板。Github也采用了这样的文化。&lt;/p&gt;

&lt;p&gt;Steam是为了解决他们公司游戏版本更新的问题。
这样不错哦。&lt;/p&gt;

&lt;p&gt;游戏的推广确实是个大手笔。  &lt;br/&gt;
像腾讯这样的公司，有自己的推广平台，几乎不要什么钱。这样等于节省了成本，当然盈利也就多了。  &lt;br/&gt;
如果没有什么自己的推广平台，那就要花钱去别人的平台上推广，这样就等于增加了成本。  &lt;br/&gt;
而且这个成本不是一点半点。要比研发费用高很多。  &lt;br/&gt;
不过这样的平台建立也不是容易的。&lt;/p&gt;

&lt;p&gt;而Steam最初为了解决版本更新问题，到后来可以发展为推广平台了。而且已经有很多游戏和Steam合作了。&lt;/p&gt;

&lt;p&gt;这个思路不错，不知道国内有没有人采用这种方式。
一解决了游戏更新的问题，二可以作为一个推广平台来运营。 岂不是一举两得。&lt;/p&gt;

&lt;p&gt;这些东西的背后当然要感谢BT了，那就是感谢BT的作者。&lt;/p&gt;

&lt;p&gt;Bram Cohen 生于1975，当然是伟大的程序员了，为什么非得说是计算机程序员呢？！难道还有第二种程序员？！  &lt;br/&gt;
1993年毕业于Stuyvesant中学，难道没有上过大学？！牛X。  &lt;br/&gt;
他曾在几家网络公司工作过，做过的最后一个项目是MojoNation，从事他最为擅长的“网络数据分布传输技术”的研发。
之后因为老板没有接受他的意见，推广它，所以他不干了。
此后他离职在家，潜心研发这种新技术。BT的Beta测试版在2001年问世了。
在同年的一次Linux开源软件大会中，他的BT软件首次亮相。
试用时，极客们发现，在传输百兆以上的大型文件时，BT的速度要比普通的ADSL快上千倍。
而且使用的人数越多，种子就越多，速度也就越快，因此数据传输不再受带宽和流量的限制。
极客们如获至宝般争相下载BT软件，并把它作为传播Linux和大型程序的主要工具。
2002年，在一场黑客论坛上，他公开了BT的所有源代码，表示希望以开源的方式让BT更加完善。
这一举动让BT声名大噪，使用人数成倍增长。
BitTorrent真正流行起来是在2003年初，它被用来发布一个新版的Linux。
与此同时，还有一些日本卡通的fans凭籍它来共享动画片。
当然他为了推广，吸引更多的人来使用这个软件，并测试它，也做了很多其它事情。这里就不说了。
BitTorrent对于Cohen来说，一直是一种脑力训练而不是一种赚钱的途径。
BitTorrent不但是免费的，而且还是开源的。
这意味着只要有足够能力，你完全可以把BitTorrent融入到你自己的程序里面。
尽管BitTorrent获得了如此巨大的成功，但它并没有为Cohen带来过一分钱。
他当时只好利用一张信用卡的免息期来透支，填补另一张信用卡的帐单来过活。
Cohen那时并不知道，BitTorrent会为他带来一份工作。
某天，他的事情为Valve软件公司的常务董事Gabe Newell所获悉。
尽管Valve正在开发令游戏玩家望眼欲穿的Half-Life 2，但是它同时也在建立一个名为Steam的在线分发网络。
由于Cohen掌握这个领域的技术，所以Valve为他提供了一个职位。
Cohen从十月 份起搬到西雅图，开始了他的工作。
一直以来，Cohen都有通过他的网站bitconjurer.org来接受BitTorrent用户的捐款，但是这笔金额一直很少。
然而从10月份开始，Cohen父亲鼓励他请求的更直接一点。
如今，Cohen称，他每天都能收到上百美元的捐款。
“在过去的几个月，我的生活方式发生了相当戏剧性的变化，获得工作还有捐款的到来，”Cohen说，“这好极了。”
Cohen患有Asperger综合症，中文名为孤独样精神障碍，这使他具有高度的集中力，但是在社交上存在障碍。
Cohen目前和他的妻子孩子居住在华盛顿的Bellevue。&lt;/p&gt;

&lt;p&gt;这里做个评论，BT从原型开发，到测试版本开发，到可用，到流行，到为作者带来收入，这中间也经历了好几年。  &lt;br/&gt;
那同样作为程序员的我们，不要想着某一天写了一个XX软件，第二天就爆发了。  &lt;br/&gt;
这告诉我们，要懂得积累，沉淀，专注。&lt;/p&gt;

&lt;p&gt;他的个人网站上，有他的twitter地址。前面说他接受捐款的网站就是他的个人网站了。
他的facebook主页： www.facebook.com/bram.cohen&lt;/p&gt;

&lt;p&gt;他现在在bittorrent.com工作，作为老板。  &lt;br/&gt;
最新的消息是这个http://www.36kr.com/p/83143.html&lt;/p&gt;

&lt;p&gt;让我们拭目以待他目标实现的那一天吧。&lt;/p&gt;

&lt;p&gt;BT这个伟大的东东，中国也有个国内版本，那就是bitcomet。  &lt;br/&gt;
当时在市场上也是曾经的王者。  &lt;br/&gt;
只不过迅雷加入了这个战场，而bitcomet的作者又因为无厘头的原因，最终就变成这个状态了。  &lt;br/&gt;
现在他们已经转战游戏了，希望能在游戏领域获得成功。 &lt;br/&gt;
只是目前还没有什么成名作。&lt;/p&gt;

&lt;p&gt;BT这个东西是好东西，就看你能不能发挥了。Valve用它作出了自己的Steam平台，或许我们也可以考虑一下这个方向。&lt;/p&gt;

&lt;p&gt;我最近使用了一个快玩的软件，就是流氓快播的公司开发的。 &lt;br/&gt;
不知道他下载游戏时，是不是用的P2P？如果是的话，那就在这个领域前进了一步了。&lt;/p&gt;

&lt;p&gt;而且任何做游戏，尤其是端游的团队，都应该研究一下BT这个东西，解决下载的问题。  &lt;br/&gt;
微端游戏或许应该走这样一个方向。 另外一个方向，是我在研究的。不过Beta版本还没有出来，等出来再炫耀吧。&lt;/p&gt;

&lt;p&gt;现在一般页游都是通过CDN来解决问题的，如果WEB也有了P2P的东东，那岂不是和谐的世界。  &lt;br/&gt;
我已经加入了一个WebP2P的邮件列表，关注一下这个方向的最新进展。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>在mingw环境下编译最新版本gcc gdb</title>
   <link href="http://zhuzhonghua.github.com/essays/2012/06/07/mingw-gcc-gdb-environment"/>
   <updated>2012-06-07T00:00:00+08:00</updated>
   <id>http://zhuzhonghua.github.com/essays/2012/06/07/mingw-gcc-gdb-environment</id>
   <content type="html">

&lt;p&gt;由于比较喜欢GCC的东西，又必须做WIN下的程序，但是考虑到效率问题  &lt;br/&gt;
1，使用LINUX交叉编译MINGW下的程序  &lt;br/&gt;
2，直接使用MINGW和MSYS编译WIN程序&lt;/p&gt;

&lt;p&gt;使用交叉编译的方法，在网上搜到的比较麻烦，而且又不是做嵌入式开发，必须用交叉编译;  &lt;br/&gt;
所以决定使用第二种方法。&lt;/p&gt;

&lt;p&gt;目前已经成功编译了GDB7.4.1和最新的BINUTILS，还有MPC，MPFR，等GCC需要依赖的库。  &lt;br/&gt;
晚上回去看一下GCC4.7.0的编译情况。&lt;/p&gt;

&lt;p&gt;不过在公司已经使用MINGW-GET拿到了GDB7.4和GCC4.6.2,而且使用正常。&lt;/p&gt;

&lt;p&gt;目前是使用VIM做编辑器，使用EMACS做调试器（是不是有点小奢侈啊），幸好这两个神器都有WIN版本。&lt;/p&gt;

&lt;h1&gt;感谢GNU，感谢上帝。&lt;/h1&gt;

&lt;p&gt;2012-06-08&lt;/p&gt;

&lt;p&gt;昨晚回去，出现了诡异的dllcrt2.o文件找不到的问题  &lt;br/&gt;
由于时间有限，又急着建立开发环境，所以决定把公司里使用mingw-get的版本拿回去。  &lt;br/&gt;
奇怪的是，家里使用mingw-get无法获取各种包，也就是不能用。&lt;/p&gt;

&lt;p&gt;今天在公司，不甘心，利用业余时间终于把这个问题搞定。&lt;/p&gt;

&lt;p&gt;网上也有人遇到这个问题，文件是有的，在/mingw/lib下&lt;/p&gt;

&lt;p&gt;刚开始使用LDFLAGS无效，后来使用GCC_EXEC_PREFIX连configure都无法通过。&lt;/p&gt;

&lt;p&gt;在这个命令的下面看到了，LIBRARY_PATH，于是灵光一现，配置好/mingw/lib&lt;/p&gt;

&lt;p&gt;结果编译了一个下午, 公司的电脑还算好的。&lt;/p&gt;

&lt;p&gt;自己编译GCC真不是玩的。花的时间太久了。&lt;/p&gt;

&lt;p&gt;不过总算了解了自己的一个心病。&lt;/p&gt;

&lt;p&gt;而且在网上差资料，关于dllcrt2.o的东西，都是外文。这里也算有个中文的关于这个的资料吧。&lt;/p&gt;

&lt;p&gt;tips:&lt;/p&gt;

&lt;p&gt;1, BINUTILS要使用最新版本，这个编译起来很快。  &lt;br/&gt;
要不然会出现unknown-pseudo .cfi_sections
2, 还有它依赖的其他库文件&lt;/p&gt;

&lt;p&gt;其他问题就不大了，祝各位看官好运&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>sicp上的练习题Parsk三角</title>
   <link href="http://zhuzhonghua.github.com/essays/2012/06/05/sicp-parsk"/>
   <updated>2012-06-05T00:00:00+08:00</updated>
   <id>http://zhuzhonghua.github.com/essays/2012/06/05/sicp-parsk</id>
   <content type="html">

&lt;p&gt;SCIP上的一个习题  &lt;br/&gt;
用递归输出PARSK三角，也有叫杨辉三角的  &lt;br/&gt;
个人认为，使用递归更简单一些，不过作为练习，就这样了  &lt;br/&gt;
上代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defun parsk(n)
  (if (= n 1)
      (let ((ret (list 1)))
    (echo-list ret)
    ret)
    (let ((resn (list 1))
      (resn-1 (parsk (- n 1))))
      (do ((i 0 (+ i 1)))
      ((&amp;gt; i (- (length resn-1) 2)) 'done)
    (setq resn (append resn (list (+ (nth i resn-1)
                     (nth (+ i 1) resn-1))))))
      (setq resn (append resn (list 1)))
      (echo-list resn)
      resn)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中ECHO-LIST是个辅助函数，输出LIST&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defun echo-list(lst)
  (progn
    (dolist (obj lst)
      (format t &quot;~A &quot; obj))
    (format t &quot;~%&quot;)))
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>lisp的尾递归</title>
   <link href="http://zhuzhonghua.github.com/essays/2012/06/05/lisp-recursive-iteration"/>
   <updated>2012-06-05T00:00:00+08:00</updated>
   <id>http://zhuzhonghua.github.com/essays/2012/06/05/lisp-recursive-iteration</id>
   <content type="html">

&lt;p&gt;在common lisp 中，尾递归的概念确实很好&lt;br&gt;&lt;/p&gt;

&lt;p&gt;废话不多说，先上代码&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以著名的斐波那契数列为例：&lt;br&gt;&lt;/p&gt;

&lt;p&gt;1，递归版&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defun fib(n)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          (t (+ (fib (- n 1))
                (fib (- n 2))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2，迭代版（尾递归）&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defun fib(n)
    (fib-iter 1 0 n))

(defun fib-iter(a b count)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用第二种方式，可以减少堆栈空间的使用&lt;/p&gt;
</content>
 </entry>
 
 
</feed>