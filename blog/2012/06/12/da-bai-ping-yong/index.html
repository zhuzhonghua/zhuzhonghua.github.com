
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>打败平庸 - GNO Blog</title>
  <meta name="author" content="zhuzhonghua">

  
  <meta name="description" content="打败平庸 (本文取自2001年在 Franz 开发者大会的一篇演讲) 1995年夏天，朋友Rober Morris 和我创办了Viaweb，我们计划写一个让用户建立在线商店的软件。当时新颖的是，软件运行在我们的服务器上，使用普通的网页作为界面。 当然，当时可能很多人有同样的想法。但是据我所知， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zhuzhonghua.github.com/blog/2012/06/12/da-bai-ping-yong/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="GNO Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">GNO Blog</a></h1>
  
    <h2>GNO's Not Octopress Blog</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com.hk/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:zhuzhonghua.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">列表</a></li>
  <li><a href="http://www.paulgrahamcn.com" target="_blank">PaulGraham中文</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">打败平庸</h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-06-12T22:45:00+08:00" pubdate data-updated="true">Jun 12<span>th</span>, 2012</time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="http://www.paulgrahamcn.com/article/beatingtheaverages">打败平庸</a></p>

<p>(本文取自2001年在 Franz 开发者大会的一篇演讲)</p>

<p>1995年夏天，朋友Rober Morris 和我创办了Viaweb，我们计划写一个让用户建立在线商店的软件。当时新颖的是，软件运行在我们的服务器上，使用普通的网页作为界面。</p>

<p>当然，当时可能很多人有同样的想法。但是据我所知，Viaweb是第一个基于网页的。对于我们来说，这是一个非常新颖的主意，之后我们给公司起名：Viaweb。因为我们的软件是通过网站，而不是运行在你的电脑桌面上。</p>

<p>软件另一点不寻常的地方是，我们使用一个叫做Lisp的语言编写。这是最早用Lisp写的大型终端软件之一，在此之前，Lisp主要用在大学和研究室里。</p>

<p>The Secret Weapon
秘密武器</p>

<p>Eric Raymond写过一篇文章，“怎样成为黑客”，其中，他告诉将来的黑客应该学习什么编程语言。他建议从python或者java开始，因为它们很简单。高级黑客还应当学习c，来理解Unix；学习Perl，来管理系统和CGI。最后，真正的高级黑客需要考虑学习Lisp：</p>

<p>“lisp值得学习，当你最终掌握它时，你会获得深厚的启示经历；这段经历会让你今后成为一个更好的程序员，即使以后不会常常用到它。“</p>

<p>你会听到相同的学习拉丁语的原因。拉丁语不会给你一份工作，除非要当个古希腊文化教授，但是它能提升你的思想，让你成为一个更好的使用其它语言的作家，比如英语。</p>

<p>但是这个比喻在此并不适用。之所以学习拉丁语不能给你一份工作，是因为没人使用。如果你用它写作，没人能理解。但是Lisp是一个计算机的语言，计算机可以理解程序员告知它的任何语言。</p>

<p>但是，就像他说的，假如Lisp能让你成为一个更好的程序员，那你为什么不会去用它？假如一根画笔能让某人成为一个更好的画家，他应该会用这根画笔去画他所有的作品，不是吗？我不是想在这讽刺Eric Raymond。总体来说，他的建议是很好的。只是他对Lisp的看法是传统的观点，而这个观点有自相矛盾的地方，即Lisp能让你成为一个更好的程序员，但是你不会去使用它。</p>

<p>为什么不用？本质上，编程语言只是工具而已。如果Lisp确实能写出更好的程序，你当然应该用它；如果它不能，那没人会用它。</p>

<p>这不仅仅是一个理论问题。软件业是个竞争很激烈的行业，优胜劣汰。在其他条件一样的情况下，软件写的又快又好的公司，就能打败他的竞争对手。当你创业的时候，这种感觉是非常强烈的。要么得到所有，要么一无所有。不是富豪，就是穷光蛋。在创业起初，如果选错了技术，你的竞争对手就会干掉你。</p>

<p>Robert和我都很了解Lisp，我们找不到任何理由不去相信自己的直觉。其他人都用C++或者Perl，但那与我们无关。如果你准备和他们一样，那你一定在用Windows。从技术角度出发，你得忽略其他人的普遍做法，而只去思考最佳方案。</p>

<p>这更加适用于创业。大公司，可以做其他大公司都在做的事。但是创业公司不能这样。很多人没意识到这点，即使是创业者。</p>

<p>大企业平均每年增长10%的利润。所以如果你在管理大企业，那么就做一般大公司做的事情，只能期望一个一般的表现——每年10%左右的增长。</p>

<p>当然，这对创业者来说，也是一样。假如你和其他创业公司做一样的事情，你也只能有一般的表现。问题是，那样的表现意味着你会破产。创业公司的存活率低于50%。所以，如果你将要创业，最好另辟蹊径，否则，你就会陷入困境。</p>

<p>在1995年，我们明白一些其他竞争者不了解，即使现在也很少人理解的东西：写一个只会运行在自己的服务器上的软件时，你可以用任何你喜欢的语言。而当写个人桌面软件时，一种强烈的偏见是，你必须使用和操作系统一样的语言。10年前，编写应用程序意味着用C。但是基于网络的软件，特别是当你拥有操作系统和语言的源码时，你可以使用任何语言。</p>

<p>尽管如此，这种新的自由却是一把双刃剑。你可以使用任何语言，就得好好想想用哪种。那些不愿意冒险作出改变的公司会发现，他们的竞争对手可不一样。</p>

<p>如果你可以使用任何语言，你会选哪个？我们选择Lisp。首先，很明显，快速开发在这个市场是很重要的。我们都是白手起家，所以能早于竞争对手推出新功能就会有很大的优势。我们知道Lisp是一种编写软件非常快的语言，而基于服务器的软件又放大了这种影响，因为你可以在编写完成的第一时间发布你的软件。</p>

<p>如果其他公司不想用Lisp，那正好。这也许会让我们处于技术的边缘，我们需要任何可以得到的帮助。当我们创办Viaweb时，我们对毫无商业经验。我们对市场，雇佣员工，赚钱，吸引顾客都一无所知。我们俩也都没实际工作过，只擅长编写软件，我们希望这能拯救我们。我们要利用一切优势。</p>

<p>你可以说使用Lisp是一次实验。我们的设想是，假如用Lisp写软件，那就能比竞争对手更快的完成软件，能作对手作不到的事。因为Lisp的高级特性，我们不需要一个大的开发团队，所以花费也更少。如果能这样，我们就能提供更好的产品，或者更低的价格，仍然可以盈利。逐渐的，我们就能得到所有的客户，而对手们什么都得不到，直到退出这个行业。当然，这就是我们所期望的。</p>

<p>实验的结果如何？让人吃惊的是，成功了。一开始 我们有很多竞争对手，大约2，30个，但是他们的软件都无法和我们的相比。我们有一个所见即所得的在线商店创建程序，运行在服务器上，但是和个人桌面应用 程序没什么两样。竞争对手们使用CGI脚本，而我们总是在功能上遥遥领先。有时候，对手会拼命宣传我们没有的功能。但是Lisp大大缩短了开发周期，以至 于我们能在1到2天之内就复制一个竞争对手刚刚发布的新功能。当记者报道他们新发布的版本的时候，我们也有了同样的功能。</p>

<p>在竞争对手看来，我们似乎有某种秘密武器——我们能解密他们的Enigma机器或者别的东西。事实上，我们确实有一个秘密武器，但是比他们想象的简单得多。没有人泄露他们的秘密给我们，我们只是能以别人意想不到的速度开发软件。</p>

<p>我9岁的时候，看过Frederick Forsyth写的《刺杀戴高乐》。主角是一个被雇佣来刺杀法国总统的刺客。那个刺客需要越过警察，到一个可以俯瞰总统行走路径的旅馆。他从警察正面走过，伪装成一个杵着拐杖的老头，没有人对他起疑心。</p>

<p>我们的秘密武器也是这样。我们用一个充满了怪异括号，古怪的人工智能语言编写软件。很多年前，我对Lisp的这个特点感到厌烦，但是它现在却成了我们的优势。商业上，最强的技术优势就是，你用着竞争者不懂的技术。商业，和打仗一样，出奇才能制胜。</p>

<p>所 以，有点惭愧的说，当我们在作Viaweb的时候，从未在公开场合提到Lisp。我们从来没有对媒体提到它，如果你在我们网站上搜索Lisp，只会找到2 本我的藏书。这不奇怪，创业公司透露给它的竞争对手的信息越少越好。如果他们不知道，或者不关心我们的软件用什么写的，那正合我意。[2]</p>

<p>最 了解我们技术的是客户们。他们不关心Viaweb是用什么写的，只是知道它很好用。他们可以用Viaweb几分钟就建好一个漂亮的在线商店，所以，一传 十，十传百，我们有了越来越多的客户。1996年底，我们的在线商店是70个左右。1997年年底，我们有了500个。6个月后，当Yahoo收购我们 时，有1070个用户。今天，作为Yahoo Store，这个软件依旧统治着市场。也是Yahoo盈利很多的商品之一，而用它建立的商店，则是Yahoo Shopping的基础。我1999年离开Yahoo，所以不知道他们现在有多少用户了，但是最近一次听说是20000。</p>

<p>The Blub Paradox
Blub矛盾原则</p>

<p>Lisp 到底强在哪里？如果Lisp这么强大，为什么这么少人用？听起来是个复杂的问题，但是答案很直接：Lisp不仅因为，只有喜欢它的人才能看到它的强大，还 因为它是你可以使用的最强大的语言。不是所有人都用Lisp的原因是，编程语言不只是技术，还包括头脑的习惯，而这些改变起来都很缓慢。当然，这里需要解 释一下。</p>

<p>我从一个非常有争议的声明开始说起：编程语言的威力是不一样的</p>

<p>至少，大部分人会同意，高级语言比机器语言强大。如今，很多程序员都明白，用机器语言写程序很傻。你应该用高级语言，让编译器去把它转换成机器语言。这个观点甚至被用在硬件上了：20世纪80年代以来，汇编指令集开始为编译器设计，而不是为程序员。</p>

<p>所有人都知道手写机器语言编写程序是错误的。但很多人没理解另一个通用的观点：如果你可以选择许多种语言，他们其他地方都一样，那只有用最有威力的才是唯一正确的选择。[3]</p>

<p>这 个观点有很多例外。如果你需要写一个和某个语言写的程序工作很接近的程序，也许用同样的语言写这个程序会是个不错的选择；如果你需要写一个只作很简单的， 比如数字，位处理，你也许应该用抽象程度不那么高的语言，特别是当它能够运行得更快的时候；如果你只想写一个临时程序，也许你该用对这个任务来说，有最佳 的函数库的语言。但是，总的说来，对于应用程序，你应该能使用最有威力（最有效率）的语言。用别的语言都是个错误，因为那样几乎等于，虽然夸哦张了点，是 在用机器语言编程。</p>

<p>你们都知道机器语言是很低级的。但是，以社会上的普遍观点来说，高级语言通常都被认为是差不多的，其实不然。从技术上说，“高级语言”并不是一个精确的定义，而在低级语言和高级语言之间也没有明确的分界线。根据抽象程度的高低，编程语言形成了一个有序的梯队列表。[4]</p>

<p>看看Cobol。Cobol是一个高级语言，因为它需要编译成机器语言执行。但是会有人认真的说Cobol的威力和，比如Python，是一样的吗？它显然比Python更接近机器语言。</p>

<p>那 么Perl 4呢？从Perl 4到Perl 5，词法闭包添加了进来。大多数Perl黑客会同意，Perl 5比Perl 4更强大。一旦你也这么觉得，那就意味着你承认，一种高级语言可以比另一种更强大。除非特殊情况，接下来你自然会想要去用能得到的，最强大的语言。</p>

<p>但是，这个想法很少会和上述结论吻合。岁月流逝，程序员极少积极的更换使用的语言。人们一旦习惯使用某种语言，他们就会满足现状。</p>

<p>程序员和他们喜爱的语言特别亲近，而我也不想伤害任何人的情感。因此，为了说明这个观点，我将使用一个假设的语言：Blub。Blub处于语言抽象程度列表的中间位置，它不是最强大的语言，但是比Cobol或者机器语言要强大。</p>

<p>而事实上，我们的Blub程序员2者都不会用。他当然不会想要用机器语言写程序，那是编译器干的事。至于Cobol，他不了解怎么用它解决问题，因为它没有X功能(设想的某种功能)。</p>

<p>我 们假设的Blub程序员如果从语言抽象程度列表往下看，他能知道自己是在往下看。比Blub弱的语言明显的弱很多，因为缺少他已经习惯的一些功能。但是， 假如我们的Blub程序员从相反的方向去看，他却不会觉得自己是在往上看。因为他看到的都是古怪的语言。他也许会认为那都是和Blub差不多的语言，只是 长相稀奇古怪而已。Blub对他来说足够了，因为他是在用Blub思考。</p>

<p>当我们从另外一个，使用更高级的语言的程序员的角度来看时，又会如何？你用Blub能作什么呢？它连Y功能都没有。</p>

<p>简 单的说，只有理解最强大语言的程序员，才会对整个列表的高级语言的威力，有一个全面的了解。（这也许就是Eric Raymond说的，Lisp会让你成为一个更好的程序员的原因。）你不能相信其他人的看法，因为Blub矛盾原则：他们对自己习惯的语言感到满足，因为 这符合他们思考程序的方式。</p>

<p>我自己的经历证明了这点，当时我还在高中用Basic写程序时。那种语言甚至不支持递归。很难想象不用递归来写程，但是我当时不这么觉得。我以Basic的方式思考，成了Basic的专家，掌握了所有我能了解到的。</p>

<p>Eric Raymond推荐给黑客的5种语言，位于语言威力列表中不同的位置，而他们之间的比较则是个容易引起争吵的话题。我想说的是，我觉得Lisp是在最顶层 的。为了证明这个观点，我会指出一个其他四种语言没有的特性。他们甚至不支持宏(Macro)，我能用它能作什么呢？[5]</p>

<p>许多语言都一 个被叫做“宏”的东西，但是Lisp的宏是不同的。信不信由你，它们作的都是和括号相关的。Lisp的设计者并不是只是为了与众不同才使用那么多括号。对 Blub程序员来说，Lisp的代码看起来很古怪。但是，这些括号的出现是有原因的。这使得Lisp从外表上看起来，和其他语言有本质的不同。</p>

<p>Lisp代码是由Lisp数据对象组成的。别的语言一般会设计成：源文件包含字符，字符串是则是该语言所支持的数据类型之一。而当解析器读取Lisp代码时，你会发现Lisp是由你可以遍历的数据结构组成的。</p>

<p>如 果你明白编译原理，就会可以理解Lisp的这种奇怪的语法，或者说没有语法的语法。其他语言会被编译器解析成解析树，而你在Lisp中，就是用这种解析树 的结构写程序。这些解析树对你的程序来说是可读的，因此就可以写程序来维护它们。在Lisp里，这样的程序称为宏。它们是可以生成程序的程序。</p>

<p>可 以生成程序的程序？什么时候会需要这么作？如果你用Cobol的方式思考，这种需求并不常见；如果用Lisp的方式思考，你会经常想要这么作。这里如果能 给出一个强大的宏的例子，也许会比较方便阐明。但是对一个不懂Lisp的人来说，会觉得那像是在胡扯，我没办法把需要让你理解宏的预备知识在这里说清楚。 在《Ansi Common Lisp》这本书里，我已经很快的引导读者理解所有的东西，尽管如此，在160页之前，我都没有提到宏。</p>

<p>我 能给出一个有说服力的例子。Viaweb编辑器的源码有20％－25％是宏。宏比普通的Lisp函数要难写，在不需要的地方使用也是个坏习惯。所以，宏存 在于那里是因为它必须存在。这就是说，在这个程序里，有20％－25％的部分是你用别的语言难以实现的。Blub程序员可能会对我声称的，Lisp如此神 气的威力，感到怀疑和好奇。我们写这些代码不是只给自己看看而已。我们是个很小的创业公司，所以尽最大的力在我们和竞争者之间构筑了一道技术的壁垒。</p>

<p>感到疑惑的人也许会想，你说的这些东西都有什么关联？我们的一大段代码，是在作用别的语言很难实现的工作，这样，我们就能人所不能。也许这就是关键所在，我鼓励你顺着这个角度去思考。也许这个杵着拐杖的老头可不简单哦。</p>

<p>Aikido for Startups
创业之道</p>

<p>我 不指望说服所有的人(大于25岁)都去学Lisp。这篇文章的目的不是改变别人的想法，而是给那些对Lisp有兴趣的人信心。他们已经知道Lisp是一个 强大的语言，但是因为它没有被广泛的使用而感到担忧。在竞赛中，这是一种优势。因为你的竞争对手用不了它，所以Lisp的优势还被放大了。</p>

<p>如 果你想要用Lisp创业，不需要因为它不被广泛的理解而感到担忧。你应该觉得那样很好。人们普遍对于他们当前使用的语言很满意。计算机硬件的发展速度比人 们习惯的改变速度快得多，实际编程比处理器要落后10到20年。像在MIT，他们早在20世纪60年代就开始用高级语言写程序了，而很多公司在80年代之 前都还在用机器语言。我敢打赌，处理器换到RISC指令集时，相当大一部分用机器语言写代码的人失了业。</p>

<p>通常说来，技术更新是很快 的。但是编程语言不一样：编程不止是技术，也是程序员思维的方式。他们是半技术，半宗教信仰的东西。[6]所以，流行的语言，即大部分程序员使用的语言， 发展像冰山一样缓慢。垃圾回收，大约20世纪60年代由Lisp引入，现在普遍被认为是个好东西；运行时输入(runtime typing)，同上，现在开始流行起来；词法闭包，20世纪70年代由Lisp引入，现在少量的运用在雷达技术上。宏，20世纪60年代由Lisp引 入，现在还是未开垦的领域。</p>

<p>当然，流行的语言有强大的势力，我不是想让你去对抗。相反，像合气道(译者：日本的一种竞技项目)一样，你可以用它来对付竞争对手。</p>

<p>如果你在一家大公司工作，也许没那么容易。说服一个头发油光锃亮的老板是个艰难的任务，而他也许正好读到某篇报道，说某某语言，就像20年前的Ada一样，将要占领这个行业。但假如你在创业公司工作，也没有那种油光锃亮的老板，那就好好利用Blub矛盾原则提到的优势，就像我们一样：你可以使用，那些坚持使用流行语言的竞争对手，永远无法匹敌的技术。</p>

<p>如果你在一个创业公司工作，这里有一些可用于评估对手的提示：查看他们的招聘岗位。他们网站上的其他东西也许会是股票照片，或者之类的。但是职位需求肯定会反映出他们要什么样的员工，否则无法得到想要的候选人。</p>

<p>我在Viaweb工作的几年里，查看过很多的职位描述。每个月都会有新的竞争者冒出来。我首先作的通常是，看看他们是否有在线的demo，然后去查看他们的招聘信息。很多年之后，我可以知道那些公司需要注意，而那些不需要。最安全的是那些需要Oracle经验的，你不需要担心他们。如果他们需要C++或者 java开发者，你同样不需要担心。如果他们想要Perl或者Python程序员，那就得小心了——看起来这家公司是搞技术的，至少，他们是真的黑客创办 的。如果看到招聘Lisp黑客的信息，我就会非常担心。</p>

<p>Notes
注释</p>

<p>[1]起初Viaweb有2部分：编辑器，用Lisp编写的，用户们用它来建立站点；请求处理系统，用C编写，处理请求。初版基本上是Lisp，因为请求处理系统很小。后来我们增加了2个模块，用C写的一个图像生成器，用Perl写的一个后台管理系统。</p>

<p>2003年1月，Yahoo发布了用C++和Perl写的新版本。很难说这个程序是否还是Lisp写的，因为要把它移植到C++，他们需要写一个Lisp解释器：构建页面模板的源文件，就我所知，还是Lisp代码。</p>

<p>[2]Rober Morris说我不需要保密，因为即使竞争者们知道我们用Lisp，他们也不会理解为什么：“假如他们有那么聪明的话，他们早就用Lisp编程了。“</p>

<p>[3] 因为图灵等价，所以很多语言被认为威力差不多，但是这不是程序员关心的。（没人想要写一个图灵机）。NB的程序员到底关心什么不好说，一种可能的解释是： 那些只能通过为更强大语言写一个解释器，才能在较弱的语言中获得的功能。如果语言A有一个操作符可以把字串中的空格去掉，而语言B没这个，那并不意味只A 就更强大。因为你大可在B里写一个类似的函数。但是假如A支持，比如递归，而B不支持，那可就不是你写一个函数库可以解决的问题了。</p>

<p>[4]呆头呆脑和断章取义的人注意：重要的是这里存在一个抽象的顺序，它到底长什么形状并不重要。</p>

<p>[5]把宏作为一个单独的功能列出来，有些不妥。实际上，他们的功效需要和其他的Lisp功能，比如词法闭包，变参等，一起才能发挥最大作用。</p>

<p>[6]结果是，对编程语言的比较要么是以“宗教战争”的形式，要么就像本科教材里面那样尽量中立的表述。对于看重和平，明哲保身的人来说，他们会避免这个话题。但是这个问题其实只是半宗教的：有些东西还是值得你去学习，特别是当你想要设计新语言的时候。</p>

<p>=================================================
Beating The Averages</p>

<p>Want to start a startup? Get funded by Y Combinator.</p>

<p>(This article is derived from a talk given at the 2001 Franz Developer Symposium.)</p>

<p>In the summer of 1995, my friend Robert Morris and I started a startup called Viaweb. Our plan was to write software that would let end users build online stores. What was novel about this software, at the time, was that it ran on our server, using ordinary Web pages as the interface.</p>

<p>A lot of people could have been having this idea at the same time, of course, but as far as I know, Viaweb was the first Web-based application. It seemed such a novel idea to us that we named the company after it: Viaweb, because our software worked via the Web, instead of running on your desktop computer.</p>

<p>Another unusual thing about this software was that it was written primarily in a programming language called Lisp. It was one of the first big end-user applications to be written in Lisp, which up till then had been used mostly in universities and research labs. [1]</p>

<p>The Secret Weapon</p>

<p>Eric Raymond has written an essay called &#8220;How to Become a Hacker,&#8221; and in it, among other things, he tells would-be hackers what languages they should learn. He suggests starting with Python and Java, because they are easy to learn. The serious hacker will also want to learn C, in order to hack Unix, and Perl for system administration and cgi scripts. Finally, the truly serious hacker should consider learning Lisp:</p>

<p>Lisp is worth learning for the profound enlightenment experience you will have when you finally get it; that experience will make you a better programmer for the rest of your days, even if you never actually use Lisp itself a lot.</p>

<p>This is the same argument you tend to hear for learning Latin. It won&#8217;t get you a job, except perhaps as a classics professor, but it will improve your mind, and make you a better writer in languages you do want to use, like English.</p>

<p>But wait a minute. This metaphor doesn&#8217;t stretch that far. The reason Latin won&#8217;t get you a job is that no one speaks it. If you write in Latin, no one can understand you. But Lisp is a computer language, and computers speak whatever language you, the programmer, tell them to.</p>

<p>So if Lisp makes you a better programmer, like he says, why wouldn&#8217;t you want to use it? If a painter were offered a brush that would make him a better painter, it seems to me that he would want to use it in all his paintings, wouldn&#8217;t he? I&#8217;m not trying to make fun of Eric Raymond here. On the whole, his advice is good. What he says about Lisp is pretty much the conventional wisdom. But there is a contradiction in the conventional wisdom: Lisp will make you a better programmer, and yet you won&#8217;t use it.</p>

<p>Why not? Programming languages are just tools, after all. If Lisp really does yield better programs, you should use it. And if it doesn&#8217;t, then who needs it?</p>

<p>This is not just a theoretical question. Software is a very competitive business, prone to natural monopolies. A company that gets software written faster and better will, all other things being equal, put its competitors out of business. And when you&#8217;re starting a startup, you feel this very keenly. Startups tend to be an all or nothing proposition. You either get rich, or you get nothing. In a startup, if you bet on the wrong technology, your competitors will crush you.</p>

<p>Robert and I both knew Lisp well, and we couldn&#8217;t see any reason not to trust our instincts and go with Lisp. We knew that everyone else was writing their software in C++ or Perl. But we also knew that that didn&#8217;t mean anything. If you chose technology that way, you&#8217;d be running Windows. When you choose technology, you have to ignore what other people are doing, and consider only what will work the best.</p>

<p>This is especially true in a startup. In a big company, you can do what all the other big companies are doing. But a startup can&#8217;t do what all the other startups do. I don&#8217;t think a lot of people realize this, even in startups.</p>

<p>The average big company grows at about ten percent a year. So if you&#8217;re running a big company and you do everything the way the average big company does it, you can expect to do as well as the average big company&#8211; that is, to grow about ten percent a year.</p>

<p>The same thing will happen if you&#8217;re running a startup, of course. If you do everything the way the average startup does it, you should expect average performance. The problem here is, average performance means that you&#8217;ll go out of business. The survival rate for startups is way less than fifty percent. So if you&#8217;re running a startup, you had better be doing something odd. If not, you&#8217;re in trouble.</p>

<p>Back in 1995, we knew something that I don&#8217;t think our competitors understood, and few understand even now: when you&#8217;re writing software that only has to run on your own servers, you can use any language you want. When you&#8217;re writing desktop software, there&#8217;s a strong bias toward writing applications in the same language as the operating system. Ten years ago, writing applications meant writing applications in C. But with Web-based software, especially when you have the source code of both the language and the operating system, you can use whatever language you want.</p>

<p>This new freedom is a double-edged sword, however. Now that you can use any language, you have to think about which one to use. Companies that try to pretend nothing has changed risk finding that their competitors do not.</p>

<p>If you can use any language, which do you use? We chose Lisp. For one thing, it was obvious that rapid development would be important in this market. We were all starting from scratch, so a company that could get new features done before its competitors would have a big advantage. We knew Lisp was a really good language for writing software quickly, and server-based applications magnify the effect of rapid development, because you can release software the minute it&#8217;s done.</p>

<p>If other companies didn&#8217;t want to use Lisp, so much the better. It might give us a technological edge, and we needed all the help we could get. When we started Viaweb, we had no experience in business. We didn&#8217;t know anything about marketing, or hiring people, or raising money, or getting customers. Neither of us had ever even had what you would call a real job. The only thing we were good at was writing software. We hoped that would save us. Any advantage we could get in the software department, we would take.</p>

<p>So you could say that using Lisp was an experiment. Our hypothesis was that if we wrote our software in Lisp, we&#8217;d be able to get features done faster than our competitors, and also to do things in our software that they couldn&#8217;t do. And because Lisp was so high-level, we wouldn&#8217;t need a big development team, so our costs would be lower. If this were so, we could offer a better product for less money, and still make a profit. We would end up getting all the users, and our competitors would get none, and eventually go out of business. That was what we hoped would happen, anyway.</p>

<p>What were the results of this experiment? Somewhat surprisingly, it worked. We eventually had many competitors, on the order of twenty to thirty of them, but none of their software could compete with ours. We had a wysiwyg online store builder that ran on the server and yet felt like a desktop application. Our competitors had cgi scripts. And we were always far ahead of them in features. Sometimes, in desperation, competitors would try to introduce features that we didn&#8217;t have. But with Lisp our development cycle was so fast that we could sometimes duplicate a new feature within a day or two of a competitor announcing it in a press release. By the time journalists covering the press release got round to calling us, we would have the new feature too.</p>

<p>It must have seemed to our competitors that we had some kind of secret weapon&#8211; that we were decoding their Enigma traffic or something. In fact we did have a secret weapon, but it was simpler than they realized. No one was leaking news of their features to us. We were just able to develop software faster than anyone thought possible.</p>

<p>When I was about nine I happened to get hold of a copy of The Day of the Jackal, by Frederick Forsyth. The main character is an assassin who is hired to kill the president of France. The assassin has to get past the police to get up to an apartment that overlooks the president&#8217;s route. He walks right by them, dressed up as an old man on crutches, and they never suspect him.</p>

<p>Our secret weapon was similar. We wrote our software in a weird AI language, with a bizarre syntax full of parentheses. For years it had annoyed me to hear Lisp described that way. But now it worked to our advantage. In business, there is nothing more valuable than a technical advantage your competitors don&#8217;t understand. In business, as in war, surprise is worth as much as force.</p>

<p>And so, I&#8217;m a little embarrassed to say, I never said anything publicly about Lisp while we were working on Viaweb. We never mentioned it to the press, and if you searched for Lisp on our Web site, all you&#8217;d find were the titles of two books in my bio. This was no accident. A startup should give its competitors as little information as possible. If they didn&#8217;t know what language our software was written in, or didn&#8217;t care, I wanted to keep it that way.[2]</p>

<p>The people who understood our technology best were the customers. They didn&#8217;t care what language Viaweb was written in either, but they noticed that it worked really well. It let them build great looking online stores literally in minutes. And so, by word of mouth mostly, we got more and more users. By the end of 1996 we had about 70 stores online. At the end of 1997 we had 500. Six months later, when Yahoo bought us, we had 1070 users. Today, as Yahoo Store, this software continues to dominate its market. It&#8217;s one of the more profitable pieces of Yahoo, and the stores built with it are the foundation of Yahoo Shopping. I left Yahoo in 1999, so I don&#8217;t know exactly how many users they have now, but the last I heard there were about 20,000.</p>

<p>The Blub Paradox</p>

<p>What&#8217;s so great about Lisp? And if Lisp is so great, why doesn&#8217;t everyone use it? These sound like rhetorical questions, but actually they have straightforward answers. Lisp is so great not because of some magic quality visible only to devotees, but because it is simply the most powerful language available. And the reason everyone doesn&#8217;t use it is that programming languages are not merely technologies, but habits of mind as well, and nothing changes slower. Of course, both these answers need explaining.</p>

<p>I&#8217;ll begin with a shockingly controversial statement: programming languages vary in power.</p>

<p>Few would dispute, at least, that high level languages are more powerful than machine language. Most programmers today would agree that you do not, ordinarily, want to program in machine language. Instead, you should program in a high-level language, and have a compiler translate it into machine language for you. This idea is even built into the hardware now: since the 1980s, instruction sets have been designed for compilers rather than human programmers.</p>

<p>Everyone knows it&#8217;s a mistake to write your whole program by hand in machine language. What&#8217;s less often understood is that there is a more general principle here: that if you have a choice of several languages, it is, all other things being equal, a mistake to program in anything but the most powerful one. [3]</p>

<p>There are many exceptions to this rule. If you&#8217;re writing a program that has to work very closely with a program written in a certain language, it might be a good idea to write the new program in the same language. If you&#8217;re writing a program that only has to do something very simple, like number crunching or bit manipulation, you may as well use a less abstract language, especially since it may be slightly faster. And if you&#8217;re writing a short, throwaway program, you may be better off just using whatever language has the best library functions for the task. But in general, for application software, you want to be using the most powerful (reasonably efficient) language you can get, and using anything else is a mistake, of exactly the same kind, though possibly in a lesser degree, as programming in machine language.</p>

<p>You can see that machine language is very low level. But, at least as a kind of social convention, high-level languages are often all treated as equivalent. They&#8217;re not. Technically the term &#8220;high-level language&#8221; doesn&#8217;t mean anything very definite. There&#8217;s no dividing line with machine languages on one side and all the high-level languages on the other. Languages fall along a continuum [4] of abstractness, from the most powerful all the way down to machine languages, which themselves vary in power.</p>

<p>Consider Cobol. Cobol is a high-level language, in the sense that it gets compiled into machine language. Would anyone seriously argue that Cobol is equivalent in power to, say, Python? It&#8217;s probably closer to machine language than Python.</p>

<p>Or how about Perl 4? Between Perl 4 and Perl 5, lexical closures got added to the language. Most Perl hackers would agree that Perl 5 is more powerful than Perl 4. But once you&#8217;ve admitted that, you&#8217;ve admitted that one high level language can be more powerful than another. And it follows inexorably that, except in special cases, you ought to use the most powerful you can get.</p>

<p>This idea is rarely followed to its conclusion, though. After a certain age, programmers rarely switch languages voluntarily. Whatever language people happen to be used to, they tend to consider just good enough.</p>

<p>Programmers get very attached to their favorite languages, and I don&#8217;t want to hurt anyone&#8217;s feelings, so to explain this point I&#8217;m going to use a hypothetical language called Blub. Blub falls right in the middle of the abstractness continuum. It is not the most powerful language, but it is more powerful than Cobol or machine language.</p>

<p>And in fact, our hypothetical Blub programmer wouldn&#8217;t use either of them. Of course he wouldn&#8217;t program in machine language. That&#8217;s what compilers are for. And as for Cobol, he doesn&#8217;t know how anyone can get anything done with it. It doesn&#8217;t even have x (Blub feature of your choice).</p>

<p>As long as our hypothetical Blub programmer is looking down the power continuum, he knows he&#8217;s looking down. Languages less powerful than Blub are obviously less powerful, because they&#8217;re missing some feature he&#8217;s used to. But when our hypothetical Blub programmer looks in the other direction, up the power continuum, he doesn&#8217;t realize he&#8217;s looking up. What he sees are merely weird languages. He probably considers them about equivalent in power to Blub, but with all this other hairy stuff thrown in as well. Blub is good enough for him, because he thinks in Blub.</p>

<p>When we switch to the point of view of a programmer using any of the languages higher up the power continuum, however, we find that he in turn looks down upon Blub. How can you get anything done in Blub? It doesn&#8217;t even have y.</p>

<p>By induction, the only programmers in a position to see all the differences in power between the various languages are those who understand the most powerful one. (This is probably what Eric Raymond meant about Lisp making you a better programmer.) You can&#8217;t trust the opinions of the others, because of the Blub paradox: they&#8217;re satisfied with whatever language they happen to use, because it dictates the way they think about programs.</p>

<p>I know this from my own experience, as a high school kid writing programs in Basic. That language didn&#8217;t even support recursion. It&#8217;s hard to imagine writing programs without using recursion, but I didn&#8217;t miss it at the time. I thought in Basic. And I was a whiz at it. Master of all I surveyed.</p>

<p>The five languages that Eric Raymond recommends to hackers fall at various points on the power continuum. Where they fall relative to one another is a sensitive topic. What I will say is that I think Lisp is at the top. And to support this claim I&#8217;ll tell you about one of the things I find missing when I look at the other four languages. How can you get anything done in them, I think, without macros? [5]</p>

<p>Many languages have something called a macro. But Lisp macros are unique. And believe it or not, what they do is related to the parentheses. The designers of Lisp didn&#8217;t put all those parentheses in the language just to be different. To the Blub programmer, Lisp code looks weird. But those parentheses are there for a reason. They are the outward evidence of a fundamental difference between Lisp and other languages.</p>

<p>Lisp code is made out of Lisp data objects. And not in the trivial sense that the source files contain characters, and strings are one of the data types supported by the language. Lisp code, after it&#8217;s read by the parser, is made of data structures that you can traverse.</p>

<p>If you understand how compilers work, what&#8217;s really going on is not so much that Lisp has a strange syntax as that Lisp has no syntax. You write programs in the parse trees that get generated within the compiler when other languages are parsed. But these parse trees are fully accessible to your programs. You can write programs that manipulate them. In Lisp, these programs are called macros. They are programs that write programs.</p>

<p>Programs that write programs? When would you ever want to do that? Not very often, if you think in Cobol. All the time, if you think in Lisp. It would be convenient here if I could give an example of a powerful macro, and say there! how about that? But if I did, it would just look like gibberish to someone who didn&#8217;t know Lisp; there isn&#8217;t room here to explain everything you&#8217;d need to know to understand what it meant. In Ansi Common Lisp I tried to move things along as fast as I could, and even so I didn&#8217;t get to macros until page 160.</p>

<p>But I think I can give a kind of argument that might be convincing. The source code of the Viaweb editor was probably about 20-25% macros. Macros are harder to write than ordinary Lisp functions, and it&#8217;s considered to be bad style to use them when they&#8217;re not necessary. So every macro in that code is there because it has to be. What that means is that at least 20-25% of the code in this program is doing things that you can&#8217;t easily do in any other language. However skeptical the Blub programmer might be about my claims for the mysterious powers of Lisp, this ought to make him curious. We weren&#8217;t writing this code for our own amusement. We were a tiny startup, programming as hard as we could in order to put technical barriers between us and our competitors.</p>

<p>A suspicious person might begin to wonder if there was some correlation here. A big chunk of our code was doing things that are very hard to do in other languages. The resulting software did things our competitors&#8217; software couldn&#8217;t do. Maybe there was some kind of connection. I encourage you to follow that thread. There may be more to that old man hobbling along on his crutches than meets the eye.</p>

<p>Aikido for Startups</p>

<p>But I don&#8217;t expect to convince anyone (over 25) to go out and learn Lisp. The purpose of this article is not to change anyone&#8217;s mind, but to reassure people already interested in using Lisp&#8211; people who know that Lisp is a powerful language, but worry because it isn&#8217;t widely used. In a competitive situation, that&#8217;s an advantage. Lisp&#8217;s power is multiplied by the fact that your competitors don&#8217;t get it.</p>

<p>If you think of using Lisp in a startup, you shouldn&#8217;t worry that it isn&#8217;t widely understood. You should hope that it stays that way. And it&#8217;s likely to. It&#8217;s the nature of programming languages to make most people satisfied with whatever they currently use. Computer hardware changes so much faster than personal habits that programming practice is usually ten to twenty years behind the processor. At places like MIT they were writing programs in high-level languages in the early 1960s, but many companies continued to write code in machine language well into the 1980s. I bet a lot of people continued to write machine language until the processor, like a bartender eager to close up and go home, finally kicked them out by switching to a risc instruction set.</p>

<p>Ordinarily technology changes fast. But programming languages are different: programming languages are not just technology, but what programmers think in. They&#8217;re half technology and half religion.[6] And so the median language, meaning whatever language the median programmer uses, moves as slow as an iceberg. Garbage collection, introduced by Lisp in about 1960, is now widely considered to be a good thing. Runtime typing, ditto, is growing in popularity. Lexical closures, introduced by Lisp in the early 1970s, are now, just barely, on the radar screen. Macros, introduced by Lisp in the mid 1960s, are still terra incognita.</p>

<p>Obviously, the median language has enormous momentum. I&#8217;m not proposing that you can fight this powerful force. What I&#8217;m proposing is exactly the opposite: that, like a practitioner of Aikido, you can use it against your opponents.</p>

<p>If you work for a big company, this may not be easy. You will have a hard time convincing the pointy-haired boss to let you build things in Lisp, when he has just read in the paper that some other language is poised, like Ada was twenty years ago, to take over the world. But if you work for a startup that doesn&#8217;t have pointy-haired bosses yet, you can, like we did, turn the Blub paradox to your advantage: you can use technology that your competitors, glued immovably to the median language, will never be able to match.</p>

<p>If you ever do find yourself working for a startup, here&#8217;s a handy tip for evaluating competitors. Read their job listings. Everything else on their site may be stock photos or the prose equivalent, but the job listings have to be specific about what they want, or they&#8217;ll get the wrong candidates.</p>

<p>During the years we worked on Viaweb I read a lot of job descriptions. A new competitor seemed to emerge out of the woodwork every month or so. The first thing I would do, after checking to see if they had a live online demo, was look at their job listings. After a couple years of this I could tell which companies to worry about and which not to. The more of an IT flavor the job descriptions had, the less dangerous the company was. The safest kind were the ones that wanted Oracle experience. You never had to worry about those. You were also safe if they said they wanted C++ or Java developers. If they wanted Perl or Python programmers, that would be a bit frightening&#8211; that&#8217;s starting to sound like a company where the technical side, at least, is run by real hackers. If I had ever seen a job posting looking for Lisp hackers, I would have been really worried.</p>

<p>Notes</p>

<p>[1] Viaweb at first had two parts: the editor, written in Lisp, which people used to build their sites, and the ordering system, written in C, which handled orders. The first version was mostly Lisp, because the ordering system was small. Later we added two more modules, an image generator written in C, and a back-office manager written mostly in Perl.</p>

<p>In January 2003, Yahoo released a new version of the editor written in C++ and Perl. It&#8217;s hard to say whether the program is no longer written in Lisp, though, because to translate this program into C++ they literally had to write a Lisp interpreter: the source files of all the page-generating templates are still, as far as I know, Lisp code. (See Greenspun&#8217;s Tenth Rule.)</p>

<p>[2] Robert Morris says that I didn&#8217;t need to be secretive, because even if our competitors had known we were using Lisp, they wouldn&#8217;t have understood why: &#8220;If they were that smart they&#8217;d already be programming in Lisp.&#8221;</p>

<p>[3] All languages are equally powerful in the sense of being Turing equivalent, but that&#8217;s not the sense of the word programmers care about. (No one wants to program a Turing machine.) The kind of power programmers care about may not be formally definable, but one way to explain it would be to say that it refers to features you could only get in the less powerful language by writing an interpreter for the more powerful language in it. If language A has an operator for removing spaces from strings and language B doesn&#8217;t, that probably doesn&#8217;t make A more powerful, because you can probably write a subroutine to do it in B. But if A supports, say, recursion, and B doesn&#8217;t, that&#8217;s not likely to be something you can fix by writing library functions.</p>

<p>[4] Note to nerds: or possibly a lattice, narrowing toward the top; it&#8217;s not the shape that matters here but the idea that there is at least a partial order.</p>

<p>[5] It is a bit misleading to treat macros as a separate feature. In practice their usefulness is greatly enhanced by other Lisp features like lexical closures and rest parameters.</p>

<p>[6] As a result, comparisons of programming languages either take the form of religious wars or undergraduate textbooks so determinedly neutral that they&#8217;re really works of anthropology. People who value their peace, or want tenure, avoid the topic. But the question is only half a religious one; there is something there worth studying, especially if you want to design new languages.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">zhuzhonghua</span></span>

      








  


<time datetime="2012-06-12T22:45:00+08:00" pubdate data-updated="true">Jun 12<span>th</span>, 2012</time>
      


    </p>
    
      <div class="sharing">
  
  
  
  
    <!-- JiaThis Button BEGIN -->
<div id="jiathis_style_32x32">
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_tqq"></a>
	<a class="jiathis_button_renren"></a>
	<a class="jiathis_button_kaixin001"></a>
	<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

<!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript" id="UYScript" src="http://v1.uyan.cc/js/iframe.js?UYUserId=0" async=""></script>
<!-- UY END -->

  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2012/06/12/ru-he-chuang-zao-cai-fu/" title="Previous Post: 如何创造财富">&laquo; 如何创造财富</a>
      
      
        <a class="basic-alignment right" href="/blog/2012/06/12/zi-xia-er-shang-bian-cheng/" title="Next Post: 自下而上编程">自下而上编程 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/07/19/zhen-ai-sheng-ming-%2Cshi-yong-python/">珍爱生命，使用Python</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/07/18/ai-xi-xiao-mu-zhi-%2Cyuan-chi-emacs%2Cwei-da-de-emacs-asciitu-mo-shi/">爱惜小拇指，远离Emacs，伟大的Emacs  ASCII图模式</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/07/17/wo-gong-xian-%5B%3F%5D-ge-makefile-dot-template/">我贡献一个makefile.template</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/07/16/you-xi-li-qian-ru-yu-yin-xi-tong/">游戏里嵌入语音系统</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/07/13/zai-vimzhong-pa-xing/">在Vim中爬行</a>
      </li>
    
  </ul>
</section>





<section>
  <h1>About Me</h1>
  <p>MMO服务器程序</p>
  <p>主要使用C＋＋，配合各种脚本 </p>
  <p>Email: secondsquare@gmail.com </p>
  <p>QQ: 406344976 </p>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - zhuzhonghua -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
