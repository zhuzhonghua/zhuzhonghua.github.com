((3) 0 () 25 ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2013-06-22-doubanfmhunter.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2013-06-26-doubanfmhunter_update.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2013-07-18-sdl20-compile.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2014-01-05-xui-flash-cocos2d-x-html5.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2013-11-24-flash-jsfl-cocos2d-js-app.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2018-07-18-c-c-\344\270\216chibi-scheme\344\272\222\347\233\270\350\260\203\347\224\250.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2018-03-04-blockchain-python-demo.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2018-08-20-\344\275\277\347\224\250racket-scheme-lisp-\350\277\233\350\241\214\346\270\270\346\210\217\346\234\215\345\212\241\345\231\250\345\274\200\345\217\221.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2014-08-02-nodejs-log.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2013-10-31-html5test-project.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2013-10-02-jsfl-js-error.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2012-11-13-swf-spec-9-font-text.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2015-11-20-gnashdefinebits-streamadapter.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2014-12-26-tamarin-execute-routine.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2017-09-24-\344\275\277\347\224\250gimp\347\232\204python\350\204\232\346\234\254\350\207\252\345\212\250\346\213\206\350\247\243plist\345\233\276\347\211\207.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2014-08-19-nodejs-game-server.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2014-12-17-parse-swf.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2020-02-16-\347\224\250python\347\224\237\346\210\220makefile.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2018-01-14-realm-of-racket-big-bang.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2017-10-11-realm-of-racket-\347\214\234\346\225\260\345\255\227.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2018-03-04-shuangseqiu-emulate.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2012-06-07-mingw-gcc-gdb.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2012-12-21-swf-spec-9-shape.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2013-02-06-python-cpp-embed.md" . unix) (p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2013-03-03-founders-at-work-after-read.md" . unix)) () (h ! (equal) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2018-08-20-\344\275\277\347\224\250racket-scheme-lisp-\350\277\233\350\241\214\346\270\270\346\210\217\346\234\215\345\212\241\345\231\250\345\274\200\345\217\221.md" . unix) f post (u . "使用Racket(Scheme/Lisp)进行游戏服务器开发") (? . 7) 1548258350 (p+ #"/Users/zhonghua/demo/zhonghua_com/2018/08/\344\275\277\347\224\250racket-scheme-lisp-\350\277\233\350\241\214\346\270\270\346\210\217\346\234\215\345\212\241\345\231\250\345\274\200\345\217\221.html" . unix) (u . "/2018/08/%E4%BD%BF%E7%94%A8racket-scheme-lisp-%E8%BF%9B%E8%A1%8C%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91.html") (u . "2018-08-20T18:16:54") (? . 5) (? . 17) (c (u . "Racket") c (u . "Scheme") c (u . "Lisp") c (u . "网络") c (u . "游戏") c (u . "服务器") c (u . "后端") c (u . "后台") c (u . "开发")) (u . "\n<p><a href=\"https://github.com/zhuzhonghua/racket_gameserver\">Github仓库地址</a></p>\n\n<p>Racket作为Lisp方言，从它们的Blog<a href=\"https://blog.racket-lang.org/index.html\">Racket Blog</a>就可以看出，社区非常活跃。</p>\n\n<p>安装好Racket之后，使用racket main.rkt就可以运行服务器了。</p>\n\n<p>附带一个使用nodejs的测试客户端，node testClient.js 可以连接上Racket服务器。</p>\n\n<p>协议使用的Protobuf</p>\n\n<p>(serve port-no)是主入口函数，port-no是服务器需要监听的端口。</p>\n\n<p>(game-loop) 在单独线程中运行，使用custodians(守护)机制，来释放所有系统资源，streams，线程等</p>\n\n<p>game-loop的处理流程</p>\n\n<ol>\n <li>接收新来的连接(accept-conn)\n  <br /></li>\n <li>接收并处理客户端发送的消息(read-conn)\n  <br /></li>\n <li>发送给客户端的消息(flush-conn)</li></ol>\n\n<p>在read/write连接时，如果出错，使用with-handlers来处理网络异常。</p>\n\n<p>在op.rkt中定义了示例消息号\n <br />在route.rkt中定义了消息路由，哪个消息号的消息，由哪个函数处理\n <br />在proto.rkt中定义了反序列化的消息，以供游戏逻辑代码使用</p>\n\n<p>上面的定义比较简单粗暴，但是原理都是类似的</p>\n\n<p>录了一些视频，一点一点讲解，从零开始写这个服务器代码\n <br />在持续更新中</p>\n\n<p><a href=\"https://www.youtube.com/playlist?list=PL3gfPn2A9HNGqA6RjVQhpNW8TjaRqOlEt\">Youtube地址</a></p>\n\n<p><a href=\"https://h5.renrenjiang.cn/#/column?cid=19930&amp;su=5799319\">人人讲地址</a></p>") #f (u . "\n<p><a href=\"https://github.com/zhuzhonghua/racket_gameserver\">Github仓库地址</a></p>\n\n<p>Racket作为Lisp方言，从它们的Blog<a href=\"https://blog.racket-lang.org/index.html\">Racket Blog</a>就可以看出，社区非常活跃。</p>\n\n<p>安装好Racket之后，使用racket main.rkt就可以运行服务器了。</p>\n\n<p>附带一个使用nodejs的测试客户端，node testClient.js 可以连接上Racket服务器。</p>\n\n<p>协议使用的Protobuf</p>\n\n<p>(serve port-no)是主入口函数，port-no是服务器需要监听的端口。</p>\n\n<p>(game-loop) 在单独线程中运行，使用custodians(守护)机制，来释放所有系统资源，streams，线程等</p>\n\n<p>game-loop的处理流程</p>\n\n<ol>\n <li>接收新来的连接(accept-conn)\n  <br /></li>\n <li>接收并处理客户端发送的消息(read-conn)\n  <br /></li>\n <li>发送给客户端的消息(flush-conn)</li></ol>\n\n<p>在read/write连接时，如果出错，使用with-handlers来处理网络异常。</p>\n\n<p>在op.rkt中定义了示例消息号\n <br />在route.rkt中定义了消息路由，哪个消息号的消息，由哪个函数处理\n <br />在proto.rkt中定义了反序列化的消息，以供游戏逻辑代码使用</p>\n\n<p>上面的定义比较简单粗暴，但是原理都是类似的</p>\n\n<p>录了一些视频，一点一点讲解，从零开始写这个服务器代码\n <br />在持续更新中</p>\n\n<p><a href=\"https://www.youtube.com/playlist?list=PL3gfPn2A9HNGqA6RjVQhpNW8TjaRqOlEt\">Youtube地址</a></p>\n\n<p><a href=\"https://h5.renrenjiang.cn/#/column?cid=19930&amp;su=5799319\">人人讲地址</a></p>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2013-06-26-doubanfmhunter_update.md" . unix) f post (u . "豆瓣FM Hunter 更新") (? . 1) 1505574438 (p+ #"/Users/zhonghua/demo/zhonghua_com/2013/06/\350\261\206\347\223\243fm-hunter-\346\233\264\346\226\260.html" . unix) (u . "/2013/06/%E8%B1%86%E7%93%A3fm-hunter-%E6%9B%B4%E6%96%B0.html") (u . "2013-06-26T00:00:00") (? . 0) (? . 2) () (u . "\n<p>但是后来在新浪上搭建的服务器不能用了，于是努力实现了本地下载。</p>\n\n<p>首先参考了别人的代码，把xpi文件(其实就是zip文件)打开，阅读里面下载相关的代码。</p>\n\n<p>1.点击下载时，弹出对话框</p>\n\n<pre><code>function getFilePicker(path)\n{\n    var fp = Cc[\"@mozilla.org/filepicker;1\"].getService(Ci.nsIFilePicker)\n    fp.init(win, 'Save Douban Music', fp.modeSave)\n\tfp.defaultExtension = 'mp3';\n\tfp.defaultString = path;\n\tfp.appendFilter('MP3', '*.mp3');\n\tvar rv = fp.show()\n\tif (rv == fp.returnOK || rv == fp.returnReplace) {\n\t\treturn fp\n\t}\n    else{\n        return null;\n    }\n}</code></pre>\n\n<p>这里需要注意的一个地方就是Cc和Ci分别代表了Components.classes和Components.interfaces。 记得前面var {Cc, Ci} = require(&ldquo;chrome&rdquo;)</p>\n\n<p>参数path其实就是文件名，我在这里使用了标题title。</p>\n\n<p>2.接下来就要写入文件了。</p>\n\n<pre><code>var fp = getFilePicker(name);\nif(!fp) return;\n\nvar file = fp.file;\n\nvar ios = Cc[\"@mozilla.org/network/io-service;1\"].getService(Ci.nsIIOService);\nvar url = ios.newURI(u, null, null);\nvar channel = ios.newChannelFromURI(url);\nvar observer = {\n  onStreamComplete : function(aLoader, aContext, aStatus, aLength, aResult) {\n      \tvar stream = Cc[\"@mozilla.org/network/safe-file-output-stream;1\"].createInstance(Ci.nsIFileOutputStream);\n          stream.init(file, -1, -1, 0);\n          var bstream = Cc[\"@mozilla.org/binaryoutputstream;1\"].createInstance(Ci.nsIBinaryOutputStream);\n\n          bstream.setOutputStream(stream);    \n          bstream.writeByteArray(aResult, aLength);\n          if (stream instanceof Ci.nsISafeOutputStream) {\n             stream.finish();\n          }else {\n              stream.close();\n          }\n      }\n}\nvar sl = Cc[\"@mozilla.org/network/stream-loader;1\"].createInstance(Ci.nsIStreamLoader);\nsl.init(observer);\nchannel.asyncOpen(sl, channel);</code></pre>\n\n<p>其实我也是在网上照抄一些代码，大体懂得一些含义，异步加载url地址，获得数据之后，写入文件。</p>\n\n<p>等以后需要了，再进行更新吧。目前够用了。</p>\n\n<p>Just For Fun</p>") #f (u . "\n<p>但是后来在新浪上搭建的服务器不能用了，于是努力实现了本地下载。</p>\n\n<p>首先参考了别人的代码，把xpi文件(其实就是zip文件)打开，阅读里面下载相关的代码。</p>\n\n<p>1.点击下载时，弹出对话框</p>\n\n<pre><code>function getFilePicker(path)\n{\n    var fp = Cc[\"@mozilla.org/filepicker;1\"].getService(Ci.nsIFilePicker)\n    fp.init(win, 'Save Douban Music', fp.modeSave)\n\tfp.defaultExtension = 'mp3';\n\tfp.defaultString = path;\n\tfp.appendFilter('MP3', '*.mp3');\n\tvar rv = fp.show()\n\tif (rv == fp.returnOK || rv == fp.returnReplace) {\n\t\treturn fp\n\t}\n    else{\n        return null;\n    }\n}</code></pre>\n\n<p>这里需要注意的一个地方就是Cc和Ci分别代表了Components.classes和Components.interfaces。 记得前面var {Cc, Ci} = require(&ldquo;chrome&rdquo;)</p>\n\n<p>参数path其实就是文件名，我在这里使用了标题title。</p>\n\n<p>2.接下来就要写入文件了。</p>\n\n<pre><code>var fp = getFilePicker(name);\nif(!fp) return;\n\nvar file = fp.file;\n\nvar ios = Cc[\"@mozilla.org/network/io-service;1\"].getService(Ci.nsIIOService);\nvar url = ios.newURI(u, null, null);\nvar channel = ios.newChannelFromURI(url);\nvar observer = {\n  onStreamComplete : function(aLoader, aContext, aStatus, aLength, aResult) {\n      \tvar stream = Cc[\"@mozilla.org/network/safe-file-output-stream;1\"].createInstance(Ci.nsIFileOutputStream);\n          stream.init(file, -1, -1, 0);\n          var bstream = Cc[\"@mozilla.org/binaryoutputstream;1\"].createInstance(Ci.nsIBinaryOutputStream);\n\n          bstream.setOutputStream(stream);    \n          bstream.writeByteArray(aResult, aLength);\n          if (stream instanceof Ci.nsISafeOutputStream) {\n             stream.finish();\n          }else {\n              stream.close();\n          }\n      }\n}\nvar sl = Cc[\"@mozilla.org/network/stream-loader;1\"].createInstance(Ci.nsIStreamLoader);\nsl.init(observer);\nchannel.asyncOpen(sl, channel);</code></pre>\n\n<p>其实我也是在网上照抄一些代码，大体懂得一些含义，异步加载url地址，获得数据之后，写入文件。</p>\n\n<p>等以后需要了，再进行更新吧。目前够用了。</p>\n\n<p>Just For Fun</p>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2018-03-04-shuangseqiu-emulate.md" . unix) f post (u . "用Python模拟双色球抽奖") (? . 20) 1520100883 (p+ #"/Users/zhonghua/demo/zhonghua_com/2018/03/\347\224\250python\346\250\241\346\213\237\345\217\214\350\211\262\347\220\203\346\212\275\345\245\226.html" . unix) (u . "/2018/03/%E7%94%A8python%E6%A8%A1%E6%8B%9F%E5%8F%8C%E8%89%B2%E7%90%83%E6%8A%BD%E5%A5%96.html") (u . "2018-03-04T00:00:22") (? . 18) (? . 6) (c (u . "Python") c (u . "双色球") c (u . "大乐透") c (u . "彩票")) (u . "\n<ol>\n <li>抓取历史开奖的双色球号码\n  <br /></li>\n <li>模拟生成N注彩票，并且过滤掉历史上开奖的号\n  <br /></li>\n <li>把模拟出来的彩票写入sqlite数据</li></ol>\n\n<p>用Python3写\n <br />需要用到几个python库\n <br />1. requests (pip3 install requests) 网络库\n <br />2. bs4 (pip3 install bs4) BeautifulSoup，方便分析抓取内容\n <br />3. sqlite3 (pip3 install sqlite3) 数据库</p>\n\n<h1 id=\"获取历史所有期号\">获取历史所有期号</h1>\n\n<pre><code>def get_all_option():\n  # 彩票获取源\n  url=\"http://kaijiang.500.com/shtml/ssq/18016.shtml\"\n  req = requests.get(url)\n\t\n  # 找到对应的字段\t\n  soup = BeautifulSoup(req.text, 'html.parser')\n  linkids = re.compile(\"link[0-9]+\")\n  all_ids = soup.find(attrs={'class':'iSelectBox'})\n\t\t  \n  # 把所有期号写入ssq_all_ids.txt 这个文件，一行一个期号\n  all_links = all_ids.find_all('a')\n  f = open(\"ssq_all_ids.txt\", \"w\")\n  for link_id in all_links:\n    f.write(link_id.string+'\\n')\n  f.close()\n  </code></pre>\n\n<h1 id=\"获取特定期号的号码\">获取特定期号的号码</h1>\n\n<pre><code>def get_ball(url, id):\n  # 抓取id期号的号码\n  req = requests.get(url, timeout=10)\n  soup = BeautifulSoup(req.text, 'html.parser')\n  balls = soup.find(attrs={'class':'ball_box01'})\n\n  # 找到红号字段\n  red_balls = []\n  for red in balls.find_all(attrs={'class':'ball_red'}):\n    red_balls.append(red.string)\n\n  # 找到蓝号字段\n  blue_balls = []\n  for blue in balls.find_all(attrs={'class':'ball_blue'}):\n    blue_balls.append(blue.string)\n\n  # 把期号，红号，蓝号都写入 ssq_hit_ids.txt\n  # 期号|红号1,红号2,红号3,红号4,红号5,红号6|蓝号\n  # 蓝号只有一个，不过可以扩展到大乐透，多个蓝号\n  f = open('ssq_hit_ids.txt', 'a+')\n  f.write(id+\"|\"+\",\".join(red_balls)+\"|\"+\",\".join(blue_balls)+'\\n')\n  f.close()\n  print(\"get  \"+id)\n  \n  </code></pre>\n\n<h1 id=\"更新期号\">更新期号</h1>\n\n<p>以后再使用时，只需要抓取缺失的期号</p>\n\n<pre><code>def update_ids():\n  # 拿到所有期号\n  url=\"http://kaijiang.500.com/shtml/ssq/18016.shtml\"\n  req = requests.get(url)\n\n  soup = BeautifulSoup(req.text, 'html.parser')\n  linkids = re.compile(\"link[0-9]+\")\n  all_ids = soup.find(attrs={'class':'iSelectBox'})\n  all_links = all_ids.find_all('a')\n\n  new_ids = []\n  for link_id in all_links:\n    new_ids.append(link_id.string)\n\n  # 拿到已经抓取的期号\n  old_ids = []\n  with open(\"ssq_all_ids.txt\", 'r') as f:\n    old_ids = f.readlines()\n  old_ids_new = [one.replace('\\n','') for one in old_ids]\n  # 转换成set，方便查找\n  old_ids_set = set(old_ids_new)\n\n  for one in new_ids:\n    # 如果没抓取过，那么抓取\n    if not one in old_ids_set:\n      url=\"http://kaijiang.500.com/shtml/ssq/\"+one.replace('\\n','')+\".shtml\"\n      try:\n        get_ball(url, one)\n        with open(\"ssq_all_ids.txt\", 'a') as f:\n          f.write(one+\"\\n\")\n        print(\"update  id \"+one)\n      except Exception as e:\n        print(e)\n        with open('ssq_err_ids.txt', 'a+') as f:\n          f.write(one+'\\n')\n\t\t  </code></pre>\n\n<h1 id=\"初始抓取\">初始抓取</h1>\n\n<pre><code>def main():\n  # 把所有期号读进来\n  all_ids = []\n  with open('ssq_all_ids.txt', 'r') as f:\n    all_ids = f.readlines()\n\n  # 把每一期的开奖号码抓下来\n  for one_id in all_ids:\n    one_id = one_id.replace('\\n','')\n    url=\"http://kaijiang.500.com/shtml/ssq/\"+one_id+\".shtml\"\n    try:\n      get_ball(url, one_id)\n      time.sleep(.100)\n    except Exception as e:\n      print(e)\n      # 做异常判断，防止漏抓取内容\n      f = open('ssq_err_ids.txt', 'a+')\n      f.write(one_id+'\\n')\n      f.close()\n\t\t  \n\t\t  </code></pre>\n\n<p>现在就可以运行</p>\n\n<pre><code>get_all_option()\nmain()\n</code></pre>\n\n<p>抓取所有历史开奖号码了</p>\n\n<p>接下来可以模拟开奖号码，写数据库了</p>\n\n<h1 id=\"数据库脚本\">数据库脚本</h1>\n\n<pre><code># 删除库的脚本\nsql_drop_guess = '''\ndrop table guess;\n'''\n# 创建库的脚本\n# id 是主键，自增\n# nxx是对应模拟的号码，随机出2，那么n02列就有值，可以记录1，或者直接记录2\n# 没有模拟出来的号，那对应的列就是默认值0\n# count 是对应模拟出的号的个数，可能同一号码，会模拟出多次\n# 就好像全国2亿注彩票，可能还有人买重了\n# 为了优化，还建立了唯一索引\n# 这里只是模拟红球，因为篮球只有16个号，刨除上一期开的号，那就是只有15个号\n# 如果觉得哪一组红球比较有戏，可以拖15个篮球，所以随机模拟时，不考虑篮球\nsql_create_guess = '''\nCREATE TABLE guess (\n  id INTEGER primary key AUTOINCREMENT,\n  n01 int default 0, n02 int default 0, n03 int default 0,\n  n04 int default 0, n05 int default 0, n06 int default 0,\n  n07 int default 0, n08 int default 0, n09 int default 0,\n  n10 int default 0, n11 int default 0, n12 int default 0,\n  n13 int default 0, n14 int default 0, n15 int default 0,\n  n16 int default 0, n17 int default 0, n18 int default 0,\n  n19 int default 0, n20 int default 0, n21 int default 0,\n  n22 int default 0, n23 int default 0, n24 int default 0,\n  n25 int default 0, n26 int default 0, n27 int default 0,\n  n28 int default 0, n29 int default 0, n30 int default 0,\n  n31 int default 0, n32 int default 0, n33 int default 0,\n  count int,\n  unique (n01,n02,n03,n04,n05,n06,n07,n08,n09,n10,\n          n11,n12,n13,n14,n15,n16,n17,n18,n19,n20,\n          n21,n22,n23,n24,n25,n26,n27,n28,n29,n30,n31,n32,n33)\n);\n'''</code></pre>\n\n<h1 id=\"删库和建库代码\">删库和建库代码</h1>\n\n<pre><code>def drop_guess_table():\n  # 连接数据库文件\n  conn = sqlite3.connect(dbname)\n  # 执行脚本\n  c = conn.cursor()\n  c.execute(sql_drop_guess)\n  conn.commit()\n  # 关闭数据库文件\n  conn.close()\n  print('drop guess success')\n\ndef create_guess_db():\n  # 连接数据库文件\n  conn = sqlite3.connect(dbname)\n  c = conn.cursor()\n  # 执行脚本\n  c.execute(sql_create_guess)\n  conn.commit()\n  # 关闭数据库文件\n  conn.close()\n  print('create db success')\n  </code></pre>\n\n<p>dbname 会定义成一个全局变量\n <br />双色球每周会开3期，所以每天一个数据库文件，就可以了</p>\n\n<h1 id=\"把历史开奖号读进来\">把历史开奖号读进来</h1>\n\n<pre><code>def get_all_history():\n  # 读取历史开奖号码文件\n  lines = []\n  with open('ssq_hit_ids.txt') as f:\n    lines = f.readlines()\n\n  all_red=set()\n  for line in lines:\n    if len(line) &lt;= 0:\n      continue\n    # 摘取红号  \n    red_balls = line.split('|')[1].split(',')\n    # 红号排序，并组织成\"红号1,红号2,红号3,红号4,红号5,红号6\"的字符串放入set中，方便查找\n    int_red_balls = []\n    for one in red_balls:\n      int_red_balls.append(int(one))\n    int_red_balls.sort()\n    str_red_balls=[str(one) for one in int_red_balls]\n    all_red.add(','.join(str_red_balls))\n\n  return all_red\n  </code></pre>\n\n<h1 id=\"生成一组红号\">生成一组红号</h1>\n\n<pre><code>def gen_one():\n  # 33个红球\n  # 这里可以优化，比如想杀号，定胆的情况下\n  all_red_balls = list(range(1,33+1))\n  gen_red_balls = []\n  # 把所有可能的号随机打乱\n  # 取一个，从列表里删除一个，防止取到重复的红号\n  index = random.randrange(0, len(all_red_balls))\n  gen_red_balls.append(all_red_balls.pop(index))\n\n  index = random.randrange(0, len(all_red_balls))\n  gen_red_balls.append(all_red_balls.pop(index))\n\n  index = random.randrange(0, len(all_red_balls))\n  gen_red_balls.append(all_red_balls.pop(index))\n\n  index = random.randrange(0, len(all_red_balls))\n  gen_red_balls.append(all_red_balls.pop(index))\n\n  index = random.randrange(0, len(all_red_balls))\n  gen_red_balls.append(all_red_balls.pop(index))\n\n  index = random.randrange(0, len(all_red_balls))\n  gen_red_balls.append(all_red_balls.pop(index))\n\n  gen_red_balls.sort()\n  return gen_red_balls</code></pre>\n\n<h1 id=\"生成n注并过滤历史开奖号\">生成N注，并过滤历史开奖号</h1>\n\n<pre><code>def gen():\n  # 拿到历史开奖号\n  red_history = get_all_history()\n  all_red_balls = {}\n  # run_count是指定的模拟多少注\t  \n  global run_count\n  while run_count &gt; 0:\n    run_count -= 1\n    in_history = True\n    while in_history:\n      # 生成一组，然后构造成\",”连接的字符串，然后过滤历史号\n      red_balls = gen_one()\n      str_red_balls = [str(one) for one in red_balls]\n      one_red = \",\".join(str_red_balls)\n      if not one_red in red_history:\n        # 同一号码，累计+1\n        all_red_balls[one_red] = all_red_balls.get(one_red, 0) + 1\n        in_history = False\n  print(\"gen all balls\")\n  return all_red_balls\n  </code></pre>\n\n<h1 id=\"准备写入数据库\">准备写入数据库</h1>\n\n<p>数据库列辅助函数</p>\n\n<pre><code>def get_ball_col(ball):\n  if int(ball) &lt; 10:\n    return 'n0'+ball\n  else:\n    return 'n'+ball</code></pre>\n\n<h1 id=\"动态构造插入和更新数据库sql\">动态构造插入和更新数据库SQL</h1>\n\n<pre><code>def get_sql_insert(ored, count):\n  # ored 红球数组\n  # count 对应红球重复的个数\n  col1 = get_ball_col(ored[0])\n  col2 = get_ball_col(ored[1])\n  col3 = get_ball_col(ored[2])\n  col4 = get_ball_col(ored[3])\n  col5 = get_ball_col(ored[4])\n  col6 = get_ball_col(ored[5])\n  sql = 'insert into guess('+col1+','+col2+','+col3+','+col4+','+col5+','+col6+',count) values('+ored[0]+','+ored[1]+','+ored[2]+','+ored[\\\n3]+','+ored[4]+','+ored[5]+','+str(count)+')'\n  return sql\n\ndef get_sql_update(ored, count):\n  # ored 红球数组\n  # count 对应红球重复的个数\n  col1 = get_ball_col(ored[0])\n  col2 = get_ball_col(ored[1])\n  col3 = get_ball_col(ored[2])\n  col4 = get_ball_col(ored[3])\n  col5 = get_ball_col(ored[4])\n  col6 = get_ball_col(ored[5])\n  sql = 'update guess set count=count+%s where '+col1+'=%s and '+col2+'=%s and '+col3+'=%s and '+col4+'=%s and '+col5+'=%s and '+col6+'=%s\\\n'\n  return sql % (count, ored[0], ored[1], ored[2], ored[3], ored[4], ored[5])\n  </code></pre>\n\n<h1 id=\"写入数据库\">写入数据库</h1>\n\n<pre><code>def update_all_red_balls(all_red_balls):\n  # all_red_balls 所有模拟出的红球\n  conn = sqlite3.connect(dbname)\n  c = conn.cursor()\n  for k in all_red_balls:\n    # 单组红号分拆成数组\n    red_balls = k.split(',')\n    count = all_red_balls[k]\n    # 如果插入失败，则尝试更新count\n    try:\n      sql = get_sql_insert(red_balls, count)\n      c.execute(sql)\n    except Exception:\n      sql = get_sql_update(red_balls, count)\n      c.execute(sql)\n  conn.commit()\n  conn.close()\n  </code></pre>\n\n<p>还有一种做法，每生成一组红号就写入数据库，通过try catch来插入或者更新\n <br />这种方式，生成数量小的话，还可以接受，比如10万注，当生成上亿注时，这个效率就不可接受了\n <br />第一版就是每生成一注就写数据库，跑1亿注，结果跑了48小时都没有跑完\n <br />所以优化成现在这样，先把所有期望生成的彩票都生成，然后一次都写入数据库，效率提升了N倍</p>\n\n<h1 id=\"运行\">运行</h1>\n\n<pre><code>dbname = \"ssq-2018-3-1.db\"\nrun_count = 100000000\n</code></pre>\n\n<p>可以在每次运行之前先跑一遍</p>\n\n<pre><code>update_ids()</code></pre>\n\n<p>更新历史开奖号\n <br />每次新模拟，需要先创建数据库文件</p>\n\n<pre><code>create_guess_db()\n</code></pre>\n\n<p>如果操作失误，可以先删除数据库</p>\n\n<pre><code>drop_guess_table()\n</code></pre>\n\n<p>或者修改 dbname，再创建 create_guess_db()</p>\n\n<pre><code>begin = datetime.datetime.now()\nupdate_all_red_balls(gen())\nend = datetime.datetime.now()\n\nprint((end-begin).total_seconds())\n</code></pre>\n\n<p>记录开始时间，运行，然后记录结束时间，看看N注彩票运行了多久</p>\n\n<p>JUST FOR FUN!</p>") #f (u . "\n<ol>\n <li>抓取历史开奖的双色球号码\n  <br /></li>\n <li>模拟生成N注彩票，并且过滤掉历史上开奖的号\n  <br /></li>\n <li>把模拟出来的彩票写入sqlite数据</li></ol>\n\n<p>用Python3写\n <br />需要用到几个python库\n <br />1. requests (pip3 install requests) 网络库\n <br />2. bs4 (pip3 install bs4) BeautifulSoup，方便分析抓取内容\n <br />3. sqlite3 (pip3 install sqlite3) 数据库</p>\n\n<h1 id=\"获取历史所有期号\">获取历史所有期号</h1>\n\n<pre><code>def get_all_option():\n  # 彩票获取源\n  url=\"http://kaijiang.500.com/shtml/ssq/18016.shtml\"\n  req = requests.get(url)\n\t\n  # 找到对应的字段\t\n  soup = BeautifulSoup(req.text, 'html.parser')\n  linkids = re.compile(\"link[0-9]+\")\n  all_ids = soup.find(attrs={'class':'iSelectBox'})\n\t\t  \n  # 把所有期号写入ssq_all_ids.txt 这个文件，一行一个期号\n  all_links = all_ids.find_all('a')\n  f = open(\"ssq_all_ids.txt\", \"w\")\n  for link_id in all_links:\n    f.write(link_id.string+'\\n')\n  f.close()\n  </code></pre>\n\n<h1 id=\"获取特定期号的号码\">获取特定期号的号码</h1>\n\n<pre><code>def get_ball(url, id):\n  # 抓取id期号的号码\n  req = requests.get(url, timeout=10)\n  soup = BeautifulSoup(req.text, 'html.parser')\n  balls = soup.find(attrs={'class':'ball_box01'})\n\n  # 找到红号字段\n  red_balls = []\n  for red in balls.find_all(attrs={'class':'ball_red'}):\n    red_balls.append(red.string)\n\n  # 找到蓝号字段\n  blue_balls = []\n  for blue in balls.find_all(attrs={'class':'ball_blue'}):\n    blue_balls.append(blue.string)\n\n  # 把期号，红号，蓝号都写入 ssq_hit_ids.txt\n  # 期号|红号1,红号2,红号3,红号4,红号5,红号6|蓝号\n  # 蓝号只有一个，不过可以扩展到大乐透，多个蓝号\n  f = open('ssq_hit_ids.txt', 'a+')\n  f.write(id+\"|\"+\",\".join(red_balls)+\"|\"+\",\".join(blue_balls)+'\\n')\n  f.close()\n  print(\"get  \"+id)\n  \n  </code></pre>\n\n<h1 id=\"更新期号\">更新期号</h1>\n\n<p>以后再使用时，只需要抓取缺失的期号</p>\n\n<pre><code>def update_ids():\n  # 拿到所有期号\n  url=\"http://kaijiang.500.com/shtml/ssq/18016.shtml\"\n  req = requests.get(url)\n\n  soup = BeautifulSoup(req.text, 'html.parser')\n  linkids = re.compile(\"link[0-9]+\")\n  all_ids = soup.find(attrs={'class':'iSelectBox'})\n  all_links = all_ids.find_all('a')\n\n  new_ids = []\n  for link_id in all_links:\n    new_ids.append(link_id.string)\n\n  # 拿到已经抓取的期号\n  old_ids = []\n  with open(\"ssq_all_ids.txt\", 'r') as f:\n    old_ids = f.readlines()\n  old_ids_new = [one.replace('\\n','') for one in old_ids]\n  # 转换成set，方便查找\n  old_ids_set = set(old_ids_new)\n\n  for one in new_ids:\n    # 如果没抓取过，那么抓取\n    if not one in old_ids_set:\n      url=\"http://kaijiang.500.com/shtml/ssq/\"+one.replace('\\n','')+\".shtml\"\n      try:\n        get_ball(url, one)\n        with open(\"ssq_all_ids.txt\", 'a') as f:\n          f.write(one+\"\\n\")\n        print(\"update  id \"+one)\n      except Exception as e:\n        print(e)\n        with open('ssq_err_ids.txt', 'a+') as f:\n          f.write(one+'\\n')\n\t\t  </code></pre>\n\n<h1 id=\"初始抓取\">初始抓取</h1>\n\n<pre><code>def main():\n  # 把所有期号读进来\n  all_ids = []\n  with open('ssq_all_ids.txt', 'r') as f:\n    all_ids = f.readlines()\n\n  # 把每一期的开奖号码抓下来\n  for one_id in all_ids:\n    one_id = one_id.replace('\\n','')\n    url=\"http://kaijiang.500.com/shtml/ssq/\"+one_id+\".shtml\"\n    try:\n      get_ball(url, one_id)\n      time.sleep(.100)\n    except Exception as e:\n      print(e)\n      # 做异常判断，防止漏抓取内容\n      f = open('ssq_err_ids.txt', 'a+')\n      f.write(one_id+'\\n')\n      f.close()\n\t\t  \n\t\t  </code></pre>\n\n<p>现在就可以运行</p>\n\n<pre><code>get_all_option()\nmain()\n</code></pre>\n\n<p>抓取所有历史开奖号码了</p>\n\n<p>接下来可以模拟开奖号码，写数据库了</p>\n\n<h1 id=\"数据库脚本\">数据库脚本</h1>\n\n<pre><code># 删除库的脚本\nsql_drop_guess = '''\ndrop table guess;\n'''\n# 创建库的脚本\n# id 是主键，自增\n# nxx是对应模拟的号码，随机出2，那么n02列就有值，可以记录1，或者直接记录2\n# 没有模拟出来的号，那对应的列就是默认值0\n# count 是对应模拟出的号的个数，可能同一号码，会模拟出多次\n# 就好像全国2亿注彩票，可能还有人买重了\n# 为了优化，还建立了唯一索引\n# 这里只是模拟红球，因为篮球只有16个号，刨除上一期开的号，那就是只有15个号\n# 如果觉得哪一组红球比较有戏，可以拖15个篮球，所以随机模拟时，不考虑篮球\nsql_create_guess = '''\nCREATE TABLE guess (\n  id INTEGER primary key AUTOINCREMENT,\n  n01 int default 0, n02 int default 0, n03 int default 0,\n  n04 int default 0, n05 int default 0, n06 int default 0,\n  n07 int default 0, n08 int default 0, n09 int default 0,\n  n10 int default 0, n11 int default 0, n12 int default 0,\n  n13 int default 0, n14 int default 0, n15 int default 0,\n  n16 int default 0, n17 int default 0, n18 int default 0,\n  n19 int default 0, n20 int default 0, n21 int default 0,\n  n22 int default 0, n23 int default 0, n24 int default 0,\n  n25 int default 0, n26 int default 0, n27 int default 0,\n  n28 int default 0, n29 int default 0, n30 int default 0,\n  n31 int default 0, n32 int default 0, n33 int default 0,\n  count int,\n  unique (n01,n02,n03,n04,n05,n06,n07,n08,n09,n10,\n          n11,n12,n13,n14,n15,n16,n17,n18,n19,n20,\n          n21,n22,n23,n24,n25,n26,n27,n28,n29,n30,n31,n32,n33)\n);\n'''</code></pre>\n\n<h1 id=\"删库和建库代码\">删库和建库代码</h1>\n\n<pre><code>def drop_guess_table():\n  # 连接数据库文件\n  conn = sqlite3.connect(dbname)\n  # 执行脚本\n  c = conn.cursor()\n  c.execute(sql_drop_guess)\n  conn.commit()\n  # 关闭数据库文件\n  conn.close()\n  print('drop guess success')\n\ndef create_guess_db():\n  # 连接数据库文件\n  conn = sqlite3.connect(dbname)\n  c = conn.cursor()\n  # 执行脚本\n  c.execute(sql_create_guess)\n  conn.commit()\n  # 关闭数据库文件\n  conn.close()\n  print('create db success')\n  </code></pre>\n\n<p>dbname 会定义成一个全局变量\n <br />双色球每周会开3期，所以每天一个数据库文件，就可以了</p>\n\n<h1 id=\"把历史开奖号读进来\">把历史开奖号读进来</h1>\n\n<pre><code>def get_all_history():\n  # 读取历史开奖号码文件\n  lines = []\n  with open('ssq_hit_ids.txt') as f:\n    lines = f.readlines()\n\n  all_red=set()\n  for line in lines:\n    if len(line) &lt;= 0:\n      continue\n    # 摘取红号  \n    red_balls = line.split('|')[1].split(',')\n    # 红号排序，并组织成\"红号1,红号2,红号3,红号4,红号5,红号6\"的字符串放入set中，方便查找\n    int_red_balls = []\n    for one in red_balls:\n      int_red_balls.append(int(one))\n    int_red_balls.sort()\n    str_red_balls=[str(one) for one in int_red_balls]\n    all_red.add(','.join(str_red_balls))\n\n  return all_red\n  </code></pre>\n\n<h1 id=\"生成一组红号\">生成一组红号</h1>\n\n<pre><code>def gen_one():\n  # 33个红球\n  # 这里可以优化，比如想杀号，定胆的情况下\n  all_red_balls = list(range(1,33+1))\n  gen_red_balls = []\n  # 把所有可能的号随机打乱\n  # 取一个，从列表里删除一个，防止取到重复的红号\n  index = random.randrange(0, len(all_red_balls))\n  gen_red_balls.append(all_red_balls.pop(index))\n\n  index = random.randrange(0, len(all_red_balls))\n  gen_red_balls.append(all_red_balls.pop(index))\n\n  index = random.randrange(0, len(all_red_balls))\n  gen_red_balls.append(all_red_balls.pop(index))\n\n  index = random.randrange(0, len(all_red_balls))\n  gen_red_balls.append(all_red_balls.pop(index))\n\n  index = random.randrange(0, len(all_red_balls))\n  gen_red_balls.append(all_red_balls.pop(index))\n\n  index = random.randrange(0, len(all_red_balls))\n  gen_red_balls.append(all_red_balls.pop(index))\n\n  gen_red_balls.sort()\n  return gen_red_balls</code></pre>\n\n<h1 id=\"生成n注并过滤历史开奖号\">生成N注，并过滤历史开奖号</h1>\n\n<pre><code>def gen():\n  # 拿到历史开奖号\n  red_history = get_all_history()\n  all_red_balls = {}\n  # run_count是指定的模拟多少注\t  \n  global run_count\n  while run_count &gt; 0:\n    run_count -= 1\n    in_history = True\n    while in_history:\n      # 生成一组，然后构造成\",”连接的字符串，然后过滤历史号\n      red_balls = gen_one()\n      str_red_balls = [str(one) for one in red_balls]\n      one_red = \",\".join(str_red_balls)\n      if not one_red in red_history:\n        # 同一号码，累计+1\n        all_red_balls[one_red] = all_red_balls.get(one_red, 0) + 1\n        in_history = False\n  print(\"gen all balls\")\n  return all_red_balls\n  </code></pre>\n\n<h1 id=\"准备写入数据库\">准备写入数据库</h1>\n\n<p>数据库列辅助函数</p>\n\n<pre><code>def get_ball_col(ball):\n  if int(ball) &lt; 10:\n    return 'n0'+ball\n  else:\n    return 'n'+ball</code></pre>\n\n<h1 id=\"动态构造插入和更新数据库sql\">动态构造插入和更新数据库SQL</h1>\n\n<pre><code>def get_sql_insert(ored, count):\n  # ored 红球数组\n  # count 对应红球重复的个数\n  col1 = get_ball_col(ored[0])\n  col2 = get_ball_col(ored[1])\n  col3 = get_ball_col(ored[2])\n  col4 = get_ball_col(ored[3])\n  col5 = get_ball_col(ored[4])\n  col6 = get_ball_col(ored[5])\n  sql = 'insert into guess('+col1+','+col2+','+col3+','+col4+','+col5+','+col6+',count) values('+ored[0]+','+ored[1]+','+ored[2]+','+ored[\\\n3]+','+ored[4]+','+ored[5]+','+str(count)+')'\n  return sql\n\ndef get_sql_update(ored, count):\n  # ored 红球数组\n  # count 对应红球重复的个数\n  col1 = get_ball_col(ored[0])\n  col2 = get_ball_col(ored[1])\n  col3 = get_ball_col(ored[2])\n  col4 = get_ball_col(ored[3])\n  col5 = get_ball_col(ored[4])\n  col6 = get_ball_col(ored[5])\n  sql = 'update guess set count=count+%s where '+col1+'=%s and '+col2+'=%s and '+col3+'=%s and '+col4+'=%s and '+col5+'=%s and '+col6+'=%s\\\n'\n  return sql % (count, ored[0], ored[1], ored[2], ored[3], ored[4], ored[5])\n  </code></pre>\n\n<h1 id=\"写入数据库\">写入数据库</h1>\n\n<pre><code>def update_all_red_balls(all_red_balls):\n  # all_red_balls 所有模拟出的红球\n  conn = sqlite3.connect(dbname)\n  c = conn.cursor()\n  for k in all_red_balls:\n    # 单组红号分拆成数组\n    red_balls = k.split(',')\n    count = all_red_balls[k]\n    # 如果插入失败，则尝试更新count\n    try:\n      sql = get_sql_insert(red_balls, count)\n      c.execute(sql)\n    except Exception:\n      sql = get_sql_update(red_balls, count)\n      c.execute(sql)\n  conn.commit()\n  conn.close()\n  </code></pre>\n\n<p>还有一种做法，每生成一组红号就写入数据库，通过try catch来插入或者更新\n <br />这种方式，生成数量小的话，还可以接受，比如10万注，当生成上亿注时，这个效率就不可接受了\n <br />第一版就是每生成一注就写数据库，跑1亿注，结果跑了48小时都没有跑完\n <br />所以优化成现在这样，先把所有期望生成的彩票都生成，然后一次都写入数据库，效率提升了N倍</p>\n\n<h1 id=\"运行\">运行</h1>\n\n<pre><code>dbname = \"ssq-2018-3-1.db\"\nrun_count = 100000000\n</code></pre>\n\n<p>可以在每次运行之前先跑一遍</p>\n\n<pre><code>update_ids()</code></pre>\n\n<p>更新历史开奖号\n <br />每次新模拟，需要先创建数据库文件</p>\n\n<pre><code>create_guess_db()\n</code></pre>\n\n<p>如果操作失误，可以先删除数据库</p>\n\n<pre><code>drop_guess_table()\n</code></pre>\n\n<p>或者修改 dbname，再创建 create_guess_db()</p>\n\n<pre><code>begin = datetime.datetime.now()\nupdate_all_red_balls(gen())\nend = datetime.datetime.now()\n\nprint((end-begin).total_seconds())\n</code></pre>\n\n<p>记录开始时间，运行，然后记录结束时间，看看N注彩票运行了多久</p>\n\n<p>JUST FOR FUN!</p>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2013-06-22-doubanfmhunter.md" . unix) f post (u . "豆瓣FM Hunter") (? . 0) 1505574346 (p+ #"/Users/zhonghua/demo/zhonghua_com/2013/06/\350\261\206\347\223\243fm-hunter.html" . unix) (u . "/2013/06/%E8%B1%86%E7%93%A3fm-hunter.html") (u . "2013-06-22T00:00:00") (? . 24) (? . 1) () (u . "\n<p>前两天在听豆瓣电台，想把听到的歌都下载下来。 于是做了一个火狐浏览器的插件，doubanfmhunter。</p>\n\n<p>这里介绍一下主要用到的点，完整代码在<a href=\"https://builder.addons.mozilla.org/package/190551/latest/\">https://builder.addons.mozilla.org/package/190551/latest/</a>。因为用的是firefox的addon builder，所以放到github上倒麻烦，就不放了。</p>\n\n<ol>\n <li>\n  <p>首先要通过firefox的调试平台看到请求的GET地址，也就是播放的MP3的地址。</p></li>\n <li>\n  <p>使用events监听http-on-modify-request事件。 当接收到类似1里面监听的url地址时，记录下来该地址。</p></li>\n <li>\n  <p>搭建一个sae的后台，想下载该MP3时，请求该SAE后台下载该MP3.</p></li></ol>\n\n<p>遇到一些问题，还没有时间去深入研究，如果路过的人知道答案，告知在下，不胜感激。</p>\n\n<ol>\n <li>\n  <p>通过调试发现，豆瓣电台应该是先请求一个带playlist的地址，返回一个json，里面有很多的mp3地址，以及专辑信息。 然后再请求一个mp3地址。但是请求的mp3地址并不在返回的json里，所以也不知道他们是怎么选择这个mp3地址的。</p></li>\n <li>\n  <p>api文档里说text-streams是在io下面，也就是require(&ldquo;io/text-streams&rdquo;)。 但是就是编译不通过，后来下载代码发现看类库的代码，才知道写成require(&ldquo;text-streams&rdquo;)。 但是遇到byte-streams时，不管使用require(&ldquo;io/byte-streams&rdquo;)或者require(&ldquo;byte-streams&rdquo;)，都不行，所以最后只能把byte-streams里的ByteReader的代码拿出来，改改用。</p></li>\n <li>\n  <p>在使用这里的代码去监听baidu的mp3时，总是出现错误，还未深入研究。</p></li>\n <li>\n  <p>如果想监听http-on-examine-response事件，需要注意一点的是这个事件是在数据到达之前就会触发的。所以这时要写一个listener，在代码里有。</p></li>\n <li>\n  <p>本来想通过本地直接下载，window.location.href=\"data:xxx\"之类的方式达到下载的目的，可是试了很多方法都没成功。最后只能通过在SAE上建立一应用来达到下载文件的目的。这个是我最想解决的。</p></li></ol>") #f (u . "\n<p>前两天在听豆瓣电台，想把听到的歌都下载下来。 于是做了一个火狐浏览器的插件，doubanfmhunter。</p>\n\n<p>这里介绍一下主要用到的点，完整代码在<a href=\"https://builder.addons.mozilla.org/package/190551/latest/\">https://builder.addons.mozilla.org/package/190551/latest/</a>。因为用的是firefox的addon builder，所以放到github上倒麻烦，就不放了。</p>\n\n<ol>\n <li>\n  <p>首先要通过firefox的调试平台看到请求的GET地址，也就是播放的MP3的地址。</p></li>\n <li>\n  <p>使用events监听http-on-modify-request事件。 当接收到类似1里面监听的url地址时，记录下来该地址。</p></li>\n <li>\n  <p>搭建一个sae的后台，想下载该MP3时，请求该SAE后台下载该MP3.</p></li></ol>\n\n<p>遇到一些问题，还没有时间去深入研究，如果路过的人知道答案，告知在下，不胜感激。</p>\n\n<ol>\n <li>\n  <p>通过调试发现，豆瓣电台应该是先请求一个带playlist的地址，返回一个json，里面有很多的mp3地址，以及专辑信息。 然后再请求一个mp3地址。但是请求的mp3地址并不在返回的json里，所以也不知道他们是怎么选择这个mp3地址的。</p></li>\n <li>\n  <p>api文档里说text-streams是在io下面，也就是require(&ldquo;io/text-streams&rdquo;)。 但是就是编译不通过，后来下载代码发现看类库的代码，才知道写成require(&ldquo;text-streams&rdquo;)。 但是遇到byte-streams时，不管使用require(&ldquo;io/byte-streams&rdquo;)或者require(&ldquo;byte-streams&rdquo;)，都不行，所以最后只能把byte-streams里的ByteReader的代码拿出来，改改用。</p></li>\n <li>\n  <p>在使用这里的代码去监听baidu的mp3时，总是出现错误，还未深入研究。</p></li>\n <li>\n  <p>如果想监听http-on-examine-response事件，需要注意一点的是这个事件是在数据到达之前就会触发的。所以这时要写一个listener，在代码里有。</p></li>\n <li>\n  <p>本来想通过本地直接下载，window.location.href=\"data:xxx\"之类的方式达到下载的目的，可是试了很多方法都没成功。最后只能通过在SAE上建立一应用来达到下载文件的目的。这个是我最想解决的。</p></li></ol>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2013-11-24-flash-jsfl-cocos2d-js-app.md" . unix) f post (u . "使用flash开发cocos2d-x的app") (? . 4) 1505574816 (p+ #"/Users/zhonghua/demo/zhonghua_com/2013/11/\344\275\277\347\224\250flash\345\274\200\345\217\221cocos2d-x\347\232\204app.html" . unix) (u . "/2013/11/%E4%BD%BF%E7%94%A8flash%E5%BC%80%E5%8F%91cocos2d-x%E7%9A%84app.html") (u . "2013-11-24T00:00:00") (? . 9) (? . 3) () (u . "\n<p>使用flash做cocos2d-x的app的工具基本上告一个段落，做了一段视频</p>\n\n<p><a href=\"http://www.tudou.com/programs/view/iz10aSfMeVk/?resourceId=0_06_02_99\">http://www.tudou.com/programs/view/iz10aSfMeVk/?resourceId=0_06_02_99</a></p>\n\n<p>接下来还不知道要怎么做，要么卖出去，要么开源。</p>\n\n<p>不过可以肯定的是，我得自己先使用它，完善它，所以准备用自己的工具做一个app。</p>") #f (u . "\n<p>使用flash做cocos2d-x的app的工具基本上告一个段落，做了一段视频</p>\n\n<p><a href=\"http://www.tudou.com/programs/view/iz10aSfMeVk/?resourceId=0_06_02_99\">http://www.tudou.com/programs/view/iz10aSfMeVk/?resourceId=0_06_02_99</a></p>\n\n<p>接下来还不知道要怎么做，要么卖出去，要么开源。</p>\n\n<p>不过可以肯定的是，我得自己先使用它，完善它，所以准备用自己的工具做一个app。</p>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2013-07-18-sdl20-compile.md" . unix) f post (u . "编译使用SDL2.0") (? . 2) 1505574521 (p+ #"/Users/zhonghua/demo/zhonghua_com/2013/07/\347\274\226\350\257\221\344\275\277\347\224\250sdl2-0.html" . unix) (u . "/2013/07/%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8sdl2-0.html") (u . "2013-07-01T00:00:00") (? . 1) (? . 10) () (u . "\n<p>SDL2.0 可以支持非英文的输入。 也有第三方的朋友做了一个SDL插件也支持非英文输入。 这里记录一下在尝试过程中遇到一些编译问题。</p>\n\n<p>参照文档写了一个demo</p>\n\n<pre><code>#include \"../include/SDL.h\"\n\n//The event structure\nSDL_Event event;\nchar text[1024];\nSDL_Surface *screen = NULL;\nconst int SCREEN_WIDTH = 640;\nconst int SCREEN_HEIGHT = 480;\nconst int SCREEN_BPP = 32;\n\n#include &lt;string&gt;\n\nstd::string composition;\nint cursor;\nint selection_len = 0;\n\n\n#include \"SDL.h\"\n\nint main(int argc, char* argv[])\n{\n    SDL_Window* window;\n    SDL_Renderer* renderer;\n\n    // Initialize SDL.\n    if (SDL_Init(SDL_INIT_VIDEO) &lt; 0)\n            return 1;\n\n    // Create the window where we will draw.\n    window = SDL_CreateWindow(\"SDL_RenderClear\",\n                    SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,\n                    512, 512,\n                    SDL_WINDOW_SHOWN);\n\n    // We must call SDL_CreateRenderer in order for draw calls to affect this window.\n    renderer = SDL_CreateRenderer(window, -1, 0);\n\n    // Select the color for drawing. It is set to red here.\n    SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);\n\n    // Clear the entire screen to our selected color.\n    SDL_RenderClear(renderer);\n\n    // Up until now everything was drawn behind the scenes.\n    // This will show the new, red contents of the window.\n    SDL_RenderPresent(renderer);\n\n\tSDL_StartTextInput();\n\t\n    while (true)\n    {\n        if (SDL_PollEvent(&amp;event))\n        {\n            switch (event.type)\n            {\n                case SDL_TEXTINPUT:\n                    /* Add new text onto the end of our text */\n                    strcat(text, event.text.text);\n                    break;\n                case SDL_TEXTEDITING:\n                    /*\n                    Update the composition text.\n                    Update the cursor position.\n                    Update the selection length (if any).\n                    */\n                    composition = event.edit.text;\n                    cursor = event.edit.start;\n                    selection_len = event.edit.length;\n                    break;\n            }\n        }\n\n    }\n    // Give us time to see the window.\n    SDL_Delay(1000);\n\n    // Always be sure to clean up\n    SDL_Quit();\n    return 0;\n}\n\n</code></pre>\n\n<p>Makefile 这样写的</p>\n\n<pre><code>all:\n\tg++ -g testime.cpp -I/home/zhuzhonghua/work/SDL/include /home/zhuzhonghua/work/SDL/build/.libs/libSDL2.a /home/zhuzhonghua/work/SDL/build/libSDL2main.a -lpthread -lGL -lGLU -lm -L/usr/lib/x86_64-linux-gnu -lrt -ldl</code></pre>\n\n<p>demo写的有问题，需要写一个退出函数，要不然总是关不掉。</p>\n\n<p>本人喜欢静态编译，所以就全部使用的.a文件。</p>\n\n<p>刚开始编译时会遇到dlsym undefined reference 的问题，加上-ldl选项就OK了。</p>\n\n<p>遇到clock_gettime undefined reference，那么加上-lrt的选项，就OK 了。</p>") #f (u . "\n<p>SDL2.0 可以支持非英文的输入。 也有第三方的朋友做了一个SDL插件也支持非英文输入。 这里记录一下在尝试过程中遇到一些编译问题。</p>\n\n<p>参照文档写了一个demo</p>\n\n<pre><code>#include \"../include/SDL.h\"\n\n//The event structure\nSDL_Event event;\nchar text[1024];\nSDL_Surface *screen = NULL;\nconst int SCREEN_WIDTH = 640;\nconst int SCREEN_HEIGHT = 480;\nconst int SCREEN_BPP = 32;\n\n#include &lt;string&gt;\n\nstd::string composition;\nint cursor;\nint selection_len = 0;\n\n\n#include \"SDL.h\"\n\nint main(int argc, char* argv[])\n{\n    SDL_Window* window;\n    SDL_Renderer* renderer;\n\n    // Initialize SDL.\n    if (SDL_Init(SDL_INIT_VIDEO) &lt; 0)\n            return 1;\n\n    // Create the window where we will draw.\n    window = SDL_CreateWindow(\"SDL_RenderClear\",\n                    SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,\n                    512, 512,\n                    SDL_WINDOW_SHOWN);\n\n    // We must call SDL_CreateRenderer in order for draw calls to affect this window.\n    renderer = SDL_CreateRenderer(window, -1, 0);\n\n    // Select the color for drawing. It is set to red here.\n    SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);\n\n    // Clear the entire screen to our selected color.\n    SDL_RenderClear(renderer);\n\n    // Up until now everything was drawn behind the scenes.\n    // This will show the new, red contents of the window.\n    SDL_RenderPresent(renderer);\n\n\tSDL_StartTextInput();\n\t\n    while (true)\n    {\n        if (SDL_PollEvent(&amp;event))\n        {\n            switch (event.type)\n            {\n                case SDL_TEXTINPUT:\n                    /* Add new text onto the end of our text */\n                    strcat(text, event.text.text);\n                    break;\n                case SDL_TEXTEDITING:\n                    /*\n                    Update the composition text.\n                    Update the cursor position.\n                    Update the selection length (if any).\n                    */\n                    composition = event.edit.text;\n                    cursor = event.edit.start;\n                    selection_len = event.edit.length;\n                    break;\n            }\n        }\n\n    }\n    // Give us time to see the window.\n    SDL_Delay(1000);\n\n    // Always be sure to clean up\n    SDL_Quit();\n    return 0;\n}\n\n</code></pre>\n\n<p>Makefile 这样写的</p>\n\n<pre><code>all:\n\tg++ -g testime.cpp -I/home/zhuzhonghua/work/SDL/include /home/zhuzhonghua/work/SDL/build/.libs/libSDL2.a /home/zhuzhonghua/work/SDL/build/libSDL2main.a -lpthread -lGL -lGLU -lm -L/usr/lib/x86_64-linux-gnu -lrt -ldl</code></pre>\n\n<p>demo写的有问题，需要写一个退出函数，要不然总是关不掉。</p>\n\n<p>本人喜欢静态编译，所以就全部使用的.a文件。</p>\n\n<p>刚开始编译时会遇到dlsym undefined reference 的问题，加上-ldl选项就OK了。</p>\n\n<p>遇到clock_gettime undefined reference，那么加上-lrt的选项，就OK 了。</p>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2012-06-07-mingw-gcc-gdb.md" . unix) f post (u . "在mingw环境下编译最新版本gcc gdb") (? . 21) 1505573657 (p+ #"/Users/zhonghua/demo/zhonghua_com/2012/06/\345\234\250mingw\347\216\257\345\242\203\344\270\213\347\274\226\350\257\221\346\234\200\346\226\260\347\211\210\346\234\254gcc-gdb.html" . unix) (u . "/2012/06/%E5%9C%A8mingw%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%BC%96%E8%AF%91%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%ACgcc-gdb.html") (u . "2012-06-07T00:00:00") #f (? . 11) () (u . "\n<p>由于比较喜欢GCC的东西，又必须做WIN下的程序，但是考虑到效率问题 \n <br /> 1，使用LINUX交叉编译MINGW下的程序 \n <br /> 2，直接使用MINGW和MSYS编译WIN程序</p>\n\n<p>使用交叉编译的方法，在网上搜到的比较麻烦，而且又不是做嵌入式开发，必须用交叉编译; \n <br /> 所以决定使用第二种方法。</p>\n\n<p>目前已经成功编译了GDB7.4.1和最新的BINUTILS，还有MPC，MPFR，等GCC需要依赖的库。 \n <br /> 晚上回去看一下GCC4.7.0的编译情况。</p>\n\n<p>不过在公司已经使用MINGW-GET拿到了GDB7.4和GCC4.6.2,而且使用正常。</p>\n\n<p>2012-06-08</p>\n\n<p>昨晚回去，出现了诡异的dllcrt2.o文件找不到的问题 \n <br /> 由于时间有限，又急着建立开发环境，所以决定把公司里使用mingw-get的版本拿回去。 \n <br /> 奇怪的是，家里使用mingw-get无法获取各种包，也就是不能用。</p>\n\n<p>今天在公司，不甘心，利用业余时间终于把这个问题搞定。</p>\n\n<p>网上也有人遇到这个问题，文件是有的，在/mingw/lib下</p>\n\n<p>刚开始使用LDFLAGS无效，后来使用GCC_EXEC_PREFIX连configure都无法通过。</p>\n\n<p>在这个命令的下面看到了，LIBRARY_PATH，于是灵光一现，配置好/mingw/lib</p>\n\n<p>结果编译了一个下午, 公司的电脑还算好的。</p>\n\n<p>自己编译GCC真不是玩的。花的时间太久了。</p>\n\n<p>不过总算了解了自己的一个心病。</p>\n\n<p>而且在网上差资料，关于dllcrt2.o的东西，都是外文。这里也算有个中文的关于这个的资料吧。</p>\n\n<p>tips:</p>\n\n<p>1, BINUTILS要使用最新版本，这个编译起来很快。 \n <br /> 要不然会出现unknown-pseudo .cfi_sections 2, 还有它依赖的其他库文件</p>\n\n<p>其他问题就不大了，祝各位看官好运</p>") #f (u . "\n<p>由于比较喜欢GCC的东西，又必须做WIN下的程序，但是考虑到效率问题 \n <br /> 1，使用LINUX交叉编译MINGW下的程序 \n <br /> 2，直接使用MINGW和MSYS编译WIN程序</p>\n\n<p>使用交叉编译的方法，在网上搜到的比较麻烦，而且又不是做嵌入式开发，必须用交叉编译; \n <br /> 所以决定使用第二种方法。</p>\n\n<p>目前已经成功编译了GDB7.4.1和最新的BINUTILS，还有MPC，MPFR，等GCC需要依赖的库。 \n <br /> 晚上回去看一下GCC4.7.0的编译情况。</p>\n\n<p>不过在公司已经使用MINGW-GET拿到了GDB7.4和GCC4.6.2,而且使用正常。</p>\n\n<p>2012-06-08</p>\n\n<p>昨晚回去，出现了诡异的dllcrt2.o文件找不到的问题 \n <br /> 由于时间有限，又急着建立开发环境，所以决定把公司里使用mingw-get的版本拿回去。 \n <br /> 奇怪的是，家里使用mingw-get无法获取各种包，也就是不能用。</p>\n\n<p>今天在公司，不甘心，利用业余时间终于把这个问题搞定。</p>\n\n<p>网上也有人遇到这个问题，文件是有的，在/mingw/lib下</p>\n\n<p>刚开始使用LDFLAGS无效，后来使用GCC_EXEC_PREFIX连configure都无法通过。</p>\n\n<p>在这个命令的下面看到了，LIBRARY_PATH，于是灵光一现，配置好/mingw/lib</p>\n\n<p>结果编译了一个下午, 公司的电脑还算好的。</p>\n\n<p>自己编译GCC真不是玩的。花的时间太久了。</p>\n\n<p>不过总算了解了自己的一个心病。</p>\n\n<p>而且在网上差资料，关于dllcrt2.o的东西，都是外文。这里也算有个中文的关于这个的资料吧。</p>\n\n<p>tips:</p>\n\n<p>1, BINUTILS要使用最新版本，这个编译起来很快。 \n <br /> 要不然会出现unknown-pseudo .cfi_sections 2, 还有它依赖的其他库文件</p>\n\n<p>其他问题就不大了，祝各位看官好运</p>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2014-01-05-xui-flash-cocos2d-x-html5.md" . unix) f post (u . "XUI 是一个能够让你使用flash cs这样的富媒体创作工具，来制作cocos2d-x 和 cocos2d-html5手游的工具") (? . 3) 1505574879 (p+ #"/Users/zhonghua/demo/zhonghua_com/2014/01/xui-\346\230\257\344\270\200\344\270\252\350\203\275\345\244\237\350\256\251\344\275\240\344\275\277\347\224\250flash-cs\350\277\231\346\240\267\347\232\204\345\257\214\345\252\222\344\275\223\345\210\233\344\275\234\345\267\245\345\205\267-\346\235\245\345\210\266\344\275\234cocos2d-x-\345\222\214-cocos2d-html5\346\211\213\346\270\270\347\232\204\345\267\245\345\205\267.html" . unix) (u . "/2014/01/xui-%E6%98%AF%E4%B8%80%E4%B8%AA%E8%83%BD%E5%A4%9F%E8%AE%A9%E4%BD%A0%E4%BD%BF%E7%94%A8flash-cs%E8%BF%99%E6%A0%B7%E7%9A%84%E5%AF%8C%E5%AA%92%E4%BD%93%E5%88%9B%E4%BD%9C%E5%B7%A5%E5%85%B7-%E6%9D%A5%E5%88%B6%E4%BD%9Ccocos2d-x-%E5%92%8C-cocos2d-html5%E6%89%8B%E6%B8%B8%E7%9A%84%E5%B7%A5%E5%85%B7.html") (u . "2014-01-05T00:00:00") (? . 4) (? . 8) () (u . "\n<p>以前在读founders at work时，对其中的restless programmer这个词很有感触\n <br />就是各种折腾\n <br />前段时间，自己折腾了一个这样的工具</p>\n\n<p>一个能够让你使用flash cs这样的富媒体创作工具，来制作cocos2d-x 和 cocos2d-html5手游的工具</p>\n\n<h4 id=\"项目地址在这里\">项目地址在这里</h4>\n\n<p><a href=\"https://github.com/zhuzhonghua/XUI\">https://github.com/zhuzhonghua/XUI</a></p>") #f (u . "\n<p>以前在读founders at work时，对其中的restless programmer这个词很有感触\n <br />就是各种折腾\n <br />前段时间，自己折腾了一个这样的工具</p>\n\n<p>一个能够让你使用flash cs这样的富媒体创作工具，来制作cocos2d-x 和 cocos2d-html5手游的工具</p>\n\n<h4 id=\"项目地址在这里\">项目地址在这里</h4>\n\n<p><a href=\"https://github.com/zhuzhonghua/XUI\">https://github.com/zhuzhonghua/XUI</a></p>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2018-07-18-c-c-\344\270\216chibi-scheme\344\272\222\347\233\270\350\260\203\347\224\250.md" . unix) f post (u . "c/c++与chibi-scheme互相调用") (? . 5) 1532852293 (p+ #"/Users/zhonghua/demo/zhonghua_com/2018/07/c-c-\344\270\216chibi-scheme\344\272\222\347\233\270\350\260\203\347\224\250.html" . unix) (u . "/2018/07/c-c-%E4%B8%8Echibi-scheme%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8.html") (u . "2018-07-18T07:56:25") (? . 6) (? . 7) (c (u . "Lisp") c (u . "scheme") c (u . "chibi-scheme") c (u . "c/c++")) (u . "\n<p>测试环境是mac</p>\n\n<p>chibi-scheme是scheme/lisp的一种实现，适合作为脚本语言嵌入到c/c++程序中</p>\n\n<p><a href=\"http://synthcode.com/scheme/chibi/#h2_EmbeddinginC\">chibi-scheme官方文档</a>写的很清楚，只是没有实例</p>\n\n<p><a href=\"http://klamp.works/2016/02/05/chibi-scheme-1.html\">外国友人写的相关教程</a>结合实例，写的很清楚</p>\n\n<p><a href=\"https://github.com/zhuzhonghua/chibi-scheme.git\">代码库地址</a> 里的c2scheme目录是示例代码</p>\n\n<p>大体分成三步</p>\n\n<ol>\n <li>加载scheme文件\n  <br /></li>\n <li>调用scheme函数代码，传递参数，接收返回值\n  <br /></li>\n <li>scheme代码调用c/c++代码，传递参数，接收返回值</li></ol>\n\n<p>callme.scm</p>\n\n<pre><code>(import (chibi))\n(define (say-hello)\n  (display \"hello world from scheme\")\n  (newline))</code></pre>\n\n<h1 id=\"加载scheme文件\">加载scheme文件</h1>\n\n<p>构造字符串，然后加载</p>\n\n<pre><code>obj1 = sexp_c_string(ctx, \"callme.scm\", -1);\nsexp_load(ctx, obj1, NULL);</code></pre>\n\n<h1 id=\"调用scheme函数代码传递参数接收返回值\">调用scheme函数代码，传递参数，接收返回值</h1>\n\n<p>调用scheme函数代码</p>\n\n<pre><code>sexp_eval_string(ctx, \"(say-hello)\", -1, NULL);</code></pre>\n\n<p>传递参数</p>\n\n<pre><code>arg_val = sexp_make_fixnum(4);\narg_sym = sexp_intern(ctx, \"arg\", -1);\nsexp_env_define(ctx, sexp_context_env(ctx), arg_sym, arg_val);\n\nfile_path = sexp_c_string(ctx, \"callme.scm\", -1);\nsexp_load(ctx, file_path, NULL);</code></pre>\n\n<p>接收返回值</p>\n\n<pre><code>ret = sexp_eval_string(ctx, \"(square arg)\", -1, NULL);\nint result = -1;\nif (sexp_integerp(ret)) {\n  result = sexp_unbox_fixnum(ret);\n}</code></pre>\n\n<p>callme.scm</p>\n\n<pre><code>(define (square a)\n  (* a a))</code></pre>\n\n<h1 id=\"scheme代码调用cc代码传递参数接收返回值\">scheme代码调用c/c++代码，传递参数，接收返回值</h1>\n\n<p>callme.scm</p>\n\n<pre><code>(define (say-hello)\n\t(display \"hello world from scheme\")\n\t(newline)\n\t(hello-user \"chibi-scheme\"))</code></pre>\n\n<p>hello-user是c/c++函数，传递一个字符串\n <br />在c/c++中横线会转换成下划线</p>\n\n<p>定义头文件</p>\n\n<p>c2scheme.h</p>\n\n<pre><code>extern void hello_user(const char* tmp);</code></pre>\n\n<p>定义stub文件</p>\n\n<p>c2scheme.stub</p>\n\n<pre><code>(c-include \"c2scheme.h\")\t\n(define-c void hello-user (string))</code></pre>\n\n<p>stub文件主要便于生成对应的c/c++文件</p>\n\n<p>然后运行</p>\n\n<pre><code>DYLD_LIBRARY_PATH=. ./chibi-scheme ./tools/chibi-ffi c2scheme/c2scheme.stub</code></pre>\n\n<p>会生成对应的c/c++文件，我们看下它的内容</p>\n\n<p>c2scheme.c</p>\n\n<pre><code>/* Automatically generated by chibi-ffi; version: 0.4 */\n\n#include &lt;chibi/eval.h&gt;\n\n#include \"c2scheme.h\"\n/*\ntypes: ()\nenums: ()\n*/\n\nsexp sexp_hello_user_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {\n  sexp res;\n  if (! sexp_stringp(arg0))\n    return sexp_type_exception(ctx, self, SEXP_STRING, arg0);\n  res = ((hello_user(sexp_string_data(arg0))), SEXP_VOID);\n  return res;\n}\n\n\nsexp sexp_init_library (sexp ctx, sexp self, sexp_sint_t n, sexp env, const char* version, const sexp_abi_identifier_t abi) {\n  sexp_gc_var3(name, tmp, op);\n  if (!(sexp_version_compatible(ctx, version, sexp_version)\n        &amp;&amp; sexp_abi_compatible(ctx, abi, SEXP_ABI_IDENTIFIER)))\n    return SEXP_ABI_ERROR;\n  sexp_gc_preserve3(ctx, name, tmp, op);\n  op = sexp_define_foreign(ctx, env, \"hello-user\", 1, sexp_hello_user_stub);\n  if (sexp_opcodep(op)) {\n    sexp_opcode_return_type(op) = SEXP_VOID;\n    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_STRING);\n  }\n  sexp_gc_release3(ctx);\n  return SEXP_VOID;\n}</code></pre>\n\n<p>只需要实现hello_user这个函数即可.</p>\n\n<p>我们在main.cpp里实现这个方法</p>\n\n<pre><code>void hello_user(const char* tmp){\n\tprintf(\"in hello user %s \\n\", tmp);\n}</code></pre>\n\n<p>将来可以把函数的声明和实现统一规划到别的文件去，这里只是做个示例。</p>\n\n<p>完整代码及编译运行脚本在上面的仓库地址。</p>\n\n<p>注意 (import (chibi)) 这是需要加载chibi-scheme的lib目录下的scm文件，默认搜索目录是./lib和.目录，所以当运行目录在别的地方时，需要添加module搜索目录</p>\n\n<pre><code>sexp_add_module_directory(ctx, tmp=sexp_c_string(ctx,\"../lib\",-1), SEXP_TRUE);  </code></pre>\n\n<p>视频链接\n <br /><a href=\"https://www.bilibili.com/video/av27986565/\">B站</a>\n <br /><a href=\"https://youtu.be/g4kv1KNKFp0\">Youtube</a></p>") #f (u . "\n<p>测试环境是mac</p>\n\n<p>chibi-scheme是scheme/lisp的一种实现，适合作为脚本语言嵌入到c/c++程序中</p>\n\n<p><a href=\"http://synthcode.com/scheme/chibi/#h2_EmbeddinginC\">chibi-scheme官方文档</a>写的很清楚，只是没有实例</p>\n\n<p><a href=\"http://klamp.works/2016/02/05/chibi-scheme-1.html\">外国友人写的相关教程</a>结合实例，写的很清楚</p>\n\n<p><a href=\"https://github.com/zhuzhonghua/chibi-scheme.git\">代码库地址</a> 里的c2scheme目录是示例代码</p>\n\n<p>大体分成三步</p>\n\n<ol>\n <li>加载scheme文件\n  <br /></li>\n <li>调用scheme函数代码，传递参数，接收返回值\n  <br /></li>\n <li>scheme代码调用c/c++代码，传递参数，接收返回值</li></ol>\n\n<p>callme.scm</p>\n\n<pre><code>(import (chibi))\n(define (say-hello)\n  (display \"hello world from scheme\")\n  (newline))</code></pre>\n\n<h1 id=\"加载scheme文件\">加载scheme文件</h1>\n\n<p>构造字符串，然后加载</p>\n\n<pre><code>obj1 = sexp_c_string(ctx, \"callme.scm\", -1);\nsexp_load(ctx, obj1, NULL);</code></pre>\n\n<h1 id=\"调用scheme函数代码传递参数接收返回值\">调用scheme函数代码，传递参数，接收返回值</h1>\n\n<p>调用scheme函数代码</p>\n\n<pre><code>sexp_eval_string(ctx, \"(say-hello)\", -1, NULL);</code></pre>\n\n<p>传递参数</p>\n\n<pre><code>arg_val = sexp_make_fixnum(4);\narg_sym = sexp_intern(ctx, \"arg\", -1);\nsexp_env_define(ctx, sexp_context_env(ctx), arg_sym, arg_val);\n\nfile_path = sexp_c_string(ctx, \"callme.scm\", -1);\nsexp_load(ctx, file_path, NULL);</code></pre>\n\n<p>接收返回值</p>\n\n<pre><code>ret = sexp_eval_string(ctx, \"(square arg)\", -1, NULL);\nint result = -1;\nif (sexp_integerp(ret)) {\n  result = sexp_unbox_fixnum(ret);\n}</code></pre>\n\n<p>callme.scm</p>\n\n<pre><code>(define (square a)\n  (* a a))</code></pre>\n\n<h1 id=\"scheme代码调用cc代码传递参数接收返回值\">scheme代码调用c/c++代码，传递参数，接收返回值</h1>\n\n<p>callme.scm</p>\n\n<pre><code>(define (say-hello)\n\t(display \"hello world from scheme\")\n\t(newline)\n\t(hello-user \"chibi-scheme\"))</code></pre>\n\n<p>hello-user是c/c++函数，传递一个字符串\n <br />在c/c++中横线会转换成下划线</p>\n\n<p>定义头文件</p>\n\n<p>c2scheme.h</p>\n\n<pre><code>extern void hello_user(const char* tmp);</code></pre>\n\n<p>定义stub文件</p>\n\n<p>c2scheme.stub</p>\n\n<pre><code>(c-include \"c2scheme.h\")\t\n(define-c void hello-user (string))</code></pre>\n\n<p>stub文件主要便于生成对应的c/c++文件</p>\n\n<p>然后运行</p>\n\n<pre><code>DYLD_LIBRARY_PATH=. ./chibi-scheme ./tools/chibi-ffi c2scheme/c2scheme.stub</code></pre>\n\n<p>会生成对应的c/c++文件，我们看下它的内容</p>\n\n<p>c2scheme.c</p>\n\n<pre><code>/* Automatically generated by chibi-ffi; version: 0.4 */\n\n#include &lt;chibi/eval.h&gt;\n\n#include \"c2scheme.h\"\n/*\ntypes: ()\nenums: ()\n*/\n\nsexp sexp_hello_user_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {\n  sexp res;\n  if (! sexp_stringp(arg0))\n    return sexp_type_exception(ctx, self, SEXP_STRING, arg0);\n  res = ((hello_user(sexp_string_data(arg0))), SEXP_VOID);\n  return res;\n}\n\n\nsexp sexp_init_library (sexp ctx, sexp self, sexp_sint_t n, sexp env, const char* version, const sexp_abi_identifier_t abi) {\n  sexp_gc_var3(name, tmp, op);\n  if (!(sexp_version_compatible(ctx, version, sexp_version)\n        &amp;&amp; sexp_abi_compatible(ctx, abi, SEXP_ABI_IDENTIFIER)))\n    return SEXP_ABI_ERROR;\n  sexp_gc_preserve3(ctx, name, tmp, op);\n  op = sexp_define_foreign(ctx, env, \"hello-user\", 1, sexp_hello_user_stub);\n  if (sexp_opcodep(op)) {\n    sexp_opcode_return_type(op) = SEXP_VOID;\n    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_STRING);\n  }\n  sexp_gc_release3(ctx);\n  return SEXP_VOID;\n}</code></pre>\n\n<p>只需要实现hello_user这个函数即可.</p>\n\n<p>我们在main.cpp里实现这个方法</p>\n\n<pre><code>void hello_user(const char* tmp){\n\tprintf(\"in hello user %s \\n\", tmp);\n}</code></pre>\n\n<p>将来可以把函数的声明和实现统一规划到别的文件去，这里只是做个示例。</p>\n\n<p>完整代码及编译运行脚本在上面的仓库地址。</p>\n\n<p>注意 (import (chibi)) 这是需要加载chibi-scheme的lib目录下的scm文件，默认搜索目录是./lib和.目录，所以当运行目录在别的地方时，需要添加module搜索目录</p>\n\n<pre><code>sexp_add_module_directory(ctx, tmp=sexp_c_string(ctx,\"../lib\",-1), SEXP_TRUE);  </code></pre>\n\n<p>视频链接\n <br /><a href=\"https://www.bilibili.com/video/av27986565/\">B站</a>\n <br /><a href=\"https://youtu.be/g4kv1KNKFp0\">Youtube</a></p>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2014-08-02-nodejs-log.md" . unix) f post (u . "在项目中使用Nodejs") (? . 8) 1505574915 (p+ #"/Users/zhonghua/demo/zhonghua_com/2014/08/\345\234\250\351\241\271\347\233\256\344\270\255\344\275\277\347\224\250nodejs.html" . unix) (u . "/2014/08/%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8nodejs.html") (u . "2014-08-02T00:00:00") (? . 3) (? . 15) () (u . "\n<p>最近玩起了nodejs，准备用nodejs+cpp一起来写一套服务器，应对当前的需求；多进程的框架，进程间通信使用tcp socket。</p>\n\n<p>先来分享一段自己写的log相关的代码 <a href=\"https://gist.github.com/zhuzhonghua/d2367390a8134578db41\">https://gist.github.com/d2367390a8134578db41.git</a></p>\n\n<p>在应用中如下使用</p>\n\n<blockquote>\n <p>LOG(&ldquo;recv a message &rdquo;+123);</p></blockquote>\n\n<blockquote>\n <p>ERROR(&ldquo;error! wrong option&rdquo;);</p></blockquote>\n\n<blockquote>\n <p>CRASH(&ldquo;exception &rdquo;)</p></blockquote>\n\n<p>如果需要其他类型的日志，只需要照着模板再写一套即可，比如INFO什么的。</p>\n\n<blockquote>\n <ol>\n  <li>其中使用了fs.appendFile来写文件。</li>\n  <li>文件名需要添加日期后缀，这样避免一个文件过大，导致阅读不方便。</li>\n  <li>每一行日志前都有一段时间标签，方便以后查日志。</li>\n  <li>在调用LOG时，根据队列的长度，来确定是否触发appendFile事件，以及什么时候再次触发。这样能保证单个文件，同时只有一个写操作。</li></ol></blockquote>\n\n<blockquote>\n <blockquote>\n  <p>4.1 如果LOG之后，发现队列长度只有1，那么说明这是第一条或者当前唯一的一条日志，那么应该触发appenFile。 4.2 如果在还没写完的情况下，多次调用LOG，那么队列长度肯定要大于1。appendFile事件肯定已经在4.1的情况下触发了，只需要在appendFile完成之后，再次触发appendFile就可以继续写当前缓存的日志。这是通过process.nextTick来实现的。本次的LOG操作就不用再触发appendFile了。</p></blockquote></blockquote>\n\n<p>针对这种nodej这种单线程异步事件操作，在很多需要IO的地方都可以用这种思路，比如写Socket操作这种。</p>\n\n<p>前面分享的代码有很多是冗余的，因为也简单够用，所以也没整理。</p>\n\n<p>轻拍砖。</p>") #f (u . "\n<p>最近玩起了nodejs，准备用nodejs+cpp一起来写一套服务器，应对当前的需求；多进程的框架，进程间通信使用tcp socket。</p>\n\n<p>先来分享一段自己写的log相关的代码 <a href=\"https://gist.github.com/zhuzhonghua/d2367390a8134578db41\">https://gist.github.com/d2367390a8134578db41.git</a></p>\n\n<p>在应用中如下使用</p>\n\n<blockquote>\n <p>LOG(&ldquo;recv a message &rdquo;+123);</p></blockquote>\n\n<blockquote>\n <p>ERROR(&ldquo;error! wrong option&rdquo;);</p></blockquote>\n\n<blockquote>\n <p>CRASH(&ldquo;exception &rdquo;)</p></blockquote>\n\n<p>如果需要其他类型的日志，只需要照着模板再写一套即可，比如INFO什么的。</p>\n\n<blockquote>\n <ol>\n  <li>其中使用了fs.appendFile来写文件。</li>\n  <li>文件名需要添加日期后缀，这样避免一个文件过大，导致阅读不方便。</li>\n  <li>每一行日志前都有一段时间标签，方便以后查日志。</li>\n  <li>在调用LOG时，根据队列的长度，来确定是否触发appendFile事件，以及什么时候再次触发。这样能保证单个文件，同时只有一个写操作。</li></ol></blockquote>\n\n<blockquote>\n <blockquote>\n  <p>4.1 如果LOG之后，发现队列长度只有1，那么说明这是第一条或者当前唯一的一条日志，那么应该触发appenFile。 4.2 如果在还没写完的情况下，多次调用LOG，那么队列长度肯定要大于1。appendFile事件肯定已经在4.1的情况下触发了，只需要在appendFile完成之后，再次触发appendFile就可以继续写当前缓存的日志。这是通过process.nextTick来实现的。本次的LOG操作就不用再触发appendFile了。</p></blockquote></blockquote>\n\n<p>针对这种nodej这种单线程异步事件操作，在很多需要IO的地方都可以用这种思路，比如写Socket操作这种。</p>\n\n<p>前面分享的代码有很多是冗余的，因为也简单够用，所以也没整理。</p>\n\n<p>轻拍砖。</p>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2014-12-26-tamarin-execute-routine.md" . unix) f post (u . "Tamarin的执行流程") (? . 13) 1505575228 (p+ #"/Users/zhonghua/demo/zhonghua_com/2014/12/tamarin\347\232\204\346\211\247\350\241\214\346\265\201\347\250\213.html" . unix) (u . "/2014/12/tamarin%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.html") (u . "2014-12-26T00:00:00") (? . 16) (? . 12) (c (u . "SWF")) (u . "\n<div class=\"figure\"><img src=\"/assets/tamarin_routine.png\" alt=\"tamarin_routine\" />\n <p class=\"caption\">tamarin_routine</p></div>") #f (u . "\n<div class=\"figure\"><img src=\"/assets/tamarin_routine.png\" alt=\"tamarin_routine\" />\n <p class=\"caption\">tamarin_routine</p></div>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2013-10-31-html5test-project.md" . unix) f post (u . "Html5Test Project") (? . 9) 1505574768 (p+ #"/Users/zhonghua/demo/zhonghua_com/2013/10/html5test-project.html" . unix) (u . "/2013/10/html5test-project.html") (u . "2013-10-31T00:00:00") (? . 10) (? . 4) () (u . "\n<p>前段时间想做html5游戏相关的工作，但是发现没有很好的可视化编辑器。</p>\n\n<p>于是自己做了一个工具，使用flash cs设计界面，做一个工具导出html5代码和资源。</p>\n\n<p>以后准备把相关的测试都放在这里做个演示。</p>\n\n<p><a href=\"https://github.com/zhuzhonghua/XUI\">https://github.com/zhuzhonghua/XUI</a></p>\n\n<p>根据完成度，来决定是否把这个导出资源和代码的工具开源。</p>") #f (u . "\n<p>前段时间想做html5游戏相关的工作，但是发现没有很好的可视化编辑器。</p>\n\n<p>于是自己做了一个工具，使用flash cs设计界面，做一个工具导出html5代码和资源。</p>\n\n<p>以后准备把相关的测试都放在这里做个演示。</p>\n\n<p><a href=\"https://github.com/zhuzhonghua/XUI\">https://github.com/zhuzhonghua/XUI</a></p>\n\n<p>根据完成度，来决定是否把这个导出资源和代码的工具开源。</p>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2012-12-21-swf-spec-9-shape.md" . unix) f post (u . "SWF9文件格式-形状(SWF File Format Version9 - Shape)") (? . 22) 1505573649 (p+ #"/Users/zhonghua/demo/zhonghua_com/2012/12/swf9\346\226\207\344\273\266\346\240\274\345\274\217-\345\275\242\347\212\266-swf-file-format-version9-shape.html" . unix) (u . "/2012/12/swf9%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-%E5%BD%A2%E7%8A%B6-swf-file-format-version9-shape.html") (u . "2012-12-21T00:00:00") (? . 11) (? . 23) (c (u . "SWF")) (u . "\n<p>Shape结构很紧凑，也很灵活。FP渲染起来效率很高。 和大多数的矢量格式一样，在Shape中定义的矢量也是由路径，也就是一组边，定义的。 路径可以是闭合的，也可以是开放的。路径中有直线，曲线，还有一些移动的指令。 指令可以使得，使用一个Shape结构定义好几个不相关的形状。</p>\n\n<p>填充样式会影响由路径包围的区域的外观。SWF文件中的填充样式里包含颜色，渐变，还有位图图像。</p>\n\n<p>线段样式会影响路径轮廓的外观。线段样式是关于笔画的粗细和颜色的。</p>\n\n<p>大多数的矢量格式只允许一个路径中只能包含一种填充和线段样式。而SWF扩展了这个限制，允许每条边都有自己的填充和线段样式。但是如果填充样式在路径中间变化，那么结果是不可知的。</p>\n\n<p>Adobe Flash创作工具还支持每条边有两个样式，内边和外边，FillStyle0和FillStyle1。FillStyle0永远都是先应用，然后根据需要，决定是否应用FillStyle1。</p>\n\n<h1 id=\"shape-简介\">Shape 简介</h1>\n\n<p>一个Shape由如下几种元素组成：</p>\n\n<ul>\n <li>CharacterId－16位的数字，在字典里作为唯一标识。CharacterID可以在控制标签中使用，如在PlaceObject里。这样可以重用并且也可以和其他元素组合为更复杂的元素。\n  <br /></li>\n <li>Bounding Box-包围Shape的矩形\n  <br /></li>\n <li>Fill Style Array-在Shape中使用的填充样式的列表\n  <br /></li>\n <li>Line Style Array-在Shape中使用的线段样式的列表\n  <br /></li>\n <li>Shape Record Array-Shape Record的列表。Shape Record可以是直边，曲边，可以改变样式，移动当前点位置</li></ul>\n\n<h1 id=\"shape举例\">Shape举例</h1>\n\n<p>下面的例子是一组Shape，但是可以由仅仅一个DefineShape标签定义。</p>\n\n<p><img src=\"/assets/shapeexample.png\" alt=\"ShapeExample\" /></p>\n\n<p>红圈，红方块还有绿色的圆边矩形都是闭合路径。曲线是一个开放路径。 红方块是由直线组成，红圈是由曲线组成，圆边矩形由曲线交叉直线组成。</p>\n\n<p>这里有两种填充样式，solid 红和solid 绿，两种线段样式，1像素黑和2像素黑。 红圈和红方块的线段样式和填充样式都一样。 圆边矩形和曲线有相同的线段样式。</p>\n\n<p>下面就是如何在SWF里描述这个例子：</p>\n\n<h3 id=\"定义填充样式\">定义填充样式</h3>\n\n<ol>\n <li>首先填充样式由FILLSTYLEARRAY定义，solid 红和solid 绿。</li>\n <li>接下来是LINESTYLEARRAY，包含了1像素黑和2像素黑。</li>\n <li>接下来是一组Shape Record。</li></ol>\n\n<p>所有的Shape Record结构相似，但是意义不同。Shape Record可以定义直边，曲边，样式改变和移动当前点。</p>\n\n<h3 id=\"定义曲线\">定义曲线</h3>\n\n<ol>\n <li>第一个Shape Record使用2像素宽的线段样式，然后设置StateMoveTo标签，把当前点移动到曲线的顶部。\n  <br /></li>\n <li>接下来的Shape Record是一个曲边，在线段底部结束。路径没有闭合。</li></ol>\n\n<h3 id=\"定义红方块\">定义红方块</h3>\n\n<ol>\n <li>接下来的Shape Record使用1像素的线段样式，红色填充样式。然后把当前点移动到红方块的左上角。\n  <br /></li>\n <li>下面的四个Shape Record都是直边。最后一个边必须在左上角结束。FP要求闭合图形必须互相衔接。也就是说第一个和最后一个点必须重合。</li></ol>\n\n<h3 id=\"定义红圈\">定义红圈</h3>\n\n<ol>\n <li>下一个Shape Record并不改变任何样式设定，但是会把当前点移动到红圈顶部。\n  <br /></li>\n <li>接下来的8个Shape Record都是曲边。并且最后要停在开始点。</li></ol>\n\n<h3 id=\"定义绿色圆边矩形\">定义绿色圆边矩形</h3>\n\n<ol>\n <li>接下来的ShapeRecord使用2像素宽的线段样式，绿色填充样式。然后把当前点移动到绿矩形的左上角。</li>\n <li>接下来的12个ShapeRecord是由StraightShapeRecord和CurvedShapeRecord交叉组成。路径在开始的地方结束。</li></ol>\n\n<h1 id=\"shape结构\">Shape结构</h1>\n\n<h2 id=\"填充样式\">填充样式</h2>\n\n<p>SWF支持3种非常基础的填充样式。</p>\n\n<ul>\n <li>单色填充 简单的RGB或者RGBA颜色填充Shape的一部分，Alpha255意味着完全不透明填充。Alpha0意味着完全透明填充。在这之间的数值意味着部分透明。\n  <br /></li>\n <li>渐进填充 渐进填充可以是线性渐进填充或者放射渐进填充。详细内容参考，Gradients一章。\n  <br /></li>\n <li>位图填充 位图填充使用了一个位图ID。有两种类型：裁减的，平铺的。如果填充区域超过了位图边界，裁减位图填充就重复使用位图边缘的颜色。而平铺填充会重复使用该位图。</li></ul>\n\n<h2 id=\"fillstylearray\">FILLSTYLEARRAY</h2>\n\n<p>填充样式数组枚举了一组填充样式。填充样式数组的格式如下：</p>\n\n<div class=\"figure\"><img src=\"/assets/fillstylearray.png\" alt=\"FILLSTYLEARRAY\" />\n <p class=\"caption\">FILLSTYLEARRAY</p></div>\n\n<h2 id=\"fillstyle\">FILLSTYLE</h2>\n\n<p>填充样式的格式如下：</p>\n\n<div class=\"figure\"><img src=\"/assets/fillstyle1.png\" alt=\"Fillstyle\" />\n <p class=\"caption\">Fillstyle</p></div>\n\n<div class=\"figure\"><img src=\"/assets/fillstyle2.png\" alt=\"Fillstyle\" />\n <p class=\"caption\">Fillstyle</p></div>\n\n<h2 id=\"线段样式\">线段样式</h2>\n\n<p>线段样式数组枚举了一组线段样式。</p>\n\n<h2 id=\"linestylearray\">LINESTYLEARRAY</h2>\n\n<p><img src=\"/assets/linestylearray.png\" alt=\"LineStyleArray\" /></p>\n\n<h2 id=\"linestyle\">LINESTYLE</h2>\n\n<p>线段样式表示的是线段的颜色和宽度。</p>\n\n<p><img src=\"/assets/linestyle.png\" alt=\"LineStyle\" /></p>\n\n<h2 id=\"linestyle2\">LINESTYLE2</h2>\n\n<p>LINESTYLE2建立在与LINESTYLE兼容的基础上，允许使用新类型的join和cap，还可以缩放，填充笔画。LINESTYLE2只能用于DefineShape4。</p>\n\n<p>LINESTYLE只允许圆连接和圆cap，LINESTYLE2允许miter join和bevel join，square cap和no cap。下面描述了完整的join和cap：</p>\n\n<p><img src=\"/assets/linestyle2joincap.png\" alt=\"LineStyle2JoinCap\" /></p>\n\n<p>在miter join中使用LINESTYLE2时，必须指定MiterLimitFactor，用来计算最大miter长度。</p>\n\n<p>最大miter长度 ＝ LINESTYLE2 MiterLimitFactor X LINESTYLE2 Width</p>\n\n<p>如果miter join超过了最大miter长度，FP会剪断。MiterLimitFactor的值是8.8格式。</p>\n\n<p>LINESTYLE2还包含一些选项来做像素微调，来校正垂直或者水平线段。</p>\n\n<p><img src=\"/assets/linestyle21.png\" alt=\"LineStyle2\" />\n <br /><img src=\"/assets/linestyle22.png\" alt=\"lineStyle2\" />\n <br /><img src=\"/assets/linestyle23.png\" alt=\"LineStyle2\" /></p>\n\n<h2 id=\"shape结构\">Shape结构</h2>\n\n<p>SHAPE结构中没有填充样式和线段样式。</p>\n\n<h2 id=\"shape\">SHAPE</h2>\n\n<p>SHAPE结构在DefineFont中使用，用来定义字型。</p>\n\n<p><img src=\"/assets/shape.png\" alt=\"SHPAE\" /></p>\n\n<h2 id=\"shapewithstyle\">SHAPEWITHSTYLE</h2>\n\n<p>SHAPEWITHSTYLE扩展了SHAPE结构，包含了填充样式和线段样式。在DefineShape中使用。</p>\n\n<p><img src=\"/assets/shapewithstyle.png\" alt=\"SHAPEWITHSTYLE\" /></p>\n\n<p>下面的图描述了SHAPEWITHSTYLE的结构：</p>\n\n<p><img src=\"/assets/shapewithstylediagram.png\" alt=\"SHAPEWITHSTYLEDIAGRAM\" /></p>\n\n<p>首先定义填充样式数组和线段样式数组，只定义一次，后面可以引用。</p>\n\n<p>蓝色区域代表SHAPERECORD数组。 第一个SHAPERECORD从填充样式数组中选择一个，然后把当前点移动到SHAPE的开始。 之后是一组边来定义SHAPE。下一个SHAPERECORD重新选择了一个填充样式，并且之后的边都采用新的样式。</p>\n\n<p>此标签完全是“自治”标签，所有引用的样式都是在本标签内定义的。</p>\n\n<h2 id=\"shape-records\">Shape Records</h2>\n\n<p>有四种类型的SHAPERECORD：</p>\n\n<ol>\n <li>End Shape Record</li>\n <li>Style Change Record\n  <br /></li>\n <li>Straight Edge Record\n  <br /></li>\n <li>Curved Edge Record</li></ol>\n\n<p>在一组SHAPERECORD内，每一个独立的SHAPERECORD都是字节对齐的。 在下一个SHAPERECORD开始之前，前一个SHAPERECORD都是先对齐到字节。</p>\n\n<p>每一个SHAPERECORD都是由一个TYPEFLAG开始的。 如果TYPEFLAG的值是0，那么此SHAPERECORD就是“非edge”的，之后的5位提供具体信息。</p>\n\n<h2 id=\"end-shape-record\">End Shape Record</h2>\n\n<p>End Shape Record简单的表明ShapeRecord数组结束，它的TypeFlag为0，并且之后的5位也是0。</p>\n\n<p><img src=\"/assets/endshaperecord.png\" alt=\"EndShpeRecord\" /></p>\n\n<h2 id=\"style-change-record\">Style Change Record</h2>\n\n<p>Style Change Record也是一个“非edge”Record，它可以做如下几件事情：</p>\n\n<ol>\n <li>选择填充样式或线段样式。\n  <br /></li>\n <li>移动当前点。\n  <br /></li>\n <li>修改当前的填充样式和线段样式。</li></ol>\n\n<p>因为改变样式都发生在一条路径的最开始部分，因此在单个record内进行多个操作是比较有用的。 例如，假想一下DefineShape标签定义了一个红圈和蓝方块。在红圈闭合之后，需要移动当前点，改变当前样式。 Style Change Record可以在一个Record里做到这些动作。</p>\n\n<p><img src=\"/assets/stylechangerecord1.png\" alt=\"StyleChangeRecord\" />\n <br /><img src=\"/assets/stylechangerecord2.png\" alt=\"StyleChangeRecord\" />\n <br /><img src=\"/assets/stylechangerecord3.png\" alt=\"StyleChangeRecord\" /></p>\n\n<p>在第一个shape record中，movedeltax 和movedeltay是和shape的起始处相关的。\n <br />在之后的shape record中，movedeltax 和movedeltay是和当前点相关的。</p>\n\n<p>样式数组从下标1开始，而不是从0开始。FillStyle＝1引用的是填充样式数组的第一个样式，FillStyle＝2引用的是第二个。 等等。填充样式的下标0表示没有填充，线段样式的下标0表示没有笔画。 最开始，填充样式和线段样式的下标都是0。</p>\n\n<h2 id=\"fillstyle0和fillstyle1\">FillStyle0和FillStyle1</h2>\n\n<p>Flash创作工具支持每条边2个样式：FillStyle0和FillStyle1。 对于不重叠不交叉的Shape，应该使用FillStyle0。 对于重叠的Shape，情况比较复杂。</p>\n\n<p>例如，如果一个Shape由两个重叠方块组成，并且只定义了FillStyle0，FP会在重叠的地方渲染一个洞。 这个区域可以使用FillStyle1。在这种情况下，对于任何方向向量，Fillstyle0是左边的颜色，FillStyle1是右边的颜色。</p>\n\n<p><img src=\"/assets/fillstyle01.png\" alt=\"FillStyle01\" /></p>\n\n<h2 id=\"edge-record\">Edge Record</h2>\n\n<p>Edge Record的TypeFlag是1。内含两种类型：直的，弯的，由StraightFlag标识。</p>\n\n<h2 id=\"straightedgerecord\">StraightEdgeRecord</h2>\n\n<p>StraightEdgeRecord存储的是XY增量。 把增量添加到当前的位置，构成了新位置。 在原来的点和现在的点之间画一条线。</p>\n\n<p>此Record支持三种类型的线：</p>\n\n<ol>\n <li>任意线\n  <br /></li>\n <li>水平线\n  <br /></li>\n <li>垂直线</li></ol>\n\n<p>任意线存储的是XY增量，其它两种线只存储一个轴的增量。</p>\n\n<div class=\"figure\"><img src=\"/assets/straightedgerecord.png\" alt=\"StraightEdgeRecord\" />\n <p class=\"caption\">StraightEdgeRecord</p></div>\n\n<h2 id=\"curvededgerecord\">CurvedEdgeRecord</h2>\n\n<p>SWF文件和大多数其他的类似文件格式最大的不同在于使用的是平方贝塞尔曲线，而不是立方贝塞尔曲线。 PostScript跟大多数的画图软件一样，使用的是立方贝塞尔曲线。 SWF文件之所以使用平方贝塞尔是因为可以更紧凑，更高效。</p>\n\n<p>下面的图展示了两种曲线：</p>\n\n<div class=\"figure\"><img src=\"/assets/quadraticcubicbeziercurves.png\" alt=\"QuadraticCubicBezierCurves\" />\n <p class=\"caption\">QuadraticCubicBezierCurves</p></div>\n\n<p>平方贝塞尔曲线有三个点：2个on-curve定位点，1个off-curve控制点。 立方贝塞尔曲线有四个点：2个on-curve定位点，2个off-curve控制点。</p>\n\n<p>curved-edge record存储了两个XY增量。三个点的计算方式如下：</p>\n\n<p>1 第一个定位点是当前的位置。\n <br />2 控制点是当前位置 plus Control增量。\n <br />3 另一个定位点是当前位置 plus Control增量 plus Anchor增量。</p>\n\n<p>最后一个定位点成为了新的当前点。</p>\n\n<div class=\"figure\"><img src=\"/assets/curveedgerecord.png\" alt=\"CurveEdgeRecord\" />\n <p class=\"caption\">CurveEdgeRecord</p></div>\n\n<h2 id=\"平方和立方贝塞尔曲线之间的转换\">平方和立方贝塞尔曲线之间的转换</h2>\n\n<p>把off-curve控制点用两个off-curve控制点替换。 两个off-curve控制点分别放在两个on-curve定位点和原来的off-curve控制点之间。 新的off-curve控制点在线段的2/3处，距离原来的off-curve控制点更近。可参见上图。</p>\n\n<p>平方贝塞尔曲线只能近似模拟立方贝塞尔曲线，因为一个是三阶曲线，一个是二阶曲线。 这个过程中会递归地分割曲线，直到两个类型的曲线误差可以接受。</p>\n\n<p>这里有一些讨论关于立方贝塞尔曲线由平方贝塞尔曲线模拟的：</p>\n\n<ul>\n <li>Converting Bezier Curves to Quadratic Splines at stevehollasch.com/cgindex/curves/cbez-quadspline.html</li>\n <li>TrueType Reference Manual, Converting Outlines to the TrueType Format at developer.apple.com/fonts/TTRefMan/RM08/appendixE.html</li></ul>\n\n<h2 id=\"shape-标签\">Shape 标签</h2>\n\n<h2 id=\"defineshape\">DefineShape</h2>\n\n<p>由DefineShape定义的Shape可以由后面的控制标签使用，如PlaceObject。 ShapeID作为唯一标识索引。 ShapeBounds是包含了Shape的矩形区域。 SHAPEWITHSTYLE包含了所有的路径，填充和线段样式。</p>\n\n<p>最低版本要求是SWF1。</p>\n\n<div class=\"figure\"><img src=\"/assets/defineshape.png\" alt=\"DefineShape\" />\n <p class=\"caption\">DefineShape</p></div>\n\n<h2 id=\"defineshape2\">DefineShape2</h2>\n\n<p>DefineShape2扩展了DefineShape，支持多余255种样式，一个Shape中有多个样式表。</p>\n\n<p>最低版本呢要求是SWF2。</p>\n\n<div class=\"figure\"><img src=\"/assets/defineshape2.png\" alt=\"DefineShape2\" />\n <p class=\"caption\">DefineShape2</p></div>\n\n<h2 id=\"defineshape3\">DefineShape3</h2>\n\n<p>DefineShape3扩展了DefineShape2，支持RGBA颜色。</p>\n\n<p>最低的版本要求是SWF3。</p>\n\n<div class=\"figure\"><img src=\"/assets/defineshape3.png\" alt=\"DefineShape3\" />\n <p class=\"caption\">DefineShape3</p></div>\n\n<h2 id=\"defineshape4\">DefineShape4</h2>\n\n<p>DefineShape4扩展了DefineShape3，使用了一个新的线段样式。 LINESTYLE2允许使用新类型的join和caps，还有缩放选项和填充一个笔画。</p>\n\n<p>DefineShape4除了指定Shape边界，还指定了边的边界。 就像Shape边界在笔画外围计算，边的边界是在边的外围计算，参看下图。 EdgeBounds字段辅助FP计算特定的布局。</p>\n\n<div class=\"figure\"><img src=\"/assets/edgebounds.png\" alt=\"EdgeBounds\" />\n <p class=\"caption\">EdgeBounds</p></div>\n\n<p>另外DefineShape4还添加了两个标记，UseNonScalingStrokes，UsesScalingStrokes。 这些标记可以帮助FP创建更好的重绘区域。</p>\n\n<p>最低版本要求SWF8。</p>\n\n<div class=\"figure\"><img src=\"/assets/defineshape4.png\" alt=\"DefineShape4\" />\n <p class=\"caption\">DefineShape4</p></div>") #f (u . "\n<p>Shape结构很紧凑，也很灵活。FP渲染起来效率很高。 和大多数的矢量格式一样，在Shape中定义的矢量也是由路径，也就是一组边，定义的。 路径可以是闭合的，也可以是开放的。路径中有直线，曲线，还有一些移动的指令。 指令可以使得，使用一个Shape结构定义好几个不相关的形状。</p>\n\n<p>填充样式会影响由路径包围的区域的外观。SWF文件中的填充样式里包含颜色，渐变，还有位图图像。</p>\n\n<p>线段样式会影响路径轮廓的外观。线段样式是关于笔画的粗细和颜色的。</p>\n\n<p>大多数的矢量格式只允许一个路径中只能包含一种填充和线段样式。而SWF扩展了这个限制，允许每条边都有自己的填充和线段样式。但是如果填充样式在路径中间变化，那么结果是不可知的。</p>\n\n<p>Adobe Flash创作工具还支持每条边有两个样式，内边和外边，FillStyle0和FillStyle1。FillStyle0永远都是先应用，然后根据需要，决定是否应用FillStyle1。</p>\n\n<h1 id=\"shape-简介\">Shape 简介</h1>\n\n<p>一个Shape由如下几种元素组成：</p>\n\n<ul>\n <li>CharacterId－16位的数字，在字典里作为唯一标识。CharacterID可以在控制标签中使用，如在PlaceObject里。这样可以重用并且也可以和其他元素组合为更复杂的元素。\n  <br /></li>\n <li>Bounding Box-包围Shape的矩形\n  <br /></li>\n <li>Fill Style Array-在Shape中使用的填充样式的列表\n  <br /></li>\n <li>Line Style Array-在Shape中使用的线段样式的列表\n  <br /></li>\n <li>Shape Record Array-Shape Record的列表。Shape Record可以是直边，曲边，可以改变样式，移动当前点位置</li></ul>\n\n<h1 id=\"shape举例\">Shape举例</h1>\n\n<p>下面的例子是一组Shape，但是可以由仅仅一个DefineShape标签定义。</p>\n\n<p><img src=\"/assets/shapeexample.png\" alt=\"ShapeExample\" /></p>\n\n<p>红圈，红方块还有绿色的圆边矩形都是闭合路径。曲线是一个开放路径。 红方块是由直线组成，红圈是由曲线组成，圆边矩形由曲线交叉直线组成。</p>\n\n<p>这里有两种填充样式，solid 红和solid 绿，两种线段样式，1像素黑和2像素黑。 红圈和红方块的线段样式和填充样式都一样。 圆边矩形和曲线有相同的线段样式。</p>\n\n<p>下面就是如何在SWF里描述这个例子：</p>\n\n<h3 id=\"定义填充样式\">定义填充样式</h3>\n\n<ol>\n <li>首先填充样式由FILLSTYLEARRAY定义，solid 红和solid 绿。</li>\n <li>接下来是LINESTYLEARRAY，包含了1像素黑和2像素黑。</li>\n <li>接下来是一组Shape Record。</li></ol>\n\n<p>所有的Shape Record结构相似，但是意义不同。Shape Record可以定义直边，曲边，样式改变和移动当前点。</p>\n\n<h3 id=\"定义曲线\">定义曲线</h3>\n\n<ol>\n <li>第一个Shape Record使用2像素宽的线段样式，然后设置StateMoveTo标签，把当前点移动到曲线的顶部。\n  <br /></li>\n <li>接下来的Shape Record是一个曲边，在线段底部结束。路径没有闭合。</li></ol>\n\n<h3 id=\"定义红方块\">定义红方块</h3>\n\n<ol>\n <li>接下来的Shape Record使用1像素的线段样式，红色填充样式。然后把当前点移动到红方块的左上角。\n  <br /></li>\n <li>下面的四个Shape Record都是直边。最后一个边必须在左上角结束。FP要求闭合图形必须互相衔接。也就是说第一个和最后一个点必须重合。</li></ol>\n\n<h3 id=\"定义红圈\">定义红圈</h3>\n\n<ol>\n <li>下一个Shape Record并不改变任何样式设定，但是会把当前点移动到红圈顶部。\n  <br /></li>\n <li>接下来的8个Shape Record都是曲边。并且最后要停在开始点。</li></ol>\n\n<h3 id=\"定义绿色圆边矩形\">定义绿色圆边矩形</h3>\n\n<ol>\n <li>接下来的ShapeRecord使用2像素宽的线段样式，绿色填充样式。然后把当前点移动到绿矩形的左上角。</li>\n <li>接下来的12个ShapeRecord是由StraightShapeRecord和CurvedShapeRecord交叉组成。路径在开始的地方结束。</li></ol>\n\n<h1 id=\"shape结构\">Shape结构</h1>\n\n<h2 id=\"填充样式\">填充样式</h2>\n\n<p>SWF支持3种非常基础的填充样式。</p>\n\n<ul>\n <li>单色填充 简单的RGB或者RGBA颜色填充Shape的一部分，Alpha255意味着完全不透明填充。Alpha0意味着完全透明填充。在这之间的数值意味着部分透明。\n  <br /></li>\n <li>渐进填充 渐进填充可以是线性渐进填充或者放射渐进填充。详细内容参考，Gradients一章。\n  <br /></li>\n <li>位图填充 位图填充使用了一个位图ID。有两种类型：裁减的，平铺的。如果填充区域超过了位图边界，裁减位图填充就重复使用位图边缘的颜色。而平铺填充会重复使用该位图。</li></ul>\n\n<h2 id=\"fillstylearray\">FILLSTYLEARRAY</h2>\n\n<p>填充样式数组枚举了一组填充样式。填充样式数组的格式如下：</p>\n\n<div class=\"figure\"><img src=\"/assets/fillstylearray.png\" alt=\"FILLSTYLEARRAY\" />\n <p class=\"caption\">FILLSTYLEARRAY</p></div>\n\n<h2 id=\"fillstyle\">FILLSTYLE</h2>\n\n<p>填充样式的格式如下：</p>\n\n<div class=\"figure\"><img src=\"/assets/fillstyle1.png\" alt=\"Fillstyle\" />\n <p class=\"caption\">Fillstyle</p></div>\n\n<div class=\"figure\"><img src=\"/assets/fillstyle2.png\" alt=\"Fillstyle\" />\n <p class=\"caption\">Fillstyle</p></div>\n\n<h2 id=\"线段样式\">线段样式</h2>\n\n<p>线段样式数组枚举了一组线段样式。</p>\n\n<h2 id=\"linestylearray\">LINESTYLEARRAY</h2>\n\n<p><img src=\"/assets/linestylearray.png\" alt=\"LineStyleArray\" /></p>\n\n<h2 id=\"linestyle\">LINESTYLE</h2>\n\n<p>线段样式表示的是线段的颜色和宽度。</p>\n\n<p><img src=\"/assets/linestyle.png\" alt=\"LineStyle\" /></p>\n\n<h2 id=\"linestyle2\">LINESTYLE2</h2>\n\n<p>LINESTYLE2建立在与LINESTYLE兼容的基础上，允许使用新类型的join和cap，还可以缩放，填充笔画。LINESTYLE2只能用于DefineShape4。</p>\n\n<p>LINESTYLE只允许圆连接和圆cap，LINESTYLE2允许miter join和bevel join，square cap和no cap。下面描述了完整的join和cap：</p>\n\n<p><img src=\"/assets/linestyle2joincap.png\" alt=\"LineStyle2JoinCap\" /></p>\n\n<p>在miter join中使用LINESTYLE2时，必须指定MiterLimitFactor，用来计算最大miter长度。</p>\n\n<p>最大miter长度 ＝ LINESTYLE2 MiterLimitFactor X LINESTYLE2 Width</p>\n\n<p>如果miter join超过了最大miter长度，FP会剪断。MiterLimitFactor的值是8.8格式。</p>\n\n<p>LINESTYLE2还包含一些选项来做像素微调，来校正垂直或者水平线段。</p>\n\n<p><img src=\"/assets/linestyle21.png\" alt=\"LineStyle2\" />\n <br /><img src=\"/assets/linestyle22.png\" alt=\"lineStyle2\" />\n <br /><img src=\"/assets/linestyle23.png\" alt=\"LineStyle2\" /></p>\n\n<h2 id=\"shape结构\">Shape结构</h2>\n\n<p>SHAPE结构中没有填充样式和线段样式。</p>\n\n<h2 id=\"shape\">SHAPE</h2>\n\n<p>SHAPE结构在DefineFont中使用，用来定义字型。</p>\n\n<p><img src=\"/assets/shape.png\" alt=\"SHPAE\" /></p>\n\n<h2 id=\"shapewithstyle\">SHAPEWITHSTYLE</h2>\n\n<p>SHAPEWITHSTYLE扩展了SHAPE结构，包含了填充样式和线段样式。在DefineShape中使用。</p>\n\n<p><img src=\"/assets/shapewithstyle.png\" alt=\"SHAPEWITHSTYLE\" /></p>\n\n<p>下面的图描述了SHAPEWITHSTYLE的结构：</p>\n\n<p><img src=\"/assets/shapewithstylediagram.png\" alt=\"SHAPEWITHSTYLEDIAGRAM\" /></p>\n\n<p>首先定义填充样式数组和线段样式数组，只定义一次，后面可以引用。</p>\n\n<p>蓝色区域代表SHAPERECORD数组。 第一个SHAPERECORD从填充样式数组中选择一个，然后把当前点移动到SHAPE的开始。 之后是一组边来定义SHAPE。下一个SHAPERECORD重新选择了一个填充样式，并且之后的边都采用新的样式。</p>\n\n<p>此标签完全是“自治”标签，所有引用的样式都是在本标签内定义的。</p>\n\n<h2 id=\"shape-records\">Shape Records</h2>\n\n<p>有四种类型的SHAPERECORD：</p>\n\n<ol>\n <li>End Shape Record</li>\n <li>Style Change Record\n  <br /></li>\n <li>Straight Edge Record\n  <br /></li>\n <li>Curved Edge Record</li></ol>\n\n<p>在一组SHAPERECORD内，每一个独立的SHAPERECORD都是字节对齐的。 在下一个SHAPERECORD开始之前，前一个SHAPERECORD都是先对齐到字节。</p>\n\n<p>每一个SHAPERECORD都是由一个TYPEFLAG开始的。 如果TYPEFLAG的值是0，那么此SHAPERECORD就是“非edge”的，之后的5位提供具体信息。</p>\n\n<h2 id=\"end-shape-record\">End Shape Record</h2>\n\n<p>End Shape Record简单的表明ShapeRecord数组结束，它的TypeFlag为0，并且之后的5位也是0。</p>\n\n<p><img src=\"/assets/endshaperecord.png\" alt=\"EndShpeRecord\" /></p>\n\n<h2 id=\"style-change-record\">Style Change Record</h2>\n\n<p>Style Change Record也是一个“非edge”Record，它可以做如下几件事情：</p>\n\n<ol>\n <li>选择填充样式或线段样式。\n  <br /></li>\n <li>移动当前点。\n  <br /></li>\n <li>修改当前的填充样式和线段样式。</li></ol>\n\n<p>因为改变样式都发生在一条路径的最开始部分，因此在单个record内进行多个操作是比较有用的。 例如，假想一下DefineShape标签定义了一个红圈和蓝方块。在红圈闭合之后，需要移动当前点，改变当前样式。 Style Change Record可以在一个Record里做到这些动作。</p>\n\n<p><img src=\"/assets/stylechangerecord1.png\" alt=\"StyleChangeRecord\" />\n <br /><img src=\"/assets/stylechangerecord2.png\" alt=\"StyleChangeRecord\" />\n <br /><img src=\"/assets/stylechangerecord3.png\" alt=\"StyleChangeRecord\" /></p>\n\n<p>在第一个shape record中，movedeltax 和movedeltay是和shape的起始处相关的。\n <br />在之后的shape record中，movedeltax 和movedeltay是和当前点相关的。</p>\n\n<p>样式数组从下标1开始，而不是从0开始。FillStyle＝1引用的是填充样式数组的第一个样式，FillStyle＝2引用的是第二个。 等等。填充样式的下标0表示没有填充，线段样式的下标0表示没有笔画。 最开始，填充样式和线段样式的下标都是0。</p>\n\n<h2 id=\"fillstyle0和fillstyle1\">FillStyle0和FillStyle1</h2>\n\n<p>Flash创作工具支持每条边2个样式：FillStyle0和FillStyle1。 对于不重叠不交叉的Shape，应该使用FillStyle0。 对于重叠的Shape，情况比较复杂。</p>\n\n<p>例如，如果一个Shape由两个重叠方块组成，并且只定义了FillStyle0，FP会在重叠的地方渲染一个洞。 这个区域可以使用FillStyle1。在这种情况下，对于任何方向向量，Fillstyle0是左边的颜色，FillStyle1是右边的颜色。</p>\n\n<p><img src=\"/assets/fillstyle01.png\" alt=\"FillStyle01\" /></p>\n\n<h2 id=\"edge-record\">Edge Record</h2>\n\n<p>Edge Record的TypeFlag是1。内含两种类型：直的，弯的，由StraightFlag标识。</p>\n\n<h2 id=\"straightedgerecord\">StraightEdgeRecord</h2>\n\n<p>StraightEdgeRecord存储的是XY增量。 把增量添加到当前的位置，构成了新位置。 在原来的点和现在的点之间画一条线。</p>\n\n<p>此Record支持三种类型的线：</p>\n\n<ol>\n <li>任意线\n  <br /></li>\n <li>水平线\n  <br /></li>\n <li>垂直线</li></ol>\n\n<p>任意线存储的是XY增量，其它两种线只存储一个轴的增量。</p>\n\n<div class=\"figure\"><img src=\"/assets/straightedgerecord.png\" alt=\"StraightEdgeRecord\" />\n <p class=\"caption\">StraightEdgeRecord</p></div>\n\n<h2 id=\"curvededgerecord\">CurvedEdgeRecord</h2>\n\n<p>SWF文件和大多数其他的类似文件格式最大的不同在于使用的是平方贝塞尔曲线，而不是立方贝塞尔曲线。 PostScript跟大多数的画图软件一样，使用的是立方贝塞尔曲线。 SWF文件之所以使用平方贝塞尔是因为可以更紧凑，更高效。</p>\n\n<p>下面的图展示了两种曲线：</p>\n\n<div class=\"figure\"><img src=\"/assets/quadraticcubicbeziercurves.png\" alt=\"QuadraticCubicBezierCurves\" />\n <p class=\"caption\">QuadraticCubicBezierCurves</p></div>\n\n<p>平方贝塞尔曲线有三个点：2个on-curve定位点，1个off-curve控制点。 立方贝塞尔曲线有四个点：2个on-curve定位点，2个off-curve控制点。</p>\n\n<p>curved-edge record存储了两个XY增量。三个点的计算方式如下：</p>\n\n<p>1 第一个定位点是当前的位置。\n <br />2 控制点是当前位置 plus Control增量。\n <br />3 另一个定位点是当前位置 plus Control增量 plus Anchor增量。</p>\n\n<p>最后一个定位点成为了新的当前点。</p>\n\n<div class=\"figure\"><img src=\"/assets/curveedgerecord.png\" alt=\"CurveEdgeRecord\" />\n <p class=\"caption\">CurveEdgeRecord</p></div>\n\n<h2 id=\"平方和立方贝塞尔曲线之间的转换\">平方和立方贝塞尔曲线之间的转换</h2>\n\n<p>把off-curve控制点用两个off-curve控制点替换。 两个off-curve控制点分别放在两个on-curve定位点和原来的off-curve控制点之间。 新的off-curve控制点在线段的2/3处，距离原来的off-curve控制点更近。可参见上图。</p>\n\n<p>平方贝塞尔曲线只能近似模拟立方贝塞尔曲线，因为一个是三阶曲线，一个是二阶曲线。 这个过程中会递归地分割曲线，直到两个类型的曲线误差可以接受。</p>\n\n<p>这里有一些讨论关于立方贝塞尔曲线由平方贝塞尔曲线模拟的：</p>\n\n<ul>\n <li>Converting Bezier Curves to Quadratic Splines at stevehollasch.com/cgindex/curves/cbez-quadspline.html</li>\n <li>TrueType Reference Manual, Converting Outlines to the TrueType Format at developer.apple.com/fonts/TTRefMan/RM08/appendixE.html</li></ul>\n\n<h2 id=\"shape-标签\">Shape 标签</h2>\n\n<h2 id=\"defineshape\">DefineShape</h2>\n\n<p>由DefineShape定义的Shape可以由后面的控制标签使用，如PlaceObject。 ShapeID作为唯一标识索引。 ShapeBounds是包含了Shape的矩形区域。 SHAPEWITHSTYLE包含了所有的路径，填充和线段样式。</p>\n\n<p>最低版本要求是SWF1。</p>\n\n<div class=\"figure\"><img src=\"/assets/defineshape.png\" alt=\"DefineShape\" />\n <p class=\"caption\">DefineShape</p></div>\n\n<h2 id=\"defineshape2\">DefineShape2</h2>\n\n<p>DefineShape2扩展了DefineShape，支持多余255种样式，一个Shape中有多个样式表。</p>\n\n<p>最低版本呢要求是SWF2。</p>\n\n<div class=\"figure\"><img src=\"/assets/defineshape2.png\" alt=\"DefineShape2\" />\n <p class=\"caption\">DefineShape2</p></div>\n\n<h2 id=\"defineshape3\">DefineShape3</h2>\n\n<p>DefineShape3扩展了DefineShape2，支持RGBA颜色。</p>\n\n<p>最低的版本要求是SWF3。</p>\n\n<div class=\"figure\"><img src=\"/assets/defineshape3.png\" alt=\"DefineShape3\" />\n <p class=\"caption\">DefineShape3</p></div>\n\n<h2 id=\"defineshape4\">DefineShape4</h2>\n\n<p>DefineShape4扩展了DefineShape3，使用了一个新的线段样式。 LINESTYLE2允许使用新类型的join和caps，还有缩放选项和填充一个笔画。</p>\n\n<p>DefineShape4除了指定Shape边界，还指定了边的边界。 就像Shape边界在笔画外围计算，边的边界是在边的外围计算，参看下图。 EdgeBounds字段辅助FP计算特定的布局。</p>\n\n<div class=\"figure\"><img src=\"/assets/edgebounds.png\" alt=\"EdgeBounds\" />\n <p class=\"caption\">EdgeBounds</p></div>\n\n<p>另外DefineShape4还添加了两个标记，UseNonScalingStrokes，UsesScalingStrokes。 这些标记可以帮助FP创建更好的重绘区域。</p>\n\n<p>最低版本要求SWF8。</p>\n\n<div class=\"figure\"><img src=\"/assets/defineshape4.png\" alt=\"DefineShape4\" />\n <p class=\"caption\">DefineShape4</p></div>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2015-11-20-gnashdefinebits-streamadapter.md" . unix) f post (u . "GNash的DefineBitsTag.cpp中的StreamAdapter类") (? . 12) 1505575480 (p+ #"/Users/zhonghua/demo/zhonghua_com/2015/11/gnash\347\232\204definebitstag-cpp\344\270\255\347\232\204streamadapter\347\261\273.html" . unix) (u . "/2015/11/gnash%E7%9A%84definebitstag-cpp%E4%B8%AD%E7%9A%84streamadapter%E7%B1%BB.html") (u . "2015-11-20T00:00:00") (? . 13) (? . 14) (c (u . "SWF")) (u . "\n<p>gnash/libcore/swf/DefineBitsTag.cpp 中定义了一个StreamAdapter类</p>\n\n<p>这个类最重要的一个方法是read，定义时会设置最大长度\n <br />读取的长度超过了最大长度，就截掉\n <br />在读取image data 时非常有用</p>\n\n<p>在使用libjpeg读image data时，并没有提供固定长度，而是提供了一个buffer，不知道终止位置在哪\n <br />通过StreamAdapter方法，避免读取越界，影响后续tag的读取，甚至宕机</p>\n\n<p>readDefineBitsJpeg2也就是tagtype=21时，通过StreamAdapter::getFile方法生成IOChannel，最大长度设置为tag的结束位置\n <br />调用Input::readImageData方法读取数据\n <br />根据type为JPEG类型，创建JpegInput\n <br />readScanline时，会调用在JpegInput的构造方法里通过rw_source_IOChannel::setup设置的fill_input_buffer方法</p>\n\n<p>在fill_input_buffer中，IO_BUF_SIZE指示了buffer大小</p>\n\n<p>于是读取jpeg数据时，就不会读越界，尤其当swf时compress模式时</p>") #f (u . "\n<p>gnash/libcore/swf/DefineBitsTag.cpp 中定义了一个StreamAdapter类</p>\n\n<p>这个类最重要的一个方法是read，定义时会设置最大长度\n <br />读取的长度超过了最大长度，就截掉\n <br />在读取image data 时非常有用</p>\n\n<p>在使用libjpeg读image data时，并没有提供固定长度，而是提供了一个buffer，不知道终止位置在哪\n <br />通过StreamAdapter方法，避免读取越界，影响后续tag的读取，甚至宕机</p>\n\n<p>readDefineBitsJpeg2也就是tagtype=21时，通过StreamAdapter::getFile方法生成IOChannel，最大长度设置为tag的结束位置\n <br />调用Input::readImageData方法读取数据\n <br />根据type为JPEG类型，创建JpegInput\n <br />readScanline时，会调用在JpegInput的构造方法里通过rw_source_IOChannel::setup设置的fill_input_buffer方法</p>\n\n<p>在fill_input_buffer中，IO_BUF_SIZE指示了buffer大小</p>\n\n<p>于是读取jpeg数据时，就不会读越界，尤其当swf时compress模式时</p>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2017-09-24-\344\275\277\347\224\250gimp\347\232\204python\350\204\232\346\234\254\350\207\252\345\212\250\346\213\206\350\247\243plist\345\233\276\347\211\207.md" . unix) f post (u . "使用gimp的python脚本自动拆解plist图片") (? . 14) 1506229623 (p+ #"/Users/zhonghua/demo/zhonghua_com/2017/09/\344\275\277\347\224\250gimp\347\232\204python\350\204\232\346\234\254\350\207\252\345\212\250\346\213\206\350\247\243plist\345\233\276\347\211\207.html" . unix) (u . "/2017/09/%E4%BD%BF%E7%94%A8gimp%E7%9A%84python%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A7%A3plist%E5%9B%BE%E7%89%87.html") (u . "2017-09-24T13:02:31") (? . 12) (? . 19) (c (u . "gimp") c (u . "python")) (u . "\n<p>需要用到的函数</p>\n\n<p>pdb.gimp_file_load 打开文件\n <br />pdb.gimp_image_crop 裁剪某一区域\n <br />pdb.gimp_image_duplicate 拷贝副本，在副本上操作，不影响原图，可以重复拷贝\n <br />pdb.gimp_file_save 保存操作的图像</p>\n\n<div class=\"brush: python\">\n <pre><code>\nfilename=\"somepngfile\"\nfilexml=\"someplistfile\"\noutpath=\"someoutputpath\"\n\nfrom gimpfu import * # 导入 gimp 里需要操作图像的库\nimport plistlib # 操作 plist文件\nimport re # 正则表达式\n\nnum = re.compile(r'\\d+') # 只要数字，width, height, offsetx, offsety，都是整型\n\nimage = pdb.gimp_file_load(filename, filename, run_mode=RUN_NONINTERACTIVE) # 加载原texture图像\n\npl = plistlib.readPlist(filexml) # 读取plist文件\nframes = pl['frames'] # 只需要frames里的字典\nprint \"key count \"+str(len(frames.keys())) \n\ncount = 0\nfor k in frames.keys():\n\tcount = count +1\n    try:\n\t\tv = frames[k] # k 是PNG名, v就是它对应的width,height,offsetx,offsety\n\t    outname = outpath+k\n\t\tframe = v['frame'] # 具体存储对应信息的字段\n\t\twhxy = num.findall(frame)\n\t\toffx = int(whxy[0])\n\t\toffy = int(whxy[1])\n\t\twidth = int(whxy[2])\n\t\theight = int(whxy[3])\n\t\tnew_img = pdb.gimp_image_duplicate(image) # 创建图像副本\n\t\tpdb.gimp_image_crop(new_img, width, height, offx, offy) # 裁剪副本里对应的区域\n\t\tdrawable=pdb.gimp_image_get_active_drawable(new_img) \n\t\tpdb.gimp_file_save(new_img, drawable, outname, outname) # 保存对应的文件\n\t\tprint str(count)+\" success \"+k\n\texcept Exception as e: # 不知道什么原因，有些文件会出错，加上异常保护，不影响后面其他的文件拆解\n\t\tprint str(count)+\" fail \"+k\n\t\tprint e\n  </code></pre></div>") #f (u . "\n<p>需要用到的函数</p>\n\n<p>pdb.gimp_file_load 打开文件\n <br />pdb.gimp_image_crop 裁剪某一区域\n <br />pdb.gimp_image_duplicate 拷贝副本，在副本上操作，不影响原图，可以重复拷贝\n <br />pdb.gimp_file_save 保存操作的图像</p>\n\n<div class=\"brush: python\">\n <pre><code>\nfilename=\"somepngfile\"\nfilexml=\"someplistfile\"\noutpath=\"someoutputpath\"\n\nfrom gimpfu import * # 导入 gimp 里需要操作图像的库\nimport plistlib # 操作 plist文件\nimport re # 正则表达式\n\nnum = re.compile(r'\\d+') # 只要数字，width, height, offsetx, offsety，都是整型\n\nimage = pdb.gimp_file_load(filename, filename, run_mode=RUN_NONINTERACTIVE) # 加载原texture图像\n\npl = plistlib.readPlist(filexml) # 读取plist文件\nframes = pl['frames'] # 只需要frames里的字典\nprint \"key count \"+str(len(frames.keys())) \n\ncount = 0\nfor k in frames.keys():\n\tcount = count +1\n    try:\n\t\tv = frames[k] # k 是PNG名, v就是它对应的width,height,offsetx,offsety\n\t    outname = outpath+k\n\t\tframe = v['frame'] # 具体存储对应信息的字段\n\t\twhxy = num.findall(frame)\n\t\toffx = int(whxy[0])\n\t\toffy = int(whxy[1])\n\t\twidth = int(whxy[2])\n\t\theight = int(whxy[3])\n\t\tnew_img = pdb.gimp_image_duplicate(image) # 创建图像副本\n\t\tpdb.gimp_image_crop(new_img, width, height, offx, offy) # 裁剪副本里对应的区域\n\t\tdrawable=pdb.gimp_image_get_active_drawable(new_img) \n\t\tpdb.gimp_file_save(new_img, drawable, outname, outname) # 保存对应的文件\n\t\tprint str(count)+\" success \"+k\n\texcept Exception as e: # 不知道什么原因，有些文件会出错，加上异常保护，不影响后面其他的文件拆解\n\t\tprint str(count)+\" fail \"+k\n\t\tprint e\n  </code></pre></div>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2014-08-19-nodejs-game-server.md" . unix) f post (u . "使用Nodejs开发网络游戏服务器") (? . 15) 1505574951 (p+ #"/Users/zhonghua/demo/zhonghua_com/2014/08/\344\275\277\347\224\250nodejs\345\274\200\345\217\221\347\275\221\347\273\234\346\270\270\346\210\217\346\234\215\345\212\241\345\231\250.html" . unix) (u . "/2014/08/%E4%BD%BF%E7%94%A8nodejs%E5%BC%80%E5%8F%91%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8.html") (u . "2014-08-19T00:00:00") (? . 8) (? . 16) () (u . "\n<p>Nodejs基于Google的V8引擎，用于开发后端。以前Js只是用于前端编程。从此之后，前端和后端就统一了，都使用js来开发，从此也模糊了前后端的划分。</p>\n\n<p>Nodejs天生的异步编程，也就天生满足异步Socket，所以非常适合做网络服务。</p>\n\n<p>写了一个基本的类库，简化游戏服务器开发中关于网络底层的开发</p>\n\n<p><a href=\"https://github.com/zhuzhonghua/Episode\">https://github.com/zhuzhonghua/Episode</a></p>") #f (u . "\n<p>Nodejs基于Google的V8引擎，用于开发后端。以前Js只是用于前端编程。从此之后，前端和后端就统一了，都使用js来开发，从此也模糊了前后端的划分。</p>\n\n<p>Nodejs天生的异步编程，也就天生满足异步Socket，所以非常适合做网络服务。</p>\n\n<p>写了一个基本的类库，简化游戏服务器开发中关于网络底层的开发</p>\n\n<p><a href=\"https://github.com/zhuzhonghua/Episode\">https://github.com/zhuzhonghua/Episode</a></p>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2014-12-17-parse-swf.md" . unix) f post (u . "解析swf文件格式") (? . 16) 1505575190 (p+ #"/Users/zhonghua/demo/zhonghua_com/2014/12/\350\247\243\346\236\220swf\346\226\207\344\273\266\346\240\274\345\274\217.html" . unix) (u . "/2014/12/%E8%A7%A3%E6%9E%90swf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.html") (u . "2014-12-17T00:00:00") (? . 15) (? . 13) (c (u . "SWF")) (u . "\n<p><a href=\"https://github.com/zhuzhonghua/utils/blob/master/parseSWF.py\">https://github.com/zhuzhonghua/utils/blob/master/parseSWF.py</a></p>\n\n<p>为了加深理解swf文件格式，使用python，参考swf spec 9，解析了其中的大部分tag</p>\n\n<p>还有一些tag没有完全解析对，后面研究到那部分时，再做修改</p>") #f (u . "\n<p><a href=\"https://github.com/zhuzhonghua/utils/blob/master/parseSWF.py\">https://github.com/zhuzhonghua/utils/blob/master/parseSWF.py</a></p>\n\n<p>为了加深理解swf文件格式，使用python，参考swf spec 9，解析了其中的大部分tag</p>\n\n<p>还有一些tag没有完全解析对，后面研究到那部分时，再做修改</p>")) ((? . 17) f post (u . "用Python生成Makefile") (? . 17) 1581867942 (p+ #"/Users/zhonghua/demo/zhonghua_com/2020/02/\347\224\250python\347\224\237\346\210\220makefile.html" . unix) (u . "/2020/02/%E7%94%A8python%E7%94%9F%E6%88%90makefile.html") (u . "2020-02-16T23:14:31") (? . 7) #f (c (u . "Python Makefile cmake automake xmake make")) (u . "\n<p>用Python生成Makefile，更灵活，更直接。</p>\n\n<pre><code>#python3\n\nimport sys\nimport os\nimport re\n\n#all src dirs\ndirs = [\".\", \"xxx\"]\ntemp_dir = \"temp\"\ntarget = \"yourtarget\"\ncpp_flags = os.popen(\"xxx shell command\").read().replace(\"\\n\",\"\")+\" -S -Wall -Wextra -Wpedantic -Dxxx -Ixx -ixxx\"\t\ncpp_libs = os.popen(\"shell command\").read().replace(\"\\n\",\"\")+\" -lxxx -Lxxx\"\n\n</code></pre>\n\n<p>dirs包含了目录列表，也可以更直接的递归获取所有目录，还可以添加别的非当前目录。</p>\n\n<p>temp_dir 临时文件的目录，主要是中间文件，xxx.o之类的。</p>\n\n<p>target 生成的目标</p>\n\n<p>cpp_flags和cpp_libs分别是编译期和链接期需要用到的，可以使用shell command结果作为参数。</p>\n\n<pre><code>############################\n#create tempdir\nif not os.path.exists(temp_dir):\n\tos.make_dirs(temp_dir)\n</code></pre>\n\n<p>创建临时目录</p>\n\n<pre><code>xxx_src = \"\"\"\nxxx/abc.c\nxxx/def.c\n\"\"\"\n\n#########################################\n#split line\ncpp_files = []\nfor one_dir in dirs:\n\tcpp_files = cpp_files + [one_dir+\"/\"+cpp for cpp in os.listdir(one_dir) if cpp.endswith('.cpp') or cpp.endswith('.c') or cpp.endswith('.cc')]\n\ncpp_files = cpp_files + xxx_src.split()</code></pre>\n\n<p>获取到所有的cpp文件列表，包括遍历得到文件和单独指定的文件</p>\n\n<pre><code>get_temp_o = lambda cpp:temp_dir+\"/\"+cpp.replace(\"./\",\"\").replace(\".cpp\",\".o\").replace(\".cc\",\".o\").replace(\".c\",\".o\").replace(\"/\",\".\")\n\t\nobjs = list(map(get_temp_o, cpp_files))</code></pre>\n\n<p>把“./”去掉，再把“.cpp”,“.cc”,“.c”等后缀换成“.o”，再把中间目录的“/”换成“.”，便于生成中间文件</p>\n\n<pre><code>phony = \"\"\"\n.PHONY: clean all\nall:$(TARGET)\n\"\"\".replace(\"$(TARGET)\", target)\n\nflags = \"\"\"\nCPPFLAGS := $(cpp_flags)\nCPPLIBS := $(cpp_libs)\n\n\"\"\".replace(\"$(cpp_flags)\", cpp_flags).replace(\"$(cpp_libs)\", cpp_libs)</code></pre>\n\n<p>字符串替换Makefile指令</p>\n\n<pre><code>def get_gen_temp_o(cpp):\n\tcmd = \"g++ -MM $(CPPFLAGS) \"+cpp\n\treturn os.popen(cmd.replace(\"$(CPPFLAGS)\", cpp_flags)).read()+\"\\tg++ -c $&lt; -o $@ $(CPPFLAGS)\\n\".replace(\"$(CPPFLAGS)\", cpp_flags)\n\t\ndef write_temp_o(make_file, cpp_files):\n\tfor cpp in cpp_files:\t\t\n\t\ttemp_o = get_temp_o(cpp)\t\t\n\t\tmake_file.write(re.sub(r'^.*\\.o\\s*:', temp_o+\":\", get_gen_temp_o(cpp)))\n\t\tmake_file.write(\"\\n\")\n\t\tprint(temp_o+\":\"+cpp)\n\n</code></pre>\n\n<p>get_gen_temp_o辅助函数获取cpp文件的依赖文件</p>\n\n<pre><code>target_cmd = \"\"\"\n$(TARGET):$(OBJS)\n\tg++ $(OBJS) -o $@ $(CPPLIBS)\n\"\"\".replace(\"$(TARGET)\", target).replace(\"$(OBJS)\", \" \".join(objs))\n\nclean_cmd = \"\"\"\nclean:\n\trm -f *.d; \\\n\trm -f *.o; \\\n\trm -f $(TARGET)\n\"\"\".replace(\"$(TARGET)\", target)\n\n</code></pre>\n\n<p>makefile指令生成目标和清理动作</p>\n\n<pre><code>with open(\"Makefile\", \"w\") as make_file:\n\tprint(\"start write makefile\")\n\tmake_file.write(phony)\n\tprint(phony)\n\tmake_file.write(flags)\n\tprint(flags)\n\twrite_temp_o(make_file, cpp_files)\n\tmake_file.write(target_cmd)\n\tprint(target_cmd)\n\tmake_file.write(clean_cmd)\n\tprint(clean_cmd)\n\tprint(\"end write makefile\")\n</code></pre>\n\n<p>最后把所有指令写入Makefile中</p>") #f (u . "\n<p>用Python生成Makefile，更灵活，更直接。</p>\n\n<pre><code>#python3\n\nimport sys\nimport os\nimport re\n\n#all src dirs\ndirs = [\".\", \"xxx\"]\ntemp_dir = \"temp\"\ntarget = \"yourtarget\"\ncpp_flags = os.popen(\"xxx shell command\").read().replace(\"\\n\",\"\")+\" -S -Wall -Wextra -Wpedantic -Dxxx -Ixx -ixxx\"\t\ncpp_libs = os.popen(\"shell command\").read().replace(\"\\n\",\"\")+\" -lxxx -Lxxx\"\n\n</code></pre>\n\n<p>dirs包含了目录列表，也可以更直接的递归获取所有目录，还可以添加别的非当前目录。</p>\n\n<p>temp_dir 临时文件的目录，主要是中间文件，xxx.o之类的。</p>\n\n<p>target 生成的目标</p>\n\n<p>cpp_flags和cpp_libs分别是编译期和链接期需要用到的，可以使用shell command结果作为参数。</p>\n\n<pre><code>############################\n#create tempdir\nif not os.path.exists(temp_dir):\n\tos.make_dirs(temp_dir)\n</code></pre>\n\n<p>创建临时目录</p>\n\n<pre><code>xxx_src = \"\"\"\nxxx/abc.c\nxxx/def.c\n\"\"\"\n\n#########################################\n#split line\ncpp_files = []\nfor one_dir in dirs:\n\tcpp_files = cpp_files + [one_dir+\"/\"+cpp for cpp in os.listdir(one_dir) if cpp.endswith('.cpp') or cpp.endswith('.c') or cpp.endswith('.cc')]\n\ncpp_files = cpp_files + xxx_src.split()</code></pre>\n\n<p>获取到所有的cpp文件列表，包括遍历得到文件和单独指定的文件</p>\n\n<pre><code>get_temp_o = lambda cpp:temp_dir+\"/\"+cpp.replace(\"./\",\"\").replace(\".cpp\",\".o\").replace(\".cc\",\".o\").replace(\".c\",\".o\").replace(\"/\",\".\")\n\t\nobjs = list(map(get_temp_o, cpp_files))</code></pre>\n\n<p>把“./”去掉，再把“.cpp”,“.cc”,“.c”等后缀换成“.o”，再把中间目录的“/”换成“.”，便于生成中间文件</p>\n\n<pre><code>phony = \"\"\"\n.PHONY: clean all\nall:$(TARGET)\n\"\"\".replace(\"$(TARGET)\", target)\n\nflags = \"\"\"\nCPPFLAGS := $(cpp_flags)\nCPPLIBS := $(cpp_libs)\n\n\"\"\".replace(\"$(cpp_flags)\", cpp_flags).replace(\"$(cpp_libs)\", cpp_libs)</code></pre>\n\n<p>字符串替换Makefile指令</p>\n\n<pre><code>def get_gen_temp_o(cpp):\n\tcmd = \"g++ -MM $(CPPFLAGS) \"+cpp\n\treturn os.popen(cmd.replace(\"$(CPPFLAGS)\", cpp_flags)).read()+\"\\tg++ -c $&lt; -o $@ $(CPPFLAGS)\\n\".replace(\"$(CPPFLAGS)\", cpp_flags)\n\t\ndef write_temp_o(make_file, cpp_files):\n\tfor cpp in cpp_files:\t\t\n\t\ttemp_o = get_temp_o(cpp)\t\t\n\t\tmake_file.write(re.sub(r'^.*\\.o\\s*:', temp_o+\":\", get_gen_temp_o(cpp)))\n\t\tmake_file.write(\"\\n\")\n\t\tprint(temp_o+\":\"+cpp)\n\n</code></pre>\n\n<p>get_gen_temp_o辅助函数获取cpp文件的依赖文件</p>\n\n<pre><code>target_cmd = \"\"\"\n$(TARGET):$(OBJS)\n\tg++ $(OBJS) -o $@ $(CPPLIBS)\n\"\"\".replace(\"$(TARGET)\", target).replace(\"$(OBJS)\", \" \".join(objs))\n\nclean_cmd = \"\"\"\nclean:\n\trm -f *.d; \\\n\trm -f *.o; \\\n\trm -f $(TARGET)\n\"\"\".replace(\"$(TARGET)\", target)\n\n</code></pre>\n\n<p>makefile指令生成目标和清理动作</p>\n\n<pre><code>with open(\"Makefile\", \"w\") as make_file:\n\tprint(\"start write makefile\")\n\tmake_file.write(phony)\n\tprint(phony)\n\tmake_file.write(flags)\n\tprint(flags)\n\twrite_temp_o(make_file, cpp_files)\n\tmake_file.write(target_cmd)\n\tprint(target_cmd)\n\tmake_file.write(clean_cmd)\n\tprint(clean_cmd)\n\tprint(\"end write makefile\")\n</code></pre>\n\n<p>最后把所有指令写入Makefile中</p>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2018-01-14-realm-of-racket-big-bang.md" . unix) f post (u . "Realm Of Racket - (big-bang)") (? . 18) 1519743314 (p+ #"/Users/zhonghua/demo/zhonghua_com/2018/01/realm-of-racket-big-bang.html" . unix) (u . "/2018/01/realm-of-racket-big-bang.html") (u . "2018-01-14T14:43:32") (? . 19) (? . 20) (c (u . "RealmOfRacket") c (u . "Lisp") c (u . "Racket")) (u . "\n<h1 id=\"big-bang\">(big-bang)</h1>\n\n<p>上一次的程序是命令行式的，这次写一些GUI(gooey)的程序\n <br />这次使用Racket里自带的2htdp/universe 2htdp/image</p>\n\n<pre><code>#lang racket\n(require 2htdp/universe 2htdp/image)\n\n(big-bang 0\n\t(on-tick add-3-to-state)\n\t(to-draw draw-a-ufo-onto-an-empty-scene))  \n\t</code></pre>\n\n<p>big-bang 创造了一个World, World是由状态和视图组成</p>\n\n<pre><code>(define (add-3-to-state current-state)\n\t(+ current-state 3))  \n\t</code></pre>\n\n<p>add&ndash;3-to-state 把当前状态+3，然后返回，big-bang会把add&ndash;3-to-state返回的值标记为下一个状态</p>\n\n<pre><code>(define (draw-a-ufo-onto-an-empty-scene current-state)\n\t(place-image IMAGE-of-UFO (/ WIDTH 2) current-state\n\t\t(empty-scene WIDTH HEIGHT)))  \n\t\t</code></pre>\n\n<p>draw-a-ufo-onto-an-empty-scene 把ufo的图片根据 current-state 绘制到特定位置\n <br />当图片落地时，动画得停下来</p>\n\n<pre><code>(define (state-is-300 current-state)\n\t(&gt;= current-state 300))\n\t\n(big-bang 0\n\t(on-tick add-3-to-state)\n\t(to-draw draw-a-ufo-onto-an-empty-scene)\n\t(stop-when state-is-300))\n\t</code></pre>\n\n<p>使用state-is&ndash;300和big-bang的stop-when来修改World的状态和视图</p>\n\n<pre><code>(big-bang state-expression\n\t(to-draw draw-function)\n\t(on-tick tick-function)\n\t(on-key key-function)\n\t(stop-when stop-function optional-last-scene))\n\t\n\t</code></pre>\n\n<p>big-bang大致长这样，state-expression是WOrld的初始状态，to-draw是把当前状态绘制到屏幕上，on-tick就是每tick调用的函数，on-key是当有输入操作，如键盘鼠标或者其他输入设备，调用的函数，在key-function里可以对状态进行修改，stop-when就是想让世界停下来的一个函数判断</p>\n\n<p>该示例的完整源码在 {Racket的安装目录}/share/pkgs/realm/chapter5/ufo-source.rkt里</p>\n\n<h1 id=\"写一个gui版本的猜数字游戏\">写一个GUI版本的猜数字游戏</h1>\n\n<p>好的数据结构会让程序有很大的不同</p>\n\n<pre><code>struct interval (small big))\n</code></pre>\n\n<p>代表猜数字的上下限</p>\n\n<pre><code>(define HELP-TEXT\n\t(text \" for larger numbers, for smaller ones\"\n\t\tTEXT-SIZE\n\t\t\"blue\"))\n(define HELP-TEXT2\n\t(text \"Press = when your number is guessed; q to quit.\"\n\t\tTEXT-SIZE\n\t\t\"blue\"))\n(define COLOR \"red\")\n</code></pre>\n\n<p>游戏指令</p>\n\n<pre><code>(define MT-SC\n\t(place-image/align\n\t\tHELP-TEXT TEXT-X TEXT-UPPER-Y \"left\" \"top\"\n\t\t(place-image/align\n\t\t\tHELP-TEXT2 TEXT-X TEXT-LOWER-Y \"left\" \"bottom\"\n\t\t\t(empty-scene WIDTH HEIGHT))))\n\t\t\t</code></pre>\n\n<p>定义常量，作为游戏的背景</p>\n\n<pre><code>(define (start lower upper)\n\t(big-bang (interval lower upper)\n\t\t(on-key deal-with-guess)\n\t\t(to-draw render)\n\t\t(stop-when single? render-last-scene)))\n\t\t</code></pre>\n\n<p>这个可以作为Main函数</p>\n\n<pre><code>(define (deal-with-guess w key)\n\t(cond [(key=? key \"up\") (bigger w)]\n\t\t[(key=? key \"down\") (smaller w)]\n\t\t[(key=? key \"q\") (stop-with w)]\n\t\t[(key=? key \"=\") (stop-with w)]\n\t\t[else w]))  \n\t\t</code></pre>\n\n<p>deal-with-guess 根据不同的key返回不同的状态</p>\n\n<pre><code>(define (smaller w)\n\t(interval (interval-small w)\n\t\t(max (interval-small w) (sub1 (guess w)))))  \n\t\t\n(define (bigger w)\n\t(interval (min (interval-big w) (add1 (guess w)))\n\t\t(interval-big w)))  \n\t\t</code></pre>\n\n<p>smaller和bigger都是创建了新的interval结构体</p>\n\n<pre><code>(define (guess w)\n\t(quotient (+ (interval-small w) (interval-big w)) 2))  \n\t</code></pre>\n\n<p>guess函数取结构的上下限，加起来然后/2</p>\n\n<pre><code>(define (render w)\n\t(overlay (text (number-&gt;string (guess w)) SIZE COLOR) MT-SC))  \n\t</code></pre>\n\n<p>render把猜的数字展示到MT-SC定义的背景上</p>\n\n<pre><code>(define (render-last-scene w)\n\t(overlay (text \"End\" SIZE COLOR) MT-SC))\n\t</code></pre>\n\n<p>当游戏结束调用的函数</p>\n\n<pre><code>(define (single? w)\n\t(= (interval-small w) (interval-big w)))  \n\t</code></pre>\n\n<p>single?比较上下限，决定是否结束游戏</p>\n\n<p>猜数字的GUI版本的完整代码在 {Racket的安装目录}/share/pkgs/realm/chapter5/source.rkt</p>") #f (u . "\n<h1 id=\"big-bang\">(big-bang)</h1>\n\n<p>上一次的程序是命令行式的，这次写一些GUI(gooey)的程序\n <br />这次使用Racket里自带的2htdp/universe 2htdp/image</p>\n\n<pre><code>#lang racket\n(require 2htdp/universe 2htdp/image)\n\n(big-bang 0\n\t(on-tick add-3-to-state)\n\t(to-draw draw-a-ufo-onto-an-empty-scene))  \n\t</code></pre>\n\n<p>big-bang 创造了一个World, World是由状态和视图组成</p>\n\n<pre><code>(define (add-3-to-state current-state)\n\t(+ current-state 3))  \n\t</code></pre>\n\n<p>add&ndash;3-to-state 把当前状态+3，然后返回，big-bang会把add&ndash;3-to-state返回的值标记为下一个状态</p>\n\n<pre><code>(define (draw-a-ufo-onto-an-empty-scene current-state)\n\t(place-image IMAGE-of-UFO (/ WIDTH 2) current-state\n\t\t(empty-scene WIDTH HEIGHT)))  \n\t\t</code></pre>\n\n<p>draw-a-ufo-onto-an-empty-scene 把ufo的图片根据 current-state 绘制到特定位置\n <br />当图片落地时，动画得停下来</p>\n\n<pre><code>(define (state-is-300 current-state)\n\t(&gt;= current-state 300))\n\t\n(big-bang 0\n\t(on-tick add-3-to-state)\n\t(to-draw draw-a-ufo-onto-an-empty-scene)\n\t(stop-when state-is-300))\n\t</code></pre>\n\n<p>使用state-is&ndash;300和big-bang的stop-when来修改World的状态和视图</p>\n\n<pre><code>(big-bang state-expression\n\t(to-draw draw-function)\n\t(on-tick tick-function)\n\t(on-key key-function)\n\t(stop-when stop-function optional-last-scene))\n\t\n\t</code></pre>\n\n<p>big-bang大致长这样，state-expression是WOrld的初始状态，to-draw是把当前状态绘制到屏幕上，on-tick就是每tick调用的函数，on-key是当有输入操作，如键盘鼠标或者其他输入设备，调用的函数，在key-function里可以对状态进行修改，stop-when就是想让世界停下来的一个函数判断</p>\n\n<p>该示例的完整源码在 {Racket的安装目录}/share/pkgs/realm/chapter5/ufo-source.rkt里</p>\n\n<h1 id=\"写一个gui版本的猜数字游戏\">写一个GUI版本的猜数字游戏</h1>\n\n<p>好的数据结构会让程序有很大的不同</p>\n\n<pre><code>struct interval (small big))\n</code></pre>\n\n<p>代表猜数字的上下限</p>\n\n<pre><code>(define HELP-TEXT\n\t(text \" for larger numbers, for smaller ones\"\n\t\tTEXT-SIZE\n\t\t\"blue\"))\n(define HELP-TEXT2\n\t(text \"Press = when your number is guessed; q to quit.\"\n\t\tTEXT-SIZE\n\t\t\"blue\"))\n(define COLOR \"red\")\n</code></pre>\n\n<p>游戏指令</p>\n\n<pre><code>(define MT-SC\n\t(place-image/align\n\t\tHELP-TEXT TEXT-X TEXT-UPPER-Y \"left\" \"top\"\n\t\t(place-image/align\n\t\t\tHELP-TEXT2 TEXT-X TEXT-LOWER-Y \"left\" \"bottom\"\n\t\t\t(empty-scene WIDTH HEIGHT))))\n\t\t\t</code></pre>\n\n<p>定义常量，作为游戏的背景</p>\n\n<pre><code>(define (start lower upper)\n\t(big-bang (interval lower upper)\n\t\t(on-key deal-with-guess)\n\t\t(to-draw render)\n\t\t(stop-when single? render-last-scene)))\n\t\t</code></pre>\n\n<p>这个可以作为Main函数</p>\n\n<pre><code>(define (deal-with-guess w key)\n\t(cond [(key=? key \"up\") (bigger w)]\n\t\t[(key=? key \"down\") (smaller w)]\n\t\t[(key=? key \"q\") (stop-with w)]\n\t\t[(key=? key \"=\") (stop-with w)]\n\t\t[else w]))  \n\t\t</code></pre>\n\n<p>deal-with-guess 根据不同的key返回不同的状态</p>\n\n<pre><code>(define (smaller w)\n\t(interval (interval-small w)\n\t\t(max (interval-small w) (sub1 (guess w)))))  \n\t\t\n(define (bigger w)\n\t(interval (min (interval-big w) (add1 (guess w)))\n\t\t(interval-big w)))  \n\t\t</code></pre>\n\n<p>smaller和bigger都是创建了新的interval结构体</p>\n\n<pre><code>(define (guess w)\n\t(quotient (+ (interval-small w) (interval-big w)) 2))  \n\t</code></pre>\n\n<p>guess函数取结构的上下限，加起来然后/2</p>\n\n<pre><code>(define (render w)\n\t(overlay (text (number-&gt;string (guess w)) SIZE COLOR) MT-SC))  \n\t</code></pre>\n\n<p>render把猜的数字展示到MT-SC定义的背景上</p>\n\n<pre><code>(define (render-last-scene w)\n\t(overlay (text \"End\" SIZE COLOR) MT-SC))\n\t</code></pre>\n\n<p>当游戏结束调用的函数</p>\n\n<pre><code>(define (single? w)\n\t(= (interval-small w) (interval-big w)))  \n\t</code></pre>\n\n<p>single?比较上下限，决定是否结束游戏</p>\n\n<p>猜数字的GUI版本的完整代码在 {Racket的安装目录}/share/pkgs/realm/chapter5/source.rkt</p>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2013-10-02-jsfl-js-error.md" . unix) f post (u . "在使用JSFL时出错的记录") (? . 10) 1505574678 (p+ #"/Users/zhonghua/demo/zhonghua_com/2013/07/\345\234\250\344\275\277\347\224\250jsfl\346\227\266\345\207\272\351\224\231\347\232\204\350\256\260\345\275\225.html" . unix) (u . "/2013/07/%E5%9C%A8%E4%BD%BF%E7%94%A8jsfl%E6%97%B6%E5%87%BA%E9%94%99%E7%9A%84%E8%AE%B0%E5%BD%95.html") (u . "2013-07-01T00:00:00") (? . 2) (? . 9) () (u . "\n<p>JSFL为何物，请自行Google</p>\n\n<p>JSFL文件中的函数名，不要和文件名相同。 要不然在执行时，会出现JS错误。 这个问题查了我好久才发现的。 而且Google了也没结果，所以在此记录。</p>") #f (u . "\n<p>JSFL为何物，请自行Google</p>\n\n<p>JSFL文件中的函数名，不要和文件名相同。 要不然在执行时，会出现JS错误。 这个问题查了我好久才发现的。 而且Google了也没结果，所以在此记录。</p>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2018-03-04-blockchain-python-demo.md" . unix) f post (u . "[译]Dumbcoin-基于教育目的的Python实现类比特币的区块链") (? . 6) 1520176719 (p+ #"/Users/zhonghua/demo/zhonghua_com/2018/03/-\350\257\221-dumbcoin-\345\237\272\344\272\216\346\225\231\350\202\262\347\233\256\347\232\204\347\232\204python\345\256\236\347\216\260\347\261\273\346\257\224\347\211\271\345\270\201\347\232\204\345\214\272\345\235\227\351\223\276.html" . unix) (u . "/2018/03/-%E8%AF%91-dumbcoin-%E5%9F%BA%E4%BA%8E%E6%95%99%E8%82%B2%E7%9B%AE%E7%9A%84%E7%9A%84python%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE.html") (u . "2018-03-04T17:49:42") (? . 20) (? . 5) (c (u . "Python") c (u . "Bitcoin") c (u . "比特币") c (u . "dumbcoin") c (u . "区块链")) (u . "\n<p>原文地址 https://github.com/julienr/ipynb_playground/blob/master/bitcoin/dumbcoin/dumbcoin.ipynb</p>\n\n<h1 id=\"简介\">简介</h1>\n\n<p>这是一本实验性质的手册，用Python实现了类比特币区块链的大多数概念。它并不安全，也不是真实的区块链，所以你不应该用它做任何其他事情，除了教育目的。</p>\n\n<p>不考虑比特币的金融利弊，它的底层技术很有趣，原始论文也很容易理解。</p>\n\n<p>或许你想要看看这本手册在<a href=\"https://news.ycombinator.com/item?id=15945490\">HackerNews</a>上的讨论。</p>\n\n<h1 id=\"引用\">引用</h1>\n\n<p>我使用了<a href=\"https://bitcoin.org/bitcoin.pdf\">比特币的最初论文</a>，还有<a href=\"http://www.michaelnielsen.org/ddi/how-the-bitcoin-protocol-actually-works/\">Michael Nielsen比特币的解释</a>。<a href=\"https://en.bitcoin.it/wiki/Main_Page\">比特币Wiki</a>是非常不错的技术资源。</p>\n\n<h1 id=\"内容\">内容</h1>\n\n<ol>\n <li>哈希函数和挖矿\n  <br /></li>\n <li>难度\n  <br /></li>\n <li>钱包\n  <br /></li>\n <li>交易\n  <br /></li>\n <li>区块\n  <br /></li>\n <li>攻击\n  <br /></li>\n <li>51%攻击\n  <br /></li>\n <li>与比特币的不同</li></ol>\n\n<p>需要用到的库</p>\n\n<pre><code>import hashlib\nimport random\nimport string\nimport json\nimport binascii\nimport numpy as np\nimport pandas as pd\nimport pylab as pl\nimport logging\n%matplotlib inline</code></pre>\n\n<h1 id=\"哈希函数和挖矿\">哈希函数和挖矿</h1>\n\n<p>我们先实现挖矿。这里我们使用SHA256哈希函数，因为SHA256的Python实现的很稳定。注意比特币使用了<a href=\"https://en.bitcoin.it/wiki/Hashcash\">2轮SHA256算法</a>，而不是1轮。</p>\n\n<p>我们的哈希函数会把任意长度的字符串转换成固定长度的64进制字符串。例如</p>\n\n<pre><code>def sha256(message):\n\treturn hashlib.sha256(message.encode('ascii')).hexdigest()</code></pre>\n\n<p>挖矿的流程是：任意长度字符串x，找这样一个数字nonce，满足hash(x+nonce)产生的哈希值以特定字符串开始。</p>\n\n<p>这里我们挖一个特定的数字nonce，信息 &ldquo;hello bitcoin&rdquo; 连接上nonce产生的哈希值有至少两个前缀数字。</p>\n\n<pre><code>message = 'hello bitcoin'\nfor nonce in range(1000):\n    digest = sha256(message + str(nonce))\n    if digest.startswith('11'):\n        print('Found nonce = %d' % nonce)\n        break\nprint(sha256(message + str(nonce)))\n\n\nFound nonce = 32\n112c38d2fdb6ddaf32f371a390307ccc779cd92443b42c4b5c58fa548f63ed83\n</code></pre>\n\n<p>要求的前缀数字越多，越难找到特定nonce。在比特币里，这叫做挖矿难度。注意比特币并不要求前缀数字，而是要求哈希值必须低于某个特定值。但是原理是相同的。</p>\n\n<p>定义两个函数，后面使用：一个函数做哈希运算，一个函数针对字符串挖矿nonce</p>\n\n<pre><code>def dumb_hash(message):\n\t\"\"\"\n    返回64进制字符串\n\t\"\"\"\n\treturn sha256(message)\n\t\t\t\n\t\t\t\ndef mine(message, difficulty=1):\n    \"\"\"\n\t输入给定字符串，找到nonce，满足hash(string+nonce)有特定难度的前缀\n\t\t\t\t    \n    Returns: (nonce, niters)\n\t\tnonce: The found nonce\n\t\tniters: The number of iterations required to find the nonce\n\t\"\"\"\n\tassert difficulty &gt;= 1, \"Difficulty of 0 is not possible\"\n\ti = 0\n\tprefix = '1' * difficulty\n\twhile True:\n\t\tnonce = str(i)\n\t\tdigest = dumb_hash(message + nonce)\n\t\tif digest.startswith(prefix):\n\t\t\treturn nonce, i\n\t\ti += 1\n\t\t\n\t\t</code></pre>\n\n<p>这样我们就可以在不同难度下挖矿了</p>\n\n<pre><code>nonce, niters = mine('42', difficulty=1)\nprint('Took %d iterations' % niters)\n\nnonce, niters = mine('42', difficulty=3)\nprint('Took %d iterations' % niters)\n\n\nTook 23 iterations\nTook 2272 iterations\n\n</code></pre>\n\n<p>例子中可以看到难度3的迭代次数要比难度1的迭代次数大很多。注意，运气好的话，第一个nonce（这里是0）就可以找到了。因此难度控制的是尝试的平均次数。基于此，我们可以做一个好看的图表。</p>\n\n<h1 id=\"难度表\">难度表</h1>\n\n<p>对于每个难度等级，我们会针对多个字符串挖矿nonce。我们记录下每个难度的平均尝试次数。</p>\n\n<pre><code>def random_string(length=10):\n\treturn ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(length))\n\nstrings = [random_string() for i in range(50)]\n\n\nlevels = range(1, 5)\n# An array of results with a row for each difficulty and a column for each test string\nresults = pd.DataFrame(index=strings, columns=levels, dtype=np.int)\nresults.fillna(value=0)\n\n#results = np.zeros((N_LEVELS, len(strings)), dtype=np.int)\nfor level in levels:\n    for s in strings:\n\t\t_, niters = mine(s, difficulty=level)\n\t\tresults[level][s] = niters\n\n\npl.figure(figsize=(10, 5))\nax = pl.subplot(111)\nax.set_title('Number of iterations to mine a nonce for various difficulty')\nresults.plot.box(showfliers=False, ax=ax)\nax.set_xlabel('Difficulty')\nax.set_ylabel('Iterations')\n\n</code></pre>\n\n<h1 id=\"钱包\">钱包</h1>\n\n<p>在比特币里钱包是公钥私钥对。公钥私钥对解释 <a href=\"https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29\">RSA</a>。</p>\n\n<p>公钥用于接受交易，私钥用于花钱。私钥签名交易，所有其他人都可以用公钥验证。</p>\n\n<p>在比特币里，钱包稍微复杂一点。钱包是多个公钥私钥对，钱包地址并不直接是公钥。这更好的保证隐私和安全，但是dumbcoin这里只用一个，公钥作为钱包地址。</p>\n\n<pre><code>import Crypto\nimport Crypto.Random\nfrom Crypto.Hash import SHA\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Signature import PKCS1_v1_5\n\n\nclass Wallet(object):\n    \"\"\"\n    钱包是公钥私钥对\n    \"\"\"\n    def __init__(self):\n        random_gen = Crypto.Random.new().read\n        self._private_key = RSA.generate(1024, random_gen)\n        self._public_key = self._private_key.publickey()\n        self._signer = PKCS1_v1_5.new(self._private_key)\n        \n    @property\n    def address(self):\n        \"\"\"我们简单起见，公钥就是地址\"\"\"\n        return binascii.hexlify(self._public_key.exportKey(format='DER')).decode('ascii')\n    \n    def sign(self, message):\n        \"\"\"\n        用这个钱包签名message\n        \"\"\"\n        h = SHA.new(message.encode('utf8'))\n        return binascii.hexlify(self._signer.sign(h)).decode('ascii')\n    \n    \ndef verify_signature(wallet_address, message, signature):\n    \"\"\"\n\t检查message的签名signature是否由wallet_address签名\n    \"\"\"\n    pubkey = RSA.importKey(binascii.unhexlify(wallet_address))\n    verifier = PKCS1_v1_5.new(pubkey)\n    h = SHA.new(message.encode('utf8'))\n    return verifier.verify(h, binascii.unhexlify(signature))\n\n\n# 测试一下\nw1 = Wallet()\nsignature = w1.sign('foobar')\nassert verify_signature(w1.address, 'foobar', signature)\nassert not verify_signature(w1.address, 'rogue message', signature)\n\n</code></pre>\n\n<h1 id=\"做交易\">做交易</h1>\n\n<p>在钱包之间交换钱，需要用到交易。交易是由下面3部分组成：</p>\n\n<ul>\n <li>消费者 Spender，他会给交易签名，花他自己的钱\n  <br /></li>\n <li>多个输入 input，是其他交易的输出。所有这些的接受者是消费者 Spender的钱包。\n  <br />要不然你就可以花其他人的钱了。\n  <br /></li>\n <li>多个输出 output，每个都指定了钱数和接受者。</li></ul>\n\n<p>交易会包含交易费，这样刺激挖矿者在区块中包含该交易。费用就是输入数量和输出数量之间的差异。</p>\n\n<p>所有交易需要一个父节点，在架构里需要一个根节点。我们起名 GenesisTransaction</p>\n\n<pre><code>class TransactionInput(object):\n    \"\"\"\n\t交易输入，指向另一个交易的输出\n    \"\"\"\n    def __init__(self, transaction, output_index):\n        self.transaction = transaction\n        self.output_index = output_index\n        assert 0 &lt;= self.output_index &lt; len(transaction.outputs)\n        \n    def to_dict(self):\n        d = {\n            'transaction': self.transaction.hash(),\n            'output_index': self.output_index\n        }\n        return d\n    \n    @property\n    def parent_output(self):\n        return self.transaction.outputs[self.output_index]\n    \n\nclass TransactionOutput(object):\n    \"\"\"\n\t交易输出，指定数量和接收者钱包\n    \"\"\"\n    def __init__(self, recipient_address, amount):\n        self.recipient = recipient_address\n        self.amount = amount\n        \n    def to_dict(self):\n        d = {\n            'recipient_address': self.recipient,\n            'amount': self.amount\n        }\n        return d\n\n        \ndef compute_fee(inputs, outputs):\n    \"\"\"\n\t通过总输入和总输出，计算交易费\n    \"\"\"\n    total_in = sum(i.transaction.outputs[i.output_index].amount for i in inputs)\n    total_out = sum(o.amount for o in outputs)\n    assert total_out &lt;= total_in, \"Invalid transaction with out(%f) &gt; in(%f)\" % (total_out, total_in)\n    return total_in - total_out\n\n    \nclass Transaction(object):\n    def __init__(self, wallet, inputs, outputs):\n        \"\"\"\n\t\t创建交易，从指定钱包花钱\n        \"\"\"\n        self.inputs = inputs\n        self.outputs = outputs\n        self.fee = compute_fee(inputs, outputs)\n        self.signature = wallet.sign(json.dumps(self.to_dict(include_signature=False)))\n        \n    def to_dict(self, include_signature=True):\n        d = {\n            \"inputs\": list(map(TransactionInput.to_dict, self.inputs)),\n            \"outputs\": list(map(TransactionOutput.to_dict, self.outputs)),\n            \"fee\": self.fee\n        }\n        if include_signature:\n            d[\"signature\"] = self.signature\n        return d\n    \n    def hash(self):\n        return dumb_hash(json.dumps(self.to_dict()))\n    \n    \nclass GenesisTransaction(Transaction):\n    \"\"\"\n\t第一笔交易是特定交易，没有输入，有25个比特币的输出\n    \"\"\"\n    def __init__(self, recipient_address, amount=25):\n        self.inputs = []\n        self.outputs = [\n            TransactionOutput(recipient_address, amount)\n        ]\n        self.fee = 0\n        self.signature = 'genesis'\n        \n    def to_dict(self, include_signature=False):\n        # TODO: Instead, should sign genesis transaction will well-known public key ?\n        assert not include_signature, \"Cannot include signature of genesis transaction\"\n        return super().to_dict(include_signature=False)</code></pre>\n\n<p>有了上面的类，我们可以在alice和bob之间做交易了</p>\n\n<pre><code>alice = Wallet()\nbob = Wallet()\n\nt1 = GenesisTransaction(alice.address)\nt2 = Transaction(\n    alice,\n    [TransactionInput(t1, 0)],\n    [TransactionOutput(bob.address, 2.0), TransactionOutput(alice.address, 22.0)]\n)\nassert np.abs(t2.fee - 1.0) &lt; 1e-5\n\n</code></pre>\n\n<p>在比特币里，并不会存储钱包的钱数。 会遍历交易链来计算你有多少。写一个函数来做这件事。</p>\n\n<pre><code>alice = Wallet()\nbob = Wallet()\nwalter = Wallet()\n\n# This gives 25 coins to Alice\nt1 = GenesisTransaction(alice.address)\n\n# Of those 25, Alice will spend\n# Alice -- 5 --&gt; Bob\n#       -- 15 --&gt; Alice\n#       -- 5 --&gt; Walter\nt2 = Transaction(\n    alice,\n    [TransactionInput(t1, 0)],\n    [TransactionOutput(bob.address, 5.0), TransactionOutput(alice.address, 15.0), TransactionOutput(walter.address, 5.0)]\n)\n\n# Walter -- 5 --&gt; Bob\nt3 = Transaction(\n    walter,\n    [TransactionInput(t2, 2)],\n    [TransactionOutput(bob.address, 5.0)])\n\n# Bob -- 8 --&gt; Walter\n#     -- 1 --&gt; Bob\n#        1 fee\nt4 = Transaction(\n    bob,\n    [TransactionInput(t2, 0), TransactionInput(t3, 0)],\n    [TransactionOutput(walter.address, 8.0), TransactionOutput(bob.address, 1.0)]\n)\n\ntransactions = [t1, t2, t3, t4]\n\n\ndef compute_balance(wallet_address, transactions):\n    \"\"\"\n\t给定地址和交易链，计算地址的钱包余额\n    \"\"\"\n    balance = 0\n    for t in transactions:\n        # Subtract all the money that the address sent out\n        for txin in t.inputs:\n            if txin.parent_output.recipient == wallet_address:\n                balance -= txin.parent_output.amount\n        # Add all the money received by the address\n        for txout in t.outputs:\n            if txout.recipient == wallet_address:\n                balance += txout.amount\n    return balance\n\nprint(\"Alice  has %.02f dumbcoins\" % compute_balance(alice.address, transactions))\nprint(\"Bob    has %.02f dumbcoins\" % compute_balance(bob.address, transactions))\nprint(\"Walter has %.02f dumbcoins\" % compute_balance(walter.address, transactions))\n\n\nAlice  has 15.00 dumbcoins\nBob    has 1.00 dumbcoins\nWalter has 8.00 dumbcoins</code></pre>\n\n<p>还需要确认交易是否有效，这意味着：</p>\n\n<ul>\n <li>你仅仅能花自己的钱。这意味着所有输入由交易的拥有者拥有。\n  <br /></li>\n <li>确保你花的钱不会比你有的多。这是有上面的compute_fee检查。</li></ul>\n\n<p>函数</p>\n\n<pre><code>def verify_transaction(transaction):\n    \"\"\"\n    确保交易是有效的\n    - 所有输入都属于相同的钱包\n    - 交易是由响应的钱包主人签名的\n    \"\"\"\n    tx_message = json.dumps(transaction.to_dict(include_signature=False))\n    if isinstance(transaction, GenesisTransaction):\n        # TODO: We should probably be more careful about validating genesis transactions\n        return True\n    \n    # Verify input transactions\n    for tx in transaction.inputs:\n        if not verify_transaction(tx.transaction):\n            logging.error(\"Invalid parent transaction\")\n            return False\n    \n    # Verify a single wallet owns all the inputs\n    first_input_address = transaction.inputs[0].parent_output.recipient\n    for txin in transaction.inputs[1:]:\n        if txin.parent_output.recipient != first_input_address:\n            logging.error(\n                \"Transaction inputs belong to multiple wallets (%s and %s)\" %\n                (txin.parent_output.recipient, first_input_address)\n            )\n            return False\n    \n    if not verify_signature(first_input_address, tx_message, transaction.signature):\n        logging.error(\"Invalid transaction signature, trying to spend someone else's money ?\")\n        return False\n    \n    # Call compute_fee here to trigger an assert if output sum is great than input sum. Without this,\n    # a miner could put such an invalid transaction.\n    compute_fee(transaction.inputs, transaction.outputs)\n    \n    return True\n\t\n\nt1 = GenesisTransaction(alice.address)\n# This is an invalid transaction because bob is trying to spend alice's money\n# (alice was the recipient of the input - t1)\nt2 = Transaction(\n    bob,\n    [TransactionInput(t1, 0)],\n    [TransactionOutput(walter.address, 10.0)]\n)\n# This is valid, alice is spending her own money\nt3 = Transaction(\n    alice,\n    [TransactionInput(t1, 0)],\n    [TransactionOutput(walter.address, 10.0)]\n)\n\nassert verify_transaction(t1)\nassert not verify_transaction(t2)\n\n\nERROR:root:Invalid transaction signature, trying to spend someone else's money ?\n\n\nassert verify_transaction(t3)\n</code></pre>\n\n<h1 id=\"把交易写入区块\">把交易写入区块</h1>\n\n<p>我们现在有</p>\n\n<ul>\n <li>定义钱包（公钥私钥对）\n  <br /></li>\n <li>在钱包之间创建交易\n  <br /></li>\n <li>验证交易（检查交易的签名）</li></ul>\n\n<p>剩下来需要把交易放入区块，让挖矿者挖矿区块。挖区块由两部分组成：</p>\n\n<ul>\n <li>验证区块中的交易\n  <br /></li>\n <li>找到一个nonce，区块的哈希以几个0开始</li></ul>\n\n<p>并且挖矿根据规则会生成钱，第一个区块GenesisTransaction会给25个币给任意地址。挖矿者会添加交易，把交易产生的费用传递给任意地址。</p>\n\n<pre><code>BLOCK_INCENTIVE = 25 # 挖矿区块得到的币数\nDIFFICULTY = 2\n\n\ndef compute_total_fee(transactions):\n    \"\"\"返回交易的总费用\"\"\"\n    return sum(t.fee for t in transactions)\n\n\nclass Block(object):\n    def __init__(self, transactions, ancestor, miner_address, skip_verif=False):\n        \"\"\"\n        Args:\n            transactions: 包含在区块中的交易\n            ancestor: 上一个区块\n            miner_address: 挖矿者的钱包. 区块奖励地址，交易费会存储在这里\n        \"\"\"\n        reward = compute_total_fee(transactions) + BLOCK_INCENTIVE\n        self.transactions = [GenesisTransaction(miner_address, amount=reward)] + transactions\n        self.ancestor = ancestor\n        \n        if not skip_verif:\n            assert all(map(verify_transaction, transactions))\n        \n        json_block = json.dumps(self.to_dict(include_hash=False))\n        self.nonce, _ = mine(json_block, DIFFICULTY)\n        self.hash = dumb_hash(json_block + self.nonce)\n        \n    def fee(self):\n        \"\"\"返回该区块的交易费\"\"\"\n        return compute_total_fee(self.transactions)\n    \n    def to_dict(self, include_hash=True):\n        d = {\n            \"transactions\": list(map(Transaction.to_dict, self.transactions)),\n            \"previous_block\": self.ancestor.hash,\n        }\n        if include_hash:\n            d[\"nonce\"] = self.nonce\n            d[\"hash\"] = self.hash\n        return d\n    \n    \nclass GenesisBlock(Block):\n    \"\"\"\n\t区块链中的第一个区块，没有祖先\n    \"\"\"\n    def __init__(self, miner_address):\n        super(GenesisBlock, self).__init__(transactions=[], ancestor=None, miner_address=miner_address)\n\n    def to_dict(self, include_hash=True):\n        d = {\n            \"transactions\": [],\n            \"genesis_block\": True,\n        }\n        if include_hash:\n            d[\"nonce\"] = self.nonce\n            d[\"hash\"] = self.hash\n        return d</code></pre>\n\n<p>类似验证交易，还需要验证区块</p>\n\n<pre><code>def verify_block(block, genesis_block, used_outputs=None):\n    \"\"\"\n    验证区块的有效性：\n    - 验证哈希以指定数量的数字开头\n    - 验证相同交易的输出没有使用两次\n    - 验证所有交易有效\n    - 验证验证第一笔交易是 GenesisTransaction，钱数是 BLOCK_INCENTIVE + total_fee\n    \n    Args:\n        block: 需要验证的区块\n        genesis_block: The genesis block (由所有人共享)\n        used_outputs: 在这之上的交易中的所有输出\n    \"\"\"\n    if used_outputs is None:\n        used_outputs = set()\n    \n    # Verify hash\n    prefix = '1' * DIFFICULTY\n    if not block.hash.startswith(prefix):\n        logging.error(\"Block hash (%s) doesn't start with prefix %s\" % (block.hash, prefix))\n        return False\n    if not all(map(verify_transaction, block.transactions)):\n        return False\n    \n    # Verify that transactions in this block don't use already spent outputs\n    #\n    # Note that we could move this in verify_transaction, but this would require some passing the used_outputs\n    # around more. So we do it here for simplicity\n    for transaction in block.transactions:\n        for i in transaction.inputs:\n            if i.parent_output in used_outputs:\n                logging.error(\"Transaction uses an already spent output : %s\" % json.dumps(i.parent_output.to_dict()))\n                return False\n            used_outputs.add(i.parent_output)\n    \n    # Verify ancestors up to the genesis block\n    if not (block.hash == genesis_block.hash):\n        if not verify_block(block.ancestor, genesis_block, used_outputs):\n            logging.error(\"Failed to validate ancestor block\")\n            return False\n    \n    # Verify the first transaction is the miner's reward\n    tx0 = block.transactions[0]\n    if not isinstance(tx0, GenesisTransaction):\n        logging.error(\"Transaction 0 is not a GenesisTransaction\")\n        return False\n    if not len(tx0.outputs) == 1:\n        logging.error(\"Transactions 0 doesn't have exactly 1 output\")\n        return False\n    reward = compute_total_fee(block.transactions[1:]) + BLOCK_INCENTIVE\n    if not tx0.outputs[0].amount == reward:\n        logging.error(\"Invalid amount in transaction 0 : %d, expected %d\" % (tx0.outputs[0].amount, reward))\n        return False\n    \n    # Only the first transaction shall be a genesis\n    for i, tx in enumerate(block.transactions):\n        if i == 0:\n            if not isinstance(tx, GenesisTransaction):\n                logging.error(\"Non-genesis transaction at index 0\")\n                return False  \n        elif isinstance(tx, GenesisTransaction):\n            logging.error(\"GenesisTransaction (hash=%s) at index %d != 0\", tx.hash(), i)\n            return False\n    return True\n\t\n\t\nalice = Wallet()\nbob = Wallet()\nwalter = Wallet()\n\ngenesis_block = GenesisBlock(miner_address=alice.address)\nprint(\"genesis_block : \" + genesis_block.hash + \" with fee=\" + str(genesis_block.fee()))\n\nt1 = genesis_block.transactions[0]\nt2 = Transaction(\n    alice,\n    [TransactionInput(t1, 0)],\n    [TransactionOutput(bob.address, 5.0), TransactionOutput(alice.address, 15.0), TransactionOutput(walter.address, 5.0)]\n)\nt3 = Transaction(\n    walter,\n    [TransactionInput(t2, 2)],\n    [TransactionOutput(bob.address, 5.0)])\n\nt4 = Transaction(\n    bob,\n    [TransactionInput(t2, 0), TransactionInput(t3, 0)],\n    [TransactionOutput(walter.address, 8.0), TransactionOutput(bob.address, 1.0)]\n)\n\nblock1 = Block([t2], ancestor=genesis_block, miner_address=walter.address)\nprint(\"block1        : \" + block1.hash + \" with fee=\" + str(block1.fee()))\n\nblock2 = Block([t3, t4], ancestor=block1, miner_address=walter.address)\nprint(\"block2        : \" + block2.hash + \" with fee=\" + str(block2.fee()))\t\t\n\n</code></pre>\n\n<p>genesis_block : 1162dce8ffec3acf13ce61109f121922eee8cceeea4784aa9d90dc6ec0e0fa92 with fee=0\n <br />block1 : 11af277c02c22a7e3c3a73102282ca5a0e01869b1d852527b6a842f0786ee8e3 with fee=0.0\n <br />block2 : 119e461d393b793478c7c7cb9fa6feb54fca35865a398d017e541027a78a2e9a with fee=1.0</p>\n\n<pre><code>verify_block(block1, genesis_block)\nverify_block(block2, genesis_block)\n</code></pre>\n\n<p>True</p>\n\n<pre><code>def collect_transactions(block, genesis_block):\n    \"\"\"递归收集该区块和祖先的所有交易\"\"\"\n    # Important : COPY block.transactions\n    transactions = [] + block.transactions\n    if block.hash != genesis_block.hash:\n        transactions += collect_transactions(block.ancestor, genesis_block)\n    return transactions\n\ntransactions = collect_transactions(block2, genesis_block)\n\n# Alice mined 25 (from the genesis block) and gave 5 to bob and 5 to walter\nprint(\"Alice  has %.02f dumbcoins\" % compute_balance(alice.address, transactions))\n# Bob received 5 from alice and 5 from walter, but then back 8 to walter with a transaction fee of 1\nprint(\"Bob    has %.02f dumbcoins\" % compute_balance(bob.address, transactions))\n# Walter mined 2 blocks (2 * 25), received 8 from bob and go a transaction fee of 1 on block2\nprint(\"Walter has %.02f dumbcoins\" % compute_balance(walter.address, transactions))\n\n</code></pre>\n\n<p>Alice has 15.00 dumbcoins\n <br />Bob has 1.00 dumbcoins\n <br />Walter has 59.00 dumbcoins</p>\n\n<h1 id=\"攻击\">攻击</h1>\n\n<p>如果挖矿者(walter)尝试花bob的钱，bob的区块不会验证通过</p>\n\n<pre><code>tx = Transaction(\n    walter,\n    [TransactionInput(t4, 1)],\n    [TransactionOutput(walter.address, 1.0)],\n)\n\n# Note that we have to use skip_verif=True to not trigger the assert in Block's constructor\nblock = Block([tx], ancestor=block2, miner_address=walter.address, skip_verif=True)\nassert not verify_block(block, genesis_block)\n\n</code></pre>\n\n<p>ERROR:root:Invalid transaction signature, trying to spend someone else&rsquo;s money ?</p>\n\n<p>还有一种攻击是挖矿者尝试修改区块中的交易，也不会成功</p>\n\n<pre><code># This is a transaction signed by bob\ntx = Transaction(\n    bob,\n    [TransactionInput(t2, 0), TransactionInput(t3, 0)],\n    [TransactionOutput(walter.address, 8.0), TransactionOutput(bob.address, 1.0)]\n)\n# And modified by the miner\ntx.outputs[0].amount += 4\nblock = Block([t3, tx], ancestor=block1, miner_address=walter.address, skip_verif=True)\nassert not verify_block(block, genesis_block)</code></pre>\n\n<p>ERROR:root:Invalid transaction signature, trying to spend someone else&rsquo;s money ?</p>\n\n<p>签名的交易可能重复，增加循环中的总钱数</p>\n\n<pre><code>block = Block([t3, t3, t4], ancestor=block1, miner_address=bob.address, skip_verif=True)\nassert not verify_block(block, genesis_block)</code></pre>\n\n<p>ERROR:root:Transaction uses an already spent output : {\"recipient_address\": &ldquo;30819f300d06092a864886f70d010101050003818d0030818902818100aec88246cc7e63c404c083b34ce153bdcf25749ec8d8764df14c0940ec795ce7522c9923e7aad577f60d346939e6c6aff45c432c6644cef675efb336fc24bdbb966d1448521537390b502c5677251e40c4a0d7b8ec9be732c21b9fe7bac7dc0f8551677645a6b89a8a39ac581fc2d440867f46994d1a52d1ddc1a22f67740f3f0203010001&rdquo;, &ldquo;amount&rdquo;: 5.0}</p>\n\n<h1 id=\"51攻击\">51%攻击</h1>\n\n<p>到目前为止账目是自我完整的，钱是只能由所有者花费。 但是还有个缺陷，没有账目中心，相信哪一个？规则是相信最长的那个区块链。</p>\n\n<pre><code># Let's start again with the same example transactions and blocks as above\nalice = Wallet()\nbob = Wallet()\nwalter = Wallet()\n\ngenesis_block = GenesisBlock(miner_address=alice.address)\n\nt1 = genesis_block.transactions[0]\nt2 = Transaction(\n    alice,\n    [TransactionInput(t1, 0)],\n    [TransactionOutput(bob.address, 5.0), TransactionOutput(alice.address, 15.0), TransactionOutput(walter.address, 5.0)]\n)\nt3 = Transaction(\n    walter,\n    [TransactionInput(t2, 2)],\n    [TransactionOutput(bob.address, 5.0)])\n\nt4 = Transaction(\n    bob,\n    [TransactionInput(t2, 0), TransactionInput(t3, 0)],\n    [TransactionOutput(walter.address, 8.0), TransactionOutput(bob.address, 1.0)]\n)\n\nblock1 = Block([t2], ancestor=genesis_block, miner_address=walter.address)\nblock2 = Block([t3, t4], ancestor=block1, miner_address=walter.address)</code></pre>\n\n<p>上面的t4，bob发了8个币给walter。假设walter是个商人，他卖给bob一个很好的车，交换了8个币。bob有了一辆车，walter有8个币。</p>\n\n<p>bob感觉有点穷，他不想在block2中花费8个币。他修改了一下历史，他给自己交易，然后挖矿了自己的区块。</p>\n\n<pre><code>t4_malicious = Transaction(\n    bob,\n    [TransactionInput(t2, 0), TransactionInput(t3, 0)],\n    [TransactionOutput(bob.address, 8.0), TransactionOutput(bob.address, 1.0)]\n)\nblock2_malicious = Block([t3, t4_malicious], ancestor=block1, miner_address=bob.address)\nprint(verify_block(block2_malicious, genesis_block))</code></pre>\n\n<p>True</p>\n\n<p>block2_malicious还没有被网络接受，它还没超过最长的账目block2。更多的交易发生了，在后面的区块挖矿。刚好bob挖矿了新的区块使用上一个交易。</p>\n\n<pre><code>t6 = Transaction(\n    alice,\n    [TransactionInput(t2, 1)],\n    [TransactionOutput(walter.address, 5.0), TransactionOutput(alice.address, 10.0)]\n)\n\nblock3_malicious = Block([t6], ancestor=block2_malicious, miner_address=bob.address)</code></pre>\n\n<p>在比特币中的规则，是相信区块链中最长的。我们找一下哪个是最长的。</p>\n\n<pre><code>def chain_length(block):\n    if block.ancestor is None:\n        return 1\n    else:\n        return 1 + chain_length(block.ancestor)\n\nprint(\"Chain length for block2           : %d\" % chain_length(block2))\nprint(\"Chain length for block3_malicious : %d \" % chain_length(block3_malicious))</code></pre>\n\n<p>Chain length for block2 : 3\n <br />Chain length for block3_malicious : 4</p>\n\n<p>接受的账目是block3_malicious，因为它是最长的。bob成功的重写了账目。另外它还是有一辆车，用8个币在walter那交易得来的。walter接受的8个币的交易被认为非法，导致walter并没有拥有8个币。</p>\n\n<p>这就是51%攻击，或者大多数攻击。</p>\n\n<p>然而walter通过计算 block3 = Block([t6], ancestor=block2, miner_address=walter.address)，block3应该由网络接受的。bob要么很幸运，很快找到了nonce，或者刚好比walter更快创建了更长的账目。</p>\n\n<p>从这个例子中得到三个有趣的结论：</p>\n\n<ul>\n <li>即使有大多数的挖矿能力，攻击者只能改变他的一个交易数据。他没办法从空气中创造钱（这需要无效区块）或花了其他的人钱（他不能签名交易）。\n  <br /></li>\n <li>这个工作的昂贵证据是需要花费足够的代码创建有效区块。如果证据是无足轻重的，网络可能就早被并发冲突给打乱了，也不会达成一致。\n  <br /></li>\n <li>相信最长区块规则，就是需要在确认交易有效性之前，要等多个交易确认。交易的确认数量就是在上一笔交易后面有多少区块。等待的交易确认数越多，攻击者修改交易的代价就越大。</li></ul>\n\n<h1 id=\"与比特币的主要不同\">与比特币的主要不同</h1>\n\n<p>就像前面解释的，这个例子并不是要做一个可使用的比特币实现，因此很多特性都没实现。</p>\n\n<ul>\n <li>使用了公钥作为钱包地址，比特币更复杂。\n  <br /></li>\n <li>比特币使用了ECDSA，这里使用了RSA。\n  <br /></li>\n <li>比特币使用了两轮SHA256，这里使用了一轮。\n  <br /></li>\n <li>比特币的交易使用了<a href=\"https://en.bitcoin.it/wiki/Script\">脚本语言</a>，这里只是简单的一个交易输出有一个数量。\n  <br /></li>\n <li>比特币需要传播区块给所有节点。整块传播并没有在这里写。参考<a href=\"https://en.bitcoin.it/wiki/Satoshi_Client_Node_Discovery\">Client Node Discovery</a>和<a href=\"https://en.bitcoin.it/wiki/Protocol_documentation\">Protocol documentation</a>。\n  <br /></li>\n <li>比特币使用了<a href=\"https://en.wikipedia.org/wiki/Merkle_tree\">Merkle tree</a>来存储。</li></ul>\n\n<h1 id=\"安全问题\">安全问题</h1>\n\n<p>出了前面说的不同，这个实现还有很多安全因素</p>\n\n<ul>\n <li>使用浮点数运算会产生很多问题。（精度损失）\n  <br /></li>\n <li>这里的JSON序列化不够跨平台。例如在不同平台的相同交易的两次序列化会产生不同，（行尾，关键字顺序，空格）\n  <br /></li>\n <li>这里实现的挖矿方法会因为整数溢出死循环</li></ul>") #f (u . "\n<p>原文地址 https://github.com/julienr/ipynb_playground/blob/master/bitcoin/dumbcoin/dumbcoin.ipynb</p>\n\n<h1 id=\"简介\">简介</h1>\n\n<p>这是一本实验性质的手册，用Python实现了类比特币区块链的大多数概念。它并不安全，也不是真实的区块链，所以你不应该用它做任何其他事情，除了教育目的。</p>\n\n<p>不考虑比特币的金融利弊，它的底层技术很有趣，原始论文也很容易理解。</p>\n\n<p>或许你想要看看这本手册在<a href=\"https://news.ycombinator.com/item?id=15945490\">HackerNews</a>上的讨论。</p>\n\n<h1 id=\"引用\">引用</h1>\n\n<p>我使用了<a href=\"https://bitcoin.org/bitcoin.pdf\">比特币的最初论文</a>，还有<a href=\"http://www.michaelnielsen.org/ddi/how-the-bitcoin-protocol-actually-works/\">Michael Nielsen比特币的解释</a>。<a href=\"https://en.bitcoin.it/wiki/Main_Page\">比特币Wiki</a>是非常不错的技术资源。</p>\n\n<h1 id=\"内容\">内容</h1>\n\n<ol>\n <li>哈希函数和挖矿\n  <br /></li>\n <li>难度\n  <br /></li>\n <li>钱包\n  <br /></li>\n <li>交易\n  <br /></li>\n <li>区块\n  <br /></li>\n <li>攻击\n  <br /></li>\n <li>51%攻击\n  <br /></li>\n <li>与比特币的不同</li></ol>\n\n<p>需要用到的库</p>\n\n<pre><code>import hashlib\nimport random\nimport string\nimport json\nimport binascii\nimport numpy as np\nimport pandas as pd\nimport pylab as pl\nimport logging\n%matplotlib inline</code></pre>\n\n<h1 id=\"哈希函数和挖矿\">哈希函数和挖矿</h1>\n\n<p>我们先实现挖矿。这里我们使用SHA256哈希函数，因为SHA256的Python实现的很稳定。注意比特币使用了<a href=\"https://en.bitcoin.it/wiki/Hashcash\">2轮SHA256算法</a>，而不是1轮。</p>\n\n<p>我们的哈希函数会把任意长度的字符串转换成固定长度的64进制字符串。例如</p>\n\n<pre><code>def sha256(message):\n\treturn hashlib.sha256(message.encode('ascii')).hexdigest()</code></pre>\n\n<p>挖矿的流程是：任意长度字符串x，找这样一个数字nonce，满足hash(x+nonce)产生的哈希值以特定字符串开始。</p>\n\n<p>这里我们挖一个特定的数字nonce，信息 &ldquo;hello bitcoin&rdquo; 连接上nonce产生的哈希值有至少两个前缀数字。</p>\n\n<pre><code>message = 'hello bitcoin'\nfor nonce in range(1000):\n    digest = sha256(message + str(nonce))\n    if digest.startswith('11'):\n        print('Found nonce = %d' % nonce)\n        break\nprint(sha256(message + str(nonce)))\n\n\nFound nonce = 32\n112c38d2fdb6ddaf32f371a390307ccc779cd92443b42c4b5c58fa548f63ed83\n</code></pre>\n\n<p>要求的前缀数字越多，越难找到特定nonce。在比特币里，这叫做挖矿难度。注意比特币并不要求前缀数字，而是要求哈希值必须低于某个特定值。但是原理是相同的。</p>\n\n<p>定义两个函数，后面使用：一个函数做哈希运算，一个函数针对字符串挖矿nonce</p>\n\n<pre><code>def dumb_hash(message):\n\t\"\"\"\n    返回64进制字符串\n\t\"\"\"\n\treturn sha256(message)\n\t\t\t\n\t\t\t\ndef mine(message, difficulty=1):\n    \"\"\"\n\t输入给定字符串，找到nonce，满足hash(string+nonce)有特定难度的前缀\n\t\t\t\t    \n    Returns: (nonce, niters)\n\t\tnonce: The found nonce\n\t\tniters: The number of iterations required to find the nonce\n\t\"\"\"\n\tassert difficulty &gt;= 1, \"Difficulty of 0 is not possible\"\n\ti = 0\n\tprefix = '1' * difficulty\n\twhile True:\n\t\tnonce = str(i)\n\t\tdigest = dumb_hash(message + nonce)\n\t\tif digest.startswith(prefix):\n\t\t\treturn nonce, i\n\t\ti += 1\n\t\t\n\t\t</code></pre>\n\n<p>这样我们就可以在不同难度下挖矿了</p>\n\n<pre><code>nonce, niters = mine('42', difficulty=1)\nprint('Took %d iterations' % niters)\n\nnonce, niters = mine('42', difficulty=3)\nprint('Took %d iterations' % niters)\n\n\nTook 23 iterations\nTook 2272 iterations\n\n</code></pre>\n\n<p>例子中可以看到难度3的迭代次数要比难度1的迭代次数大很多。注意，运气好的话，第一个nonce（这里是0）就可以找到了。因此难度控制的是尝试的平均次数。基于此，我们可以做一个好看的图表。</p>\n\n<h1 id=\"难度表\">难度表</h1>\n\n<p>对于每个难度等级，我们会针对多个字符串挖矿nonce。我们记录下每个难度的平均尝试次数。</p>\n\n<pre><code>def random_string(length=10):\n\treturn ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(length))\n\nstrings = [random_string() for i in range(50)]\n\n\nlevels = range(1, 5)\n# An array of results with a row for each difficulty and a column for each test string\nresults = pd.DataFrame(index=strings, columns=levels, dtype=np.int)\nresults.fillna(value=0)\n\n#results = np.zeros((N_LEVELS, len(strings)), dtype=np.int)\nfor level in levels:\n    for s in strings:\n\t\t_, niters = mine(s, difficulty=level)\n\t\tresults[level][s] = niters\n\n\npl.figure(figsize=(10, 5))\nax = pl.subplot(111)\nax.set_title('Number of iterations to mine a nonce for various difficulty')\nresults.plot.box(showfliers=False, ax=ax)\nax.set_xlabel('Difficulty')\nax.set_ylabel('Iterations')\n\n</code></pre>\n\n<h1 id=\"钱包\">钱包</h1>\n\n<p>在比特币里钱包是公钥私钥对。公钥私钥对解释 <a href=\"https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29\">RSA</a>。</p>\n\n<p>公钥用于接受交易，私钥用于花钱。私钥签名交易，所有其他人都可以用公钥验证。</p>\n\n<p>在比特币里，钱包稍微复杂一点。钱包是多个公钥私钥对，钱包地址并不直接是公钥。这更好的保证隐私和安全，但是dumbcoin这里只用一个，公钥作为钱包地址。</p>\n\n<pre><code>import Crypto\nimport Crypto.Random\nfrom Crypto.Hash import SHA\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Signature import PKCS1_v1_5\n\n\nclass Wallet(object):\n    \"\"\"\n    钱包是公钥私钥对\n    \"\"\"\n    def __init__(self):\n        random_gen = Crypto.Random.new().read\n        self._private_key = RSA.generate(1024, random_gen)\n        self._public_key = self._private_key.publickey()\n        self._signer = PKCS1_v1_5.new(self._private_key)\n        \n    @property\n    def address(self):\n        \"\"\"我们简单起见，公钥就是地址\"\"\"\n        return binascii.hexlify(self._public_key.exportKey(format='DER')).decode('ascii')\n    \n    def sign(self, message):\n        \"\"\"\n        用这个钱包签名message\n        \"\"\"\n        h = SHA.new(message.encode('utf8'))\n        return binascii.hexlify(self._signer.sign(h)).decode('ascii')\n    \n    \ndef verify_signature(wallet_address, message, signature):\n    \"\"\"\n\t检查message的签名signature是否由wallet_address签名\n    \"\"\"\n    pubkey = RSA.importKey(binascii.unhexlify(wallet_address))\n    verifier = PKCS1_v1_5.new(pubkey)\n    h = SHA.new(message.encode('utf8'))\n    return verifier.verify(h, binascii.unhexlify(signature))\n\n\n# 测试一下\nw1 = Wallet()\nsignature = w1.sign('foobar')\nassert verify_signature(w1.address, 'foobar', signature)\nassert not verify_signature(w1.address, 'rogue message', signature)\n\n</code></pre>\n\n<h1 id=\"做交易\">做交易</h1>\n\n<p>在钱包之间交换钱，需要用到交易。交易是由下面3部分组成：</p>\n\n<ul>\n <li>消费者 Spender，他会给交易签名，花他自己的钱\n  <br /></li>\n <li>多个输入 input，是其他交易的输出。所有这些的接受者是消费者 Spender的钱包。\n  <br />要不然你就可以花其他人的钱了。\n  <br /></li>\n <li>多个输出 output，每个都指定了钱数和接受者。</li></ul>\n\n<p>交易会包含交易费，这样刺激挖矿者在区块中包含该交易。费用就是输入数量和输出数量之间的差异。</p>\n\n<p>所有交易需要一个父节点，在架构里需要一个根节点。我们起名 GenesisTransaction</p>\n\n<pre><code>class TransactionInput(object):\n    \"\"\"\n\t交易输入，指向另一个交易的输出\n    \"\"\"\n    def __init__(self, transaction, output_index):\n        self.transaction = transaction\n        self.output_index = output_index\n        assert 0 &lt;= self.output_index &lt; len(transaction.outputs)\n        \n    def to_dict(self):\n        d = {\n            'transaction': self.transaction.hash(),\n            'output_index': self.output_index\n        }\n        return d\n    \n    @property\n    def parent_output(self):\n        return self.transaction.outputs[self.output_index]\n    \n\nclass TransactionOutput(object):\n    \"\"\"\n\t交易输出，指定数量和接收者钱包\n    \"\"\"\n    def __init__(self, recipient_address, amount):\n        self.recipient = recipient_address\n        self.amount = amount\n        \n    def to_dict(self):\n        d = {\n            'recipient_address': self.recipient,\n            'amount': self.amount\n        }\n        return d\n\n        \ndef compute_fee(inputs, outputs):\n    \"\"\"\n\t通过总输入和总输出，计算交易费\n    \"\"\"\n    total_in = sum(i.transaction.outputs[i.output_index].amount for i in inputs)\n    total_out = sum(o.amount for o in outputs)\n    assert total_out &lt;= total_in, \"Invalid transaction with out(%f) &gt; in(%f)\" % (total_out, total_in)\n    return total_in - total_out\n\n    \nclass Transaction(object):\n    def __init__(self, wallet, inputs, outputs):\n        \"\"\"\n\t\t创建交易，从指定钱包花钱\n        \"\"\"\n        self.inputs = inputs\n        self.outputs = outputs\n        self.fee = compute_fee(inputs, outputs)\n        self.signature = wallet.sign(json.dumps(self.to_dict(include_signature=False)))\n        \n    def to_dict(self, include_signature=True):\n        d = {\n            \"inputs\": list(map(TransactionInput.to_dict, self.inputs)),\n            \"outputs\": list(map(TransactionOutput.to_dict, self.outputs)),\n            \"fee\": self.fee\n        }\n        if include_signature:\n            d[\"signature\"] = self.signature\n        return d\n    \n    def hash(self):\n        return dumb_hash(json.dumps(self.to_dict()))\n    \n    \nclass GenesisTransaction(Transaction):\n    \"\"\"\n\t第一笔交易是特定交易，没有输入，有25个比特币的输出\n    \"\"\"\n    def __init__(self, recipient_address, amount=25):\n        self.inputs = []\n        self.outputs = [\n            TransactionOutput(recipient_address, amount)\n        ]\n        self.fee = 0\n        self.signature = 'genesis'\n        \n    def to_dict(self, include_signature=False):\n        # TODO: Instead, should sign genesis transaction will well-known public key ?\n        assert not include_signature, \"Cannot include signature of genesis transaction\"\n        return super().to_dict(include_signature=False)</code></pre>\n\n<p>有了上面的类，我们可以在alice和bob之间做交易了</p>\n\n<pre><code>alice = Wallet()\nbob = Wallet()\n\nt1 = GenesisTransaction(alice.address)\nt2 = Transaction(\n    alice,\n    [TransactionInput(t1, 0)],\n    [TransactionOutput(bob.address, 2.0), TransactionOutput(alice.address, 22.0)]\n)\nassert np.abs(t2.fee - 1.0) &lt; 1e-5\n\n</code></pre>\n\n<p>在比特币里，并不会存储钱包的钱数。 会遍历交易链来计算你有多少。写一个函数来做这件事。</p>\n\n<pre><code>alice = Wallet()\nbob = Wallet()\nwalter = Wallet()\n\n# This gives 25 coins to Alice\nt1 = GenesisTransaction(alice.address)\n\n# Of those 25, Alice will spend\n# Alice -- 5 --&gt; Bob\n#       -- 15 --&gt; Alice\n#       -- 5 --&gt; Walter\nt2 = Transaction(\n    alice,\n    [TransactionInput(t1, 0)],\n    [TransactionOutput(bob.address, 5.0), TransactionOutput(alice.address, 15.0), TransactionOutput(walter.address, 5.0)]\n)\n\n# Walter -- 5 --&gt; Bob\nt3 = Transaction(\n    walter,\n    [TransactionInput(t2, 2)],\n    [TransactionOutput(bob.address, 5.0)])\n\n# Bob -- 8 --&gt; Walter\n#     -- 1 --&gt; Bob\n#        1 fee\nt4 = Transaction(\n    bob,\n    [TransactionInput(t2, 0), TransactionInput(t3, 0)],\n    [TransactionOutput(walter.address, 8.0), TransactionOutput(bob.address, 1.0)]\n)\n\ntransactions = [t1, t2, t3, t4]\n\n\ndef compute_balance(wallet_address, transactions):\n    \"\"\"\n\t给定地址和交易链，计算地址的钱包余额\n    \"\"\"\n    balance = 0\n    for t in transactions:\n        # Subtract all the money that the address sent out\n        for txin in t.inputs:\n            if txin.parent_output.recipient == wallet_address:\n                balance -= txin.parent_output.amount\n        # Add all the money received by the address\n        for txout in t.outputs:\n            if txout.recipient == wallet_address:\n                balance += txout.amount\n    return balance\n\nprint(\"Alice  has %.02f dumbcoins\" % compute_balance(alice.address, transactions))\nprint(\"Bob    has %.02f dumbcoins\" % compute_balance(bob.address, transactions))\nprint(\"Walter has %.02f dumbcoins\" % compute_balance(walter.address, transactions))\n\n\nAlice  has 15.00 dumbcoins\nBob    has 1.00 dumbcoins\nWalter has 8.00 dumbcoins</code></pre>\n\n<p>还需要确认交易是否有效，这意味着：</p>\n\n<ul>\n <li>你仅仅能花自己的钱。这意味着所有输入由交易的拥有者拥有。\n  <br /></li>\n <li>确保你花的钱不会比你有的多。这是有上面的compute_fee检查。</li></ul>\n\n<p>函数</p>\n\n<pre><code>def verify_transaction(transaction):\n    \"\"\"\n    确保交易是有效的\n    - 所有输入都属于相同的钱包\n    - 交易是由响应的钱包主人签名的\n    \"\"\"\n    tx_message = json.dumps(transaction.to_dict(include_signature=False))\n    if isinstance(transaction, GenesisTransaction):\n        # TODO: We should probably be more careful about validating genesis transactions\n        return True\n    \n    # Verify input transactions\n    for tx in transaction.inputs:\n        if not verify_transaction(tx.transaction):\n            logging.error(\"Invalid parent transaction\")\n            return False\n    \n    # Verify a single wallet owns all the inputs\n    first_input_address = transaction.inputs[0].parent_output.recipient\n    for txin in transaction.inputs[1:]:\n        if txin.parent_output.recipient != first_input_address:\n            logging.error(\n                \"Transaction inputs belong to multiple wallets (%s and %s)\" %\n                (txin.parent_output.recipient, first_input_address)\n            )\n            return False\n    \n    if not verify_signature(first_input_address, tx_message, transaction.signature):\n        logging.error(\"Invalid transaction signature, trying to spend someone else's money ?\")\n        return False\n    \n    # Call compute_fee here to trigger an assert if output sum is great than input sum. Without this,\n    # a miner could put such an invalid transaction.\n    compute_fee(transaction.inputs, transaction.outputs)\n    \n    return True\n\t\n\nt1 = GenesisTransaction(alice.address)\n# This is an invalid transaction because bob is trying to spend alice's money\n# (alice was the recipient of the input - t1)\nt2 = Transaction(\n    bob,\n    [TransactionInput(t1, 0)],\n    [TransactionOutput(walter.address, 10.0)]\n)\n# This is valid, alice is spending her own money\nt3 = Transaction(\n    alice,\n    [TransactionInput(t1, 0)],\n    [TransactionOutput(walter.address, 10.0)]\n)\n\nassert verify_transaction(t1)\nassert not verify_transaction(t2)\n\n\nERROR:root:Invalid transaction signature, trying to spend someone else's money ?\n\n\nassert verify_transaction(t3)\n</code></pre>\n\n<h1 id=\"把交易写入区块\">把交易写入区块</h1>\n\n<p>我们现在有</p>\n\n<ul>\n <li>定义钱包（公钥私钥对）\n  <br /></li>\n <li>在钱包之间创建交易\n  <br /></li>\n <li>验证交易（检查交易的签名）</li></ul>\n\n<p>剩下来需要把交易放入区块，让挖矿者挖矿区块。挖区块由两部分组成：</p>\n\n<ul>\n <li>验证区块中的交易\n  <br /></li>\n <li>找到一个nonce，区块的哈希以几个0开始</li></ul>\n\n<p>并且挖矿根据规则会生成钱，第一个区块GenesisTransaction会给25个币给任意地址。挖矿者会添加交易，把交易产生的费用传递给任意地址。</p>\n\n<pre><code>BLOCK_INCENTIVE = 25 # 挖矿区块得到的币数\nDIFFICULTY = 2\n\n\ndef compute_total_fee(transactions):\n    \"\"\"返回交易的总费用\"\"\"\n    return sum(t.fee for t in transactions)\n\n\nclass Block(object):\n    def __init__(self, transactions, ancestor, miner_address, skip_verif=False):\n        \"\"\"\n        Args:\n            transactions: 包含在区块中的交易\n            ancestor: 上一个区块\n            miner_address: 挖矿者的钱包. 区块奖励地址，交易费会存储在这里\n        \"\"\"\n        reward = compute_total_fee(transactions) + BLOCK_INCENTIVE\n        self.transactions = [GenesisTransaction(miner_address, amount=reward)] + transactions\n        self.ancestor = ancestor\n        \n        if not skip_verif:\n            assert all(map(verify_transaction, transactions))\n        \n        json_block = json.dumps(self.to_dict(include_hash=False))\n        self.nonce, _ = mine(json_block, DIFFICULTY)\n        self.hash = dumb_hash(json_block + self.nonce)\n        \n    def fee(self):\n        \"\"\"返回该区块的交易费\"\"\"\n        return compute_total_fee(self.transactions)\n    \n    def to_dict(self, include_hash=True):\n        d = {\n            \"transactions\": list(map(Transaction.to_dict, self.transactions)),\n            \"previous_block\": self.ancestor.hash,\n        }\n        if include_hash:\n            d[\"nonce\"] = self.nonce\n            d[\"hash\"] = self.hash\n        return d\n    \n    \nclass GenesisBlock(Block):\n    \"\"\"\n\t区块链中的第一个区块，没有祖先\n    \"\"\"\n    def __init__(self, miner_address):\n        super(GenesisBlock, self).__init__(transactions=[], ancestor=None, miner_address=miner_address)\n\n    def to_dict(self, include_hash=True):\n        d = {\n            \"transactions\": [],\n            \"genesis_block\": True,\n        }\n        if include_hash:\n            d[\"nonce\"] = self.nonce\n            d[\"hash\"] = self.hash\n        return d</code></pre>\n\n<p>类似验证交易，还需要验证区块</p>\n\n<pre><code>def verify_block(block, genesis_block, used_outputs=None):\n    \"\"\"\n    验证区块的有效性：\n    - 验证哈希以指定数量的数字开头\n    - 验证相同交易的输出没有使用两次\n    - 验证所有交易有效\n    - 验证验证第一笔交易是 GenesisTransaction，钱数是 BLOCK_INCENTIVE + total_fee\n    \n    Args:\n        block: 需要验证的区块\n        genesis_block: The genesis block (由所有人共享)\n        used_outputs: 在这之上的交易中的所有输出\n    \"\"\"\n    if used_outputs is None:\n        used_outputs = set()\n    \n    # Verify hash\n    prefix = '1' * DIFFICULTY\n    if not block.hash.startswith(prefix):\n        logging.error(\"Block hash (%s) doesn't start with prefix %s\" % (block.hash, prefix))\n        return False\n    if not all(map(verify_transaction, block.transactions)):\n        return False\n    \n    # Verify that transactions in this block don't use already spent outputs\n    #\n    # Note that we could move this in verify_transaction, but this would require some passing the used_outputs\n    # around more. So we do it here for simplicity\n    for transaction in block.transactions:\n        for i in transaction.inputs:\n            if i.parent_output in used_outputs:\n                logging.error(\"Transaction uses an already spent output : %s\" % json.dumps(i.parent_output.to_dict()))\n                return False\n            used_outputs.add(i.parent_output)\n    \n    # Verify ancestors up to the genesis block\n    if not (block.hash == genesis_block.hash):\n        if not verify_block(block.ancestor, genesis_block, used_outputs):\n            logging.error(\"Failed to validate ancestor block\")\n            return False\n    \n    # Verify the first transaction is the miner's reward\n    tx0 = block.transactions[0]\n    if not isinstance(tx0, GenesisTransaction):\n        logging.error(\"Transaction 0 is not a GenesisTransaction\")\n        return False\n    if not len(tx0.outputs) == 1:\n        logging.error(\"Transactions 0 doesn't have exactly 1 output\")\n        return False\n    reward = compute_total_fee(block.transactions[1:]) + BLOCK_INCENTIVE\n    if not tx0.outputs[0].amount == reward:\n        logging.error(\"Invalid amount in transaction 0 : %d, expected %d\" % (tx0.outputs[0].amount, reward))\n        return False\n    \n    # Only the first transaction shall be a genesis\n    for i, tx in enumerate(block.transactions):\n        if i == 0:\n            if not isinstance(tx, GenesisTransaction):\n                logging.error(\"Non-genesis transaction at index 0\")\n                return False  \n        elif isinstance(tx, GenesisTransaction):\n            logging.error(\"GenesisTransaction (hash=%s) at index %d != 0\", tx.hash(), i)\n            return False\n    return True\n\t\n\t\nalice = Wallet()\nbob = Wallet()\nwalter = Wallet()\n\ngenesis_block = GenesisBlock(miner_address=alice.address)\nprint(\"genesis_block : \" + genesis_block.hash + \" with fee=\" + str(genesis_block.fee()))\n\nt1 = genesis_block.transactions[0]\nt2 = Transaction(\n    alice,\n    [TransactionInput(t1, 0)],\n    [TransactionOutput(bob.address, 5.0), TransactionOutput(alice.address, 15.0), TransactionOutput(walter.address, 5.0)]\n)\nt3 = Transaction(\n    walter,\n    [TransactionInput(t2, 2)],\n    [TransactionOutput(bob.address, 5.0)])\n\nt4 = Transaction(\n    bob,\n    [TransactionInput(t2, 0), TransactionInput(t3, 0)],\n    [TransactionOutput(walter.address, 8.0), TransactionOutput(bob.address, 1.0)]\n)\n\nblock1 = Block([t2], ancestor=genesis_block, miner_address=walter.address)\nprint(\"block1        : \" + block1.hash + \" with fee=\" + str(block1.fee()))\n\nblock2 = Block([t3, t4], ancestor=block1, miner_address=walter.address)\nprint(\"block2        : \" + block2.hash + \" with fee=\" + str(block2.fee()))\t\t\n\n</code></pre>\n\n<p>genesis_block : 1162dce8ffec3acf13ce61109f121922eee8cceeea4784aa9d90dc6ec0e0fa92 with fee=0\n <br />block1 : 11af277c02c22a7e3c3a73102282ca5a0e01869b1d852527b6a842f0786ee8e3 with fee=0.0\n <br />block2 : 119e461d393b793478c7c7cb9fa6feb54fca35865a398d017e541027a78a2e9a with fee=1.0</p>\n\n<pre><code>verify_block(block1, genesis_block)\nverify_block(block2, genesis_block)\n</code></pre>\n\n<p>True</p>\n\n<pre><code>def collect_transactions(block, genesis_block):\n    \"\"\"递归收集该区块和祖先的所有交易\"\"\"\n    # Important : COPY block.transactions\n    transactions = [] + block.transactions\n    if block.hash != genesis_block.hash:\n        transactions += collect_transactions(block.ancestor, genesis_block)\n    return transactions\n\ntransactions = collect_transactions(block2, genesis_block)\n\n# Alice mined 25 (from the genesis block) and gave 5 to bob and 5 to walter\nprint(\"Alice  has %.02f dumbcoins\" % compute_balance(alice.address, transactions))\n# Bob received 5 from alice and 5 from walter, but then back 8 to walter with a transaction fee of 1\nprint(\"Bob    has %.02f dumbcoins\" % compute_balance(bob.address, transactions))\n# Walter mined 2 blocks (2 * 25), received 8 from bob and go a transaction fee of 1 on block2\nprint(\"Walter has %.02f dumbcoins\" % compute_balance(walter.address, transactions))\n\n</code></pre>\n\n<p>Alice has 15.00 dumbcoins\n <br />Bob has 1.00 dumbcoins\n <br />Walter has 59.00 dumbcoins</p>\n\n<h1 id=\"攻击\">攻击</h1>\n\n<p>如果挖矿者(walter)尝试花bob的钱，bob的区块不会验证通过</p>\n\n<pre><code>tx = Transaction(\n    walter,\n    [TransactionInput(t4, 1)],\n    [TransactionOutput(walter.address, 1.0)],\n)\n\n# Note that we have to use skip_verif=True to not trigger the assert in Block's constructor\nblock = Block([tx], ancestor=block2, miner_address=walter.address, skip_verif=True)\nassert not verify_block(block, genesis_block)\n\n</code></pre>\n\n<p>ERROR:root:Invalid transaction signature, trying to spend someone else&rsquo;s money ?</p>\n\n<p>还有一种攻击是挖矿者尝试修改区块中的交易，也不会成功</p>\n\n<pre><code># This is a transaction signed by bob\ntx = Transaction(\n    bob,\n    [TransactionInput(t2, 0), TransactionInput(t3, 0)],\n    [TransactionOutput(walter.address, 8.0), TransactionOutput(bob.address, 1.0)]\n)\n# And modified by the miner\ntx.outputs[0].amount += 4\nblock = Block([t3, tx], ancestor=block1, miner_address=walter.address, skip_verif=True)\nassert not verify_block(block, genesis_block)</code></pre>\n\n<p>ERROR:root:Invalid transaction signature, trying to spend someone else&rsquo;s money ?</p>\n\n<p>签名的交易可能重复，增加循环中的总钱数</p>\n\n<pre><code>block = Block([t3, t3, t4], ancestor=block1, miner_address=bob.address, skip_verif=True)\nassert not verify_block(block, genesis_block)</code></pre>\n\n<p>ERROR:root:Transaction uses an already spent output : {\"recipient_address\": &ldquo;30819f300d06092a864886f70d010101050003818d0030818902818100aec88246cc7e63c404c083b34ce153bdcf25749ec8d8764df14c0940ec795ce7522c9923e7aad577f60d346939e6c6aff45c432c6644cef675efb336fc24bdbb966d1448521537390b502c5677251e40c4a0d7b8ec9be732c21b9fe7bac7dc0f8551677645a6b89a8a39ac581fc2d440867f46994d1a52d1ddc1a22f67740f3f0203010001&rdquo;, &ldquo;amount&rdquo;: 5.0}</p>\n\n<h1 id=\"51攻击\">51%攻击</h1>\n\n<p>到目前为止账目是自我完整的，钱是只能由所有者花费。 但是还有个缺陷，没有账目中心，相信哪一个？规则是相信最长的那个区块链。</p>\n\n<pre><code># Let's start again with the same example transactions and blocks as above\nalice = Wallet()\nbob = Wallet()\nwalter = Wallet()\n\ngenesis_block = GenesisBlock(miner_address=alice.address)\n\nt1 = genesis_block.transactions[0]\nt2 = Transaction(\n    alice,\n    [TransactionInput(t1, 0)],\n    [TransactionOutput(bob.address, 5.0), TransactionOutput(alice.address, 15.0), TransactionOutput(walter.address, 5.0)]\n)\nt3 = Transaction(\n    walter,\n    [TransactionInput(t2, 2)],\n    [TransactionOutput(bob.address, 5.0)])\n\nt4 = Transaction(\n    bob,\n    [TransactionInput(t2, 0), TransactionInput(t3, 0)],\n    [TransactionOutput(walter.address, 8.0), TransactionOutput(bob.address, 1.0)]\n)\n\nblock1 = Block([t2], ancestor=genesis_block, miner_address=walter.address)\nblock2 = Block([t3, t4], ancestor=block1, miner_address=walter.address)</code></pre>\n\n<p>上面的t4，bob发了8个币给walter。假设walter是个商人，他卖给bob一个很好的车，交换了8个币。bob有了一辆车，walter有8个币。</p>\n\n<p>bob感觉有点穷，他不想在block2中花费8个币。他修改了一下历史，他给自己交易，然后挖矿了自己的区块。</p>\n\n<pre><code>t4_malicious = Transaction(\n    bob,\n    [TransactionInput(t2, 0), TransactionInput(t3, 0)],\n    [TransactionOutput(bob.address, 8.0), TransactionOutput(bob.address, 1.0)]\n)\nblock2_malicious = Block([t3, t4_malicious], ancestor=block1, miner_address=bob.address)\nprint(verify_block(block2_malicious, genesis_block))</code></pre>\n\n<p>True</p>\n\n<p>block2_malicious还没有被网络接受，它还没超过最长的账目block2。更多的交易发生了，在后面的区块挖矿。刚好bob挖矿了新的区块使用上一个交易。</p>\n\n<pre><code>t6 = Transaction(\n    alice,\n    [TransactionInput(t2, 1)],\n    [TransactionOutput(walter.address, 5.0), TransactionOutput(alice.address, 10.0)]\n)\n\nblock3_malicious = Block([t6], ancestor=block2_malicious, miner_address=bob.address)</code></pre>\n\n<p>在比特币中的规则，是相信区块链中最长的。我们找一下哪个是最长的。</p>\n\n<pre><code>def chain_length(block):\n    if block.ancestor is None:\n        return 1\n    else:\n        return 1 + chain_length(block.ancestor)\n\nprint(\"Chain length for block2           : %d\" % chain_length(block2))\nprint(\"Chain length for block3_malicious : %d \" % chain_length(block3_malicious))</code></pre>\n\n<p>Chain length for block2 : 3\n <br />Chain length for block3_malicious : 4</p>\n\n<p>接受的账目是block3_malicious，因为它是最长的。bob成功的重写了账目。另外它还是有一辆车，用8个币在walter那交易得来的。walter接受的8个币的交易被认为非法，导致walter并没有拥有8个币。</p>\n\n<p>这就是51%攻击，或者大多数攻击。</p>\n\n<p>然而walter通过计算 block3 = Block([t6], ancestor=block2, miner_address=walter.address)，block3应该由网络接受的。bob要么很幸运，很快找到了nonce，或者刚好比walter更快创建了更长的账目。</p>\n\n<p>从这个例子中得到三个有趣的结论：</p>\n\n<ul>\n <li>即使有大多数的挖矿能力，攻击者只能改变他的一个交易数据。他没办法从空气中创造钱（这需要无效区块）或花了其他的人钱（他不能签名交易）。\n  <br /></li>\n <li>这个工作的昂贵证据是需要花费足够的代码创建有效区块。如果证据是无足轻重的，网络可能就早被并发冲突给打乱了，也不会达成一致。\n  <br /></li>\n <li>相信最长区块规则，就是需要在确认交易有效性之前，要等多个交易确认。交易的确认数量就是在上一笔交易后面有多少区块。等待的交易确认数越多，攻击者修改交易的代价就越大。</li></ul>\n\n<h1 id=\"与比特币的主要不同\">与比特币的主要不同</h1>\n\n<p>就像前面解释的，这个例子并不是要做一个可使用的比特币实现，因此很多特性都没实现。</p>\n\n<ul>\n <li>使用了公钥作为钱包地址，比特币更复杂。\n  <br /></li>\n <li>比特币使用了ECDSA，这里使用了RSA。\n  <br /></li>\n <li>比特币使用了两轮SHA256，这里使用了一轮。\n  <br /></li>\n <li>比特币的交易使用了<a href=\"https://en.bitcoin.it/wiki/Script\">脚本语言</a>，这里只是简单的一个交易输出有一个数量。\n  <br /></li>\n <li>比特币需要传播区块给所有节点。整块传播并没有在这里写。参考<a href=\"https://en.bitcoin.it/wiki/Satoshi_Client_Node_Discovery\">Client Node Discovery</a>和<a href=\"https://en.bitcoin.it/wiki/Protocol_documentation\">Protocol documentation</a>。\n  <br /></li>\n <li>比特币使用了<a href=\"https://en.wikipedia.org/wiki/Merkle_tree\">Merkle tree</a>来存储。</li></ul>\n\n<h1 id=\"安全问题\">安全问题</h1>\n\n<p>出了前面说的不同，这个实现还有很多安全因素</p>\n\n<ul>\n <li>使用浮点数运算会产生很多问题。（精度损失）\n  <br /></li>\n <li>这里的JSON序列化不够跨平台。例如在不同平台的相同交易的两次序列化会产生不同，（行尾，关键字顺序，空格）\n  <br /></li>\n <li>这里实现的挖矿方法会因为整数溢出死循环</li></ul>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2012-11-13-swf-spec-9-font-text.md" . unix) f post (u . "SWF9文件格式-字体和文本(SWF File Format Version9 - Fonts and Text)") (? . 11) 1505573652 (p+ #"/Users/zhonghua/demo/zhonghua_com/2012/11/swf9\346\226\207\344\273\266\346\240\274\345\274\217-\345\255\227\344\275\223\345\222\214\346\226\207\346\234\254-swf-file-format-version9-fonts-and-text.html" . unix) (u . "/2012/11/swf9%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-%E5%AD%97%E4%BD%93%E5%92%8C%E6%96%87%E6%9C%AC-swf-file-format-version9-fonts-and-text.html") (u . "2012-11-13T00:00:00") (? . 21) (? . 22) (c (u . "SWF")) (u . "\n<p>SWF8支持很多渲染文本的方法。在SWF6之后，所有的文本都使用Unicode编码，避免了文本和字符串在不同地区之间的区别。提醒一下，尽管FP是完全支持Unicode的，但是它仅仅支持从左到右的简单文本，还不支持Hebrew，Arabic，Thai等其它复杂的文本。</p>\n\n<h1 id=\"字型文本和设备文本\">字型文本和设备文本</h1>\n\n<p>SWF支持两种文本类型：字型文本和设备文本。字型文本通过在SWF中嵌入字符形状实现，设备文本使用的是各自平台的文本渲染功能。</p>\n\n<p>字型文本在所有平台上看起来都一样。并且可以使用标准反锯齿功能。在SWF8之后，也可以使用高级文本渲染引擎实现。相对设备文本，使用字型文本会让生成的SWF文件更大，尤其是在一个很大的字符集里使用了很多字符。</p>\n\n<p>设备字体由操作系统本身实现反锯齿效果，不同平台表现不一样。有两种方式指定设备文本：通过字体名称在系统中查找，或使用一个特殊的字体名称，映射到系统的高可用字体，尽量选择相近的字体。</p>\n\n<p>字型文本字符通过DefineFont，DefineFont2，DefineFont3定义。设备文本字体通过DefineFont和DefineFontInfo一起定义，或者直接通过DefineFont2定义。定义设备文本字体的DefineFont2，如果用于动态文本的话，不需要包含任何字符图像。DefineFont和DefineFont2标签可以同时为某些文本提供字型文本支持，并且为其它文本提供设备文本支持，只要提供了图像和字符编码。</p>\n\n<h1 id=\"静态文本和动态文本\">静态文本和动态文本</h1>\n\n<p>文本可以被定义为静态的，或者在SWF4之后，动态的。动态文本可以在运行时改变，并且还可以编辑。动态文本可以模拟几乎静态文本的所有特性。除了静态文本精确的单个字符的位置，如果不考虑实现难度和版本兼容性的话。动态文本还有很多静态文本没有的格式化功能。丰富的格式化功能由HTML的一个子集支持。</p>\n\n<p>静态文本通过DefineText定义。动态文本通过DefineEditText定义。这两个标签都可以引用DefineFont或者DefineFont2来获取字符来源。DefineEditText使用DefineFont2，而不是DefineFont。DefineText既可以使用DefineFont也可以使用DefineFont2。</p>\n\n<p>DefineEditText提供了一个标记，来指明使用字型文本还是设备文本(译者注：如果有谁知道这个标记请告诉我，我没找到)，而DefineText并没有。这意味着在静态文本中，SWF没办法指明使用字型文本还是设备文本。这个问题由运行时标记解决。一般情况下，所有静态文本都使用字型文本。当FP插件被嵌入到HTML页面中，一个叫devicefont的HTML标签选项会让FP把所有静态文本都渲染成设备文本。字型文本作为后备。DefineEditText能够指明使用静态文本还是字型文本的能力是被认为好于DefineText的另一个原因。</p>\n\n<h1 id=\"字型文本\">字型文本</h1>\n\n<h2 id=\"字型定义\">字型定义</h2>\n\n<p>字型是在一个称为EMSquare的标准坐标空间里定义的。相同的字型集合被用于每一个给定的字体大小。为了以不同的大小渲染字型，FP通过把EM坐标缩放到点阵坐标。</p>\n\n<p><img src=\"/assets/glyphdefinitions.png\" alt=\"glyphdef\" /></p>\n\n<p>字型字体－不使用高级文本渲染引擎－没有包含任何提高小字体可读性的提示信息。然而反锯齿会很好的提高缩小字体的可读性。即使在12点的大小时(看作100％)，字型文本还是易读的。12点或更低，在渲染可读文本时，建议采用高级反锯齿。这样小字体也会有很好的可读性，并且还会包含额外字体元信息来提高渲染效果。</p>\n\n<p>TTF可以很好的转为SWF字型。一个简单的算法是使用Quadratic Bezier 曲线替换Quadratic B－splines。</p>\n\n<p>例子：</p>\n\n<p>左边是TTF中Arial的字符b的字型。它是由弯曲的和直线的边组成。方块指示的是on-curve点，x指示的是off-curve点。黑圈是字型的参考点。蓝色边框线指示的是字型的轮廓。</p>\n\n<h2 id=\"em-square\">EM Square</h2>\n\n<p>EMSquare 是想象的空间，用于字型大小和对齐。EMSquare足够大，包含了所有字型，包括重音字型。包括字体的上部，下部，还有一些额外空间来避免文本线的冲突。</p>\n\n<p><img src=\"/assets/emsquare.png\" alt=\"emsquare\" /></p>\n\n<p>SWF字型是在1024＊1024的空间中定义的。其它来源的字型(如TTF)会有不同的EMSquare。为了使用这些字型，应该缩放到1024大小。</p>\n\n<h2 id=\"把ttf转换为swf字型\">把TTF转换为SWF字型</h2>\n\n<p>TTF字型是使用Quadratic B－Splines定义的，这可以很容易的转换为SWF字型的Quadratic Bezier曲线。</p>\n\n<p>一个TTF B－splines是由一个on-curve点和很多off-curve点，再跟着一个on-curve点组成的。两个off-curve点的中点保证在曲线上。SWF的Bezier曲线是由一个on-curve点和一个off-curve点，再跟一个on-curve点组成。</p>\n\n<p>从TTF到SWF曲线的转换就是在两个off-curve点的中点插入一个on-curve点。</p>\n\n<p>例子：</p>\n\n<p>下面是4个点的B－splines，P0和P3是on-curve点，P1和P2是连续的off-curve点。</p>\n\n<p><img src=\"/assets/bsplines.png\" alt=\"bsplines\" /></p>\n\n<p>这个曲线可以由两个Bezier曲线组成，在P1和P2的中点插入M，结果就是两个Bezier曲线，P0P1M和MP2P3。</p>\n\n<p>完整的转换过程描述如下：</p>\n\n<p>1，Y坐标反向（TTF中Y向上，SWF中Y向下）\n <br />2，把TTF中EMSquare坐标缩放到SWFEMSquare坐标中。\n <br />3，在每对off-curve的中点插入on-curve点。</p>\n\n<h2 id=\"字距和差值信息\">字距和差值信息</h2>\n\n<p>字距指的是两个字型之间的水平距离。有些字体系统在每个字体定义时都存储了字距信息。SWF文件存储的是每个字型实例(字型文本块的每个字符)的字距信息。这样称为差值。</p>\n\n<p><img src=\"/assets/kerning.png\" alt=\"kerning\" /></p>\n\n<p>在前面的例子里，A字型和V字型重叠了。这种情况下，差值要比A的宽度窄。</p>\n\n<h2 id=\"高级文本渲染引擎\">高级文本渲染引擎</h2>\n\n<p>字型可以使用普通的FP渲染器渲染，或者在SWF8之后，使用高级文本渲染引擎渲染。</p>\n\n<p>高级文本渲染引擎是一种在FP渲染器里的高质量文本渲染器。对于文本来说，这个高级系统相对一般的渲染器有如下优势：</p>\n\n<ul>\n <li>即使小字体也可读\n  <br /></li>\n <li>即使小字体看起来也美观\n  <br /></li>\n <li>对于非常清晰的文本(左对齐的动态文本)支持像素对齐\n  <br /></li>\n <li>提高了字型字体的性能\n  <br /></li>\n <li>支持液晶屏幕的子像素渲染</li></ul>\n\n<p>高级文本渲染引擎的一个局限是，它没有字型文本那样的动画效果。</p>\n\n<p>高级文本渲染引擎使用Continuous Stroke Modulation(CSM)参数来调整表现。CSM是一种笔画粗细和边缘锐度的连续调整。CSM使用两种渲染参数：内部和外部切断。这些参数的最佳值是有很大的主观性，并且依赖于用户的喜好，照明条件，显示属性，字样，前景和背景颜色，还有大小。然而大部分情况下，可以通过一小部分内插值的方法来实现高质量效果。</p>\n\n<p>创建了高级反锯齿边缘的功能，含有外切断(在这之下，边缘不画)和内切断(在这之上，边缘不透明)。在两个切断值之间是一个线性函数，从外切断的0到内切断的最大值。</p>\n\n<p>调整内外切断的值会影响笔画粗细和边缘锐度。两个参数之间的空间是经典的反锯齿方法中的过滤半径的两倍。窄一些的空间提供了更锐利的边缘，而宽一些的空间提供了更柔和的边缘。空间是0时，生成的图像是双层图像；当空间很大时，会生成像水一样的边缘。一般的，在小字体情况下，用户喜欢锐利的，高对比度的边缘；而对于动画效果的文本和大字体，喜欢更柔和的边缘。</p>\n\n<p>外切断是负值，内切断是正值，中点一般在0左右。把中点调向负的方向，会增加笔画粗细；调向正的方向，会减少笔画粗细。外切断应该永远小于等于内切断。</p>\n\n<p>FP创建了一个CSM的表格，为每个高级反锯齿字体提供文本大小和文本颜色。这个表格提供了一个CSM设置的集合，包含了很大范围的字体大小。你还可以定义一个用户自定义的表格，来代替默认值，使用AS的函数，setAdvancedAntiAliasingTable()</p>\n\n<h2 id=\"definefont-和-definetext\">DefineFont 和 DefineText</h2>\n\n<p>在SWF文件格式支持的四种文本类型中，最复杂的是静态字型文本。其它类型使用的是定义静态字型文本的简单变形。</p>\n\n<p>静态字型文本使用两个TAG定义：</p>\n\n<ul>\n <li>DefineFont定义字型集合\n  <br /></li>\n <li>DefineText定义使用那个字体显示的文本字符串</li></ul>\n\n<p>DefineFont标签定义了所有用户DefineText的字型。DefineFont包含了一组SHAPERECORD，描述了字型的边缘。这些SHAPERECORD同样用于DefineShape，定义的是非文本内容。为了把文件大小降到最低，只有使用的字型才会包含进来。DefineText存储的是实际要显示的文本字符串，由字型下标表示。还有文本的包围盒，转换矩阵，属性如颜色，大小。</p>\n\n<p>DefineText包含了一组TEXTRECORD。TEXTRECORD记录了字体，颜色，大小，还有下一个字符的XY坐标。这个类型会应用到接下来的所有字符，直到另一个TEXTRECORD出现。TEXTRECORD还包含一组下标，引用了当前字体的字型表。字符不是由字符编码引用，而是由字型表的下标引用。字型数据还包含文本中每个字符的差值。</p>\n\n<h2 id=\"静态字型文本举例\">静态字型文本举例</h2>\n\n<p>考虑一下使用24大小，以Arial字体显示bob。</p>\n\n<p>首先使用DefineFont定义字型。字型表有两个SHAPERECORD。0位置是小写B的形状，1位置是小写o的形状。(第二个b重复了，不需要再定义)DefineFont还包括一个唯一ID，接下来的DefineText可以引用。</p>\n\n<p>第二，使用DefineText定义文本。TEXTRECORD设置第一个字符的位置，选择Arial字体，设置大小为24，这样字体被缩放到正确大小。(字型是在EMSquare坐标系中定义的，大小是DefineText的一部分)还包含一组GLYPHENTRY。每一个GLYPHENTRY都引用字体形状数组的一个下标。在这个例子里，第一个GLYPHENTRY引用下标0(对应字符b)，第二个引用下标1(o)，第三个引用下标0(b)。每个GLYPHENTRY还包含差值来精确定位字型的位置。</p>\n\n<p>下面的图描述了DefineText如何与DefineFont交互。</p>\n\n<p><img src=\"/assets/definetextfont.png\" alt=\"definetextfont\" /></p>\n\n<h1 id=\"字体标签\">字体标签</h1>\n\n<h2 id=\"definefont\">DefineFont</h2>\n\n<p>DefineFont定义了特定字体的每个字型的边框形状。只有在DefineText中使用的字型才会被定义。DefineFont不能用于动态文本。动态文本需要DefineFont2。</p>\n\n<p>最低文件版本是SWF1。</p>\n\n<p><img src=\"/assets/definefont.png\" alt=\"definefont\" /></p>\n\n<p>字体ID唯一标识了这个字体。可以用于DefineText引用。在SWF文件中字体ID也必须唯一。</p>\n\n<p>如果DefineFontInfo和DefineFont一起的话，要注意DefineFont中的字型顺序要和DefineFontInfo中的字符顺序一致，以字符码排序。OffsetTable和GlyphShapeTable一起使用。这两个表有相同数量的条目，offsets中的顺序和shape中的顺序，一一对应。OffsetTable指定了在GlyphShapeTable中的位置。每一个Offset条目存储的是offset table开始到相应shape的差值(BYTES)。因为GlyphShapeTable与OffsetTable相邻，那么每个表格中的条目数量(字体定义的字型数目)可以通过offsettable中的第一个条目除以2得到（译者注：读者可以自己计算一下，提示：offsetTable中条目的类型。如果不懂，可以联系译者）。</p>\n\n<p>在GlyphShapeTable中的每一个SHAPE的第一个STYLECHANGERECORD不使用LineStyle和LineStyles字段。这种情况下，这两个字段都被设为1。</p>\n\n<h2 id=\"definefontinfo\">DefineFontInfo</h2>\n\n<p>DefineFontInfo定义的是字型字体到设备字体的一个映射。提供了一个字体名和样式，传到平台的文本的渲染引擎，还有一个字符编码表格指定了相应字体的字型，这样可以把DefineText的字型下标转换为字符串。</p>\n\n<p>DefineFontInfo并不会强制把字型文本转换为设备文本。它仅仅是可以这样做。实际是根据devicefont的值或者DefineText中的UseOutlines的值来决定。如果设备字体不可用，FP会继续用字型字体。</p>\n\n<p>最低版本要求是SWF1。</p>\n\n<div class=\"figure\"><img src=\"/assets/definefontinfo1.png\" alt=\"definefontinfo\" />\n <p class=\"caption\">definefontinfo</p></div>\n\n<p><img src=\"/assets/definefontinfo2.png\" alt=\"definefontinfo\" /></p>\n\n<p>CodeTable中的条目必须是字码的升序排序。同时CodeTable中条目的顺序必须和引用的DefineFont中的字型顺序一致。这也要求DefineFont中的字型顺序要保持一致。</p>\n\n<p>SWF6和之后的文件中的文本都要求Unicode文本编码。这样所有的字符编码表都用的是UCS－2(UCS－2是第一个UTF－16的64K字符码)。这种编码为每个字符使用固定2字节大小。这就是说，如果DefineFontInfo出现在SWF6或之后的文件中，那么FontFlagsWideCodes一定被设为1，FontFlagsShiftJIS和FontFlagsANSI一定设为0，CodeTable一定使用的是UI16的UCS－2的编码组成。</p>\n\n<p>另外一点是在SWF6和之后的文件中，字体名一定是用UTF8编码的。在SWF5或之前，文件名是以平台特定的方式编码的，使用系统的码页。平台会使用当前的码页来显示，这样导致不一样的平台之间的显示不一样。如果平台是ANSI系统，字体名称就是ANSI字符串。如果平台是日本的Shift－JIS系统，字体名就会被翻译为Shift－JIS字符串。还有很多其他平台的码页。这种本地依赖非常不好，这也是为什么SWF6转向了统一编码。需要注意的是DefineFontInfo中的字体名不是空字符串结尾的。而是通过FontNameLen来定义长度的。FontNameLen指定了FontName需要的字节数，这不一定要和字符数量一致，因为有些编码，每个字符会使用多于1个字节。</p>\n\n<p>字体名是逐字使用的，直接传入平台的字体系统，定位字体。然而有很多特殊的间接字体名是,根据不同平台映射到不同的字体的。这些间接映射是硬编码到平台特定的FP中的，这些字体是在平台默认字体和最可用字体之间选择的。或者这样考虑，间接映射是为了让所有平台看起来尽可能一致。</p>\n\n<p>下面的表就是支持的间接映射字体名。</p>\n\n<p><img src=\"/assets/westernfonts.png\" alt=\"western\" />\n <br /><img src=\"/assets/japanesefonts.png\" alt=\"japanese\" /></p>\n\n<h2 id=\"definefontinfo2\">DefineFontInfo2</h2>\n\n<p>当生成SWF6或之后的文件时，建议使用DefineFontInfo2，而不是DefineFontInfo。DefineFontInfo2和DefineFontInfo是一样的，除了它增加了一个language code字段。如果使用DefineFontInfo，这个字段被认为是0，这将会导致，平台不一样，表现不一样。</p>\n\n<p>最小的版本要求是SWF6。</p>\n\n<p><img src=\"/assets/definefontinfo22.png\" alt=\"definefontinf2\" /></p>\n\n<h2 id=\"definefont2\">DefineFont2</h2>\n\n<p>DefineFont2扩展了DefineFont功能。包括：</p>\n\n<ul>\n <li>OffsetTable中32位的条目，可以有多于64K的字型字体。\n  <br /></li>\n <li>合并DefineFontInfo的功能，映射到设备字体。\n  <br /></li>\n <li>提高了动态文本的字体规格。</li></ul>\n\n<p>DefineFont2是唯一能用于动态文本的标签。</p>\n\n<p>最小的版本要求是SWF3。</p>\n\n<p><img src=\"/assets/definefont21.png\" alt=\"definefont2\" />\n <br /><img src=\"/assets/definefont22.png\" alt=\"definefont2\" />\n <br /><img src=\"/assets/definefont23.png\" alt=\"definefont2\" />\n <br /><img src=\"/assets/definefont24.png\" alt=\"definefont2\" /></p>\n\n<p>在SWF6和之后的文件中，DefineFont2和DefineFontInfo一样，要求Unicode。CodeTable(还有OffsetTable，GlyphTable， FontAdvanceTable)必须以字码顺序排序。如果DefineFont2仅仅用于动态文本，并且也不需要字型渲染，那么NumGlyphs被设置为0，并且忽略所有相关条目。这样会减少DefineFont2的大小。没有字型的DefineFont2不能够显示静态文本(需要字型索引)和字型文本(需要字型形状定义)。</p>\n\n<p>布局信息(ascent, descent, leading, advance table, bounds table, kerning table)仅仅对动态文本有用。此信息代替了用于静态字型文本的每个字符的布局信息。DefineFont2中的布局信息是相当标准的字体规格信息，可以从标准的字体定义中抽取，如TTF。</p>\n\n<p>就像在DefineFont里一样，DefineFont2里每个SHAPE的第一个STYLECHANGERECORD也不使用LineStyle和LineStyles字段，并且也被设置为1。</p>\n\n<p>DefeinFont2还保留了字体边框表和字距表。这些信息在FP7之后就不用了，但是必须被保留下来，为了DefineFont2的一致性。为FontBoundTable提供一个最小的RECT，把KerningCount永远设置为0，这样可以忽略掉FontKerningTable。</p>\n\n<h2 id=\"definefont3\">DefineFont3</h2>\n\n<p>DefineFont3是和DefineFontAlignZones一起在SWF8中引入的。当使用高级反锯齿功能时，DefineFontAlignZones是可选的，但是推荐使用；它会修改DefineFont3的行为。</p>\n\n<p>DefineFont3扩展了DefineFont2的功能，通过把GlyphShapeTable中的SHAPE坐标提高20倍。所有的EMSquare坐标在导出时，都乘以20，这样就可以精确到1/20个单位。这可以定义更精确的字型，有更好的可视效果。</p>\n\n<p>最低的版本要求是SWF8。</p>\n\n<p><img src=\"/assets/definefont31.png\" alt=\"definefont3\" />\n <br /><img src=\"/assets/definefont32.png\" alt=\"definefont3\" />  <img src=\"/assets/definefont33.png\" alt=\"definefont3\" />  <img src=\"/assets/definefont34.png\" alt=\"definefont3\" /></p>\n\n<h2 id=\"definefontalignzones\">DefineFontAlignZones</h2>\n\n<p>DefineFongAlignZones可以修改DefineFont3。高级文本渲染引擎使用alignment zones来建立字型边界，实现像素对齐。alignment zones对于高质量的字体很重要。</p>\n\n<p>Alignment Zones为每个有很强横竖感的字型都定义了一个包围盒。盒子是通过x坐标，粗细，y坐标，高度描述的。高度或粗细很小时，被设置为0。</p>\n\n<p>例如考虑一下字母I。</p>\n\n<p><img src=\"/assets/definefontalignzonesi.png\" alt=\"I\" /></p>\n\n<p>I在底部和顶部有很强烈的水平感。在主干的边缘，而不是在条形顶部或者衬线上，有很强烈的垂直感。在字母中心块上的强烈横竖感，决定了alignment zones。</p>\n\n<p>最低的版本要求是SWF8。</p>\n\n<p><img src=\"/assets/definefontalignmentzones.png\" alt=\"definefontalignmentzones\" />\n <br /><img src=\"/assets/zonerecord.png\" alt=\"zonerecord\" />\n <br /><img src=\"/assets/zonedata.png\" alt=\"zonedata\" /></p>\n\n<h3 id=\"kerning-record\">Kerning Record</h3>\n\n<p>Kerning Record定义的是在EMSquare坐标系中，两个字型的距离。某对字型更近或更远的话，看起来会更美观。FontKerningCode1和FontKerningCode2是两边的字符编码。FontKerningAdjustment字段有符号的整数，会加在左边字符的差值上。</p>\n\n<p><img src=\"/assets/kerningrecord.png\" alt=\"kerningrecord\" /></p>\n\n<h2 id=\"definefontname\">DefineFontName</h2>\n\n<p>DefineFontName包含了嵌入在SWF文件里的字体名和版权信息。</p>\n\n<p>最低的版本要求是SWF9。</p>\n\n<p><img src=\"/assets/definefontname1.png\" alt=\"definefontname\" />\n <br /><img src=\"/assets/definefontname2.png\" alt=\"definefontname\" /></p>\n\n<h1 id=\"静态文本标签\">静态文本标签</h1>\n\n<h2 id=\"definetext\">DefineText</h2>\n\n<p>DefineText定义了一块静态文本。描述了字体，大小，颜色和每个字符的精确位置。</p>\n\n<p>最低的版本要求是SWF1。</p>\n\n<p><img src=\"/assets/definetext.png\" alt=\"definetext\" /></p>\n\n<p>TextBounds字段是一个矩形区域，包含了这个文本块的所有字符。</p>\n\n<p>GlyphBits和AdvanceBits定义了用于GlyphIndex和GlyhAdvance字段(GLYPHRECORD中的条目里的)的位数。</p>\n\n<h3 id=\"textrecord\">TextRecord</h3>\n\n<p>一个TEXTRECORD指定了接下来的文本样式。可以被用于选择字体，改变字体颜色，改变大小，插入换行，或者设置下一个字符的XY坐标。直到下一个TEXTRECORD出现。</p>\n\n<p>TEXTRECORD还定义了文本的所有字符。字符是通过索引到当前字体的字型表，而不是字符编码。每一个TEXTRECORD都包含一组字符，共享相同的样式，并且在同一行上。</p>\n\n<p><img src=\"/assets/textrecord.png\" alt=\"textrecord\" /></p>\n\n<p>FondID字段用于选择前面定义的字体。唯一标识DefineFont或者DefineFont2的ID。</p>\n\n<p>TextHeight字段定义了字体的高度，用TWIPS单位。如50像素就是TextHeight＝1000。</p>\n\n<p>XOffset字段定义了文本框矩形左边到字型引用点(EMSquare中第一个曲线段偏离的点)的偏移。一般引用点都在底部，接近字型的左边(参看GlyphText的例子)。XOffset一般用来创建缩进文本或者非左对齐文本。如果没有指定XOffset，那就默认0。</p>\n\n<p>YOffset字段定义了文本矩形上边到字型引用点的偏移。这个字段一般用于插入断行，把文本移动到新行的开始。</p>\n\n<p>GlyphCount字段定义了字符个数，还有GLYPHENTRY表格的大小。</p>\n\n<h3 id=\"glyphentry\">GlyphEntry</h3>\n\n<p>GlyphEntry描述的是单个字符，由一个引用到当前字体字型表的索引和差值组成。差值就是当前字符引用点到下一个字符引用点的水平距离。</p>\n\n<p><img src=\"/assets/glyphentry.png\" alt=\"glyphentry\" /></p>\n\n<h2 id=\"definetext2\">DefineText2</h2>\n\n<p>DefineText2几乎和DefineText是一样的。唯一的区别是在DefineText2中的TEXTRECORD使用RGBA来定义字体颜色。这可以产生半透明甚至全透明的字符。</p>\n\n<p>由DefineText2定义的文本永远使用字型渲染。设备文本永远不包含透明性。</p>\n\n<p>最小的版本要求是SWF3。</p>\n\n<p><img src=\"/assets/definetext21.png\" alt=\"definetext2\" />\n <br /><img src=\"/assets/definetext22.png\" alt=\"definetext2\" /></p>\n\n<h1 id=\"动态文本标签\">动态文本标签</h1>\n\n<h2 id=\"defineedittext\">DefineEditText</h2>\n\n<p>DefineEditText定义的是动态文本对象，或者文本域。</p>\n\n<p>文本域和AS里的变量名关联在一起。可以读写变量内容，并且和显示保持一致。如果ReadOnly没有设置，那么用户就可以交互的修改内容。</p>\n\n<p>这里使用的字体一定是DefineFont2定义的，而不能是DefineFont。</p>\n\n<p>最低的版本要求是SWF4。</p>\n\n<p><img src=\"/assets/defineedittext1.png\" alt=\"defineedittext\" />\n <br /><img src=\"/assets/defineedittext2.png\" alt=\"defineedittext\" />\n <br /><img src=\"/assets/defineedittext3.png\" alt=\"defineedittext\" />\n <br /><img src=\"/assets/defineedittext4.png\" alt=\"defineedittext\" />\n <br /><img src=\"/assets/defineedittext5.png\" alt=\"defineedittext\" /></p>\n\n<p>如果HTML字段设置了，InitialText的内容就会被解释为HTML的一个子集。下面是所有支持的标签。</p>\n\n<p><img src=\"/assets/html1.png\" alt=\"html\" />\n <br /><img src=\"/assets/html2.png\" alt=\"html\" /></p>\n\n<h2 id=\"csmtextsettings\">CSMTextSettings</h2>\n\n<p>除了高级文本渲染，渲染引擎还支持修改文本域的标签。CSMTextSetting会修改前面的DefineText，DefineText2，DefineEditText。CSMTextSettings可以打开或者关闭文本域的反锯齿，还可以用于定义quality和option。</p>\n\n<p>最低的版本要求是SWF8。</p>\n\n<p><img src=\"/assets/csmtextsettings1.png\" alt=\"csmtextsetting\" />\n <br /><img src=\"/assets/csmtextsettings2.png\" alt=\"csmtextsetting\" />\n <br /><img src=\"/assets/csmtextsettings3.png\" alt=\"csmtextsetting\" /></p>\n\n<p>粗细和锐度字段会应用到特定文本域，这会覆盖那个文本域的默认值。</p>\n\n<p>在渲染时，通过如下方式计算：</p>\n\n<p><img src=\"/assets/csmtextsettingcalc.png\" alt=\"csmtextsettingcalc\" /></p>\n\n<p>计算时使用字体大小会生成更加线性的缩放效果，并且进行很明显的文本缩放时，线性缩放会生成不好的近似效果。进行文本缩放时最好使用默认表格作为反锯齿表格。</p>") #f (u . "\n<p>SWF8支持很多渲染文本的方法。在SWF6之后，所有的文本都使用Unicode编码，避免了文本和字符串在不同地区之间的区别。提醒一下，尽管FP是完全支持Unicode的，但是它仅仅支持从左到右的简单文本，还不支持Hebrew，Arabic，Thai等其它复杂的文本。</p>\n\n<h1 id=\"字型文本和设备文本\">字型文本和设备文本</h1>\n\n<p>SWF支持两种文本类型：字型文本和设备文本。字型文本通过在SWF中嵌入字符形状实现，设备文本使用的是各自平台的文本渲染功能。</p>\n\n<p>字型文本在所有平台上看起来都一样。并且可以使用标准反锯齿功能。在SWF8之后，也可以使用高级文本渲染引擎实现。相对设备文本，使用字型文本会让生成的SWF文件更大，尤其是在一个很大的字符集里使用了很多字符。</p>\n\n<p>设备字体由操作系统本身实现反锯齿效果，不同平台表现不一样。有两种方式指定设备文本：通过字体名称在系统中查找，或使用一个特殊的字体名称，映射到系统的高可用字体，尽量选择相近的字体。</p>\n\n<p>字型文本字符通过DefineFont，DefineFont2，DefineFont3定义。设备文本字体通过DefineFont和DefineFontInfo一起定义，或者直接通过DefineFont2定义。定义设备文本字体的DefineFont2，如果用于动态文本的话，不需要包含任何字符图像。DefineFont和DefineFont2标签可以同时为某些文本提供字型文本支持，并且为其它文本提供设备文本支持，只要提供了图像和字符编码。</p>\n\n<h1 id=\"静态文本和动态文本\">静态文本和动态文本</h1>\n\n<p>文本可以被定义为静态的，或者在SWF4之后，动态的。动态文本可以在运行时改变，并且还可以编辑。动态文本可以模拟几乎静态文本的所有特性。除了静态文本精确的单个字符的位置，如果不考虑实现难度和版本兼容性的话。动态文本还有很多静态文本没有的格式化功能。丰富的格式化功能由HTML的一个子集支持。</p>\n\n<p>静态文本通过DefineText定义。动态文本通过DefineEditText定义。这两个标签都可以引用DefineFont或者DefineFont2来获取字符来源。DefineEditText使用DefineFont2，而不是DefineFont。DefineText既可以使用DefineFont也可以使用DefineFont2。</p>\n\n<p>DefineEditText提供了一个标记，来指明使用字型文本还是设备文本(译者注：如果有谁知道这个标记请告诉我，我没找到)，而DefineText并没有。这意味着在静态文本中，SWF没办法指明使用字型文本还是设备文本。这个问题由运行时标记解决。一般情况下，所有静态文本都使用字型文本。当FP插件被嵌入到HTML页面中，一个叫devicefont的HTML标签选项会让FP把所有静态文本都渲染成设备文本。字型文本作为后备。DefineEditText能够指明使用静态文本还是字型文本的能力是被认为好于DefineText的另一个原因。</p>\n\n<h1 id=\"字型文本\">字型文本</h1>\n\n<h2 id=\"字型定义\">字型定义</h2>\n\n<p>字型是在一个称为EMSquare的标准坐标空间里定义的。相同的字型集合被用于每一个给定的字体大小。为了以不同的大小渲染字型，FP通过把EM坐标缩放到点阵坐标。</p>\n\n<p><img src=\"/assets/glyphdefinitions.png\" alt=\"glyphdef\" /></p>\n\n<p>字型字体－不使用高级文本渲染引擎－没有包含任何提高小字体可读性的提示信息。然而反锯齿会很好的提高缩小字体的可读性。即使在12点的大小时(看作100％)，字型文本还是易读的。12点或更低，在渲染可读文本时，建议采用高级反锯齿。这样小字体也会有很好的可读性，并且还会包含额外字体元信息来提高渲染效果。</p>\n\n<p>TTF可以很好的转为SWF字型。一个简单的算法是使用Quadratic Bezier 曲线替换Quadratic B－splines。</p>\n\n<p>例子：</p>\n\n<p>左边是TTF中Arial的字符b的字型。它是由弯曲的和直线的边组成。方块指示的是on-curve点，x指示的是off-curve点。黑圈是字型的参考点。蓝色边框线指示的是字型的轮廓。</p>\n\n<h2 id=\"em-square\">EM Square</h2>\n\n<p>EMSquare 是想象的空间，用于字型大小和对齐。EMSquare足够大，包含了所有字型，包括重音字型。包括字体的上部，下部，还有一些额外空间来避免文本线的冲突。</p>\n\n<p><img src=\"/assets/emsquare.png\" alt=\"emsquare\" /></p>\n\n<p>SWF字型是在1024＊1024的空间中定义的。其它来源的字型(如TTF)会有不同的EMSquare。为了使用这些字型，应该缩放到1024大小。</p>\n\n<h2 id=\"把ttf转换为swf字型\">把TTF转换为SWF字型</h2>\n\n<p>TTF字型是使用Quadratic B－Splines定义的，这可以很容易的转换为SWF字型的Quadratic Bezier曲线。</p>\n\n<p>一个TTF B－splines是由一个on-curve点和很多off-curve点，再跟着一个on-curve点组成的。两个off-curve点的中点保证在曲线上。SWF的Bezier曲线是由一个on-curve点和一个off-curve点，再跟一个on-curve点组成。</p>\n\n<p>从TTF到SWF曲线的转换就是在两个off-curve点的中点插入一个on-curve点。</p>\n\n<p>例子：</p>\n\n<p>下面是4个点的B－splines，P0和P3是on-curve点，P1和P2是连续的off-curve点。</p>\n\n<p><img src=\"/assets/bsplines.png\" alt=\"bsplines\" /></p>\n\n<p>这个曲线可以由两个Bezier曲线组成，在P1和P2的中点插入M，结果就是两个Bezier曲线，P0P1M和MP2P3。</p>\n\n<p>完整的转换过程描述如下：</p>\n\n<p>1，Y坐标反向（TTF中Y向上，SWF中Y向下）\n <br />2，把TTF中EMSquare坐标缩放到SWFEMSquare坐标中。\n <br />3，在每对off-curve的中点插入on-curve点。</p>\n\n<h2 id=\"字距和差值信息\">字距和差值信息</h2>\n\n<p>字距指的是两个字型之间的水平距离。有些字体系统在每个字体定义时都存储了字距信息。SWF文件存储的是每个字型实例(字型文本块的每个字符)的字距信息。这样称为差值。</p>\n\n<p><img src=\"/assets/kerning.png\" alt=\"kerning\" /></p>\n\n<p>在前面的例子里，A字型和V字型重叠了。这种情况下，差值要比A的宽度窄。</p>\n\n<h2 id=\"高级文本渲染引擎\">高级文本渲染引擎</h2>\n\n<p>字型可以使用普通的FP渲染器渲染，或者在SWF8之后，使用高级文本渲染引擎渲染。</p>\n\n<p>高级文本渲染引擎是一种在FP渲染器里的高质量文本渲染器。对于文本来说，这个高级系统相对一般的渲染器有如下优势：</p>\n\n<ul>\n <li>即使小字体也可读\n  <br /></li>\n <li>即使小字体看起来也美观\n  <br /></li>\n <li>对于非常清晰的文本(左对齐的动态文本)支持像素对齐\n  <br /></li>\n <li>提高了字型字体的性能\n  <br /></li>\n <li>支持液晶屏幕的子像素渲染</li></ul>\n\n<p>高级文本渲染引擎的一个局限是，它没有字型文本那样的动画效果。</p>\n\n<p>高级文本渲染引擎使用Continuous Stroke Modulation(CSM)参数来调整表现。CSM是一种笔画粗细和边缘锐度的连续调整。CSM使用两种渲染参数：内部和外部切断。这些参数的最佳值是有很大的主观性，并且依赖于用户的喜好，照明条件，显示属性，字样，前景和背景颜色，还有大小。然而大部分情况下，可以通过一小部分内插值的方法来实现高质量效果。</p>\n\n<p>创建了高级反锯齿边缘的功能，含有外切断(在这之下，边缘不画)和内切断(在这之上，边缘不透明)。在两个切断值之间是一个线性函数，从外切断的0到内切断的最大值。</p>\n\n<p>调整内外切断的值会影响笔画粗细和边缘锐度。两个参数之间的空间是经典的反锯齿方法中的过滤半径的两倍。窄一些的空间提供了更锐利的边缘，而宽一些的空间提供了更柔和的边缘。空间是0时，生成的图像是双层图像；当空间很大时，会生成像水一样的边缘。一般的，在小字体情况下，用户喜欢锐利的，高对比度的边缘；而对于动画效果的文本和大字体，喜欢更柔和的边缘。</p>\n\n<p>外切断是负值，内切断是正值，中点一般在0左右。把中点调向负的方向，会增加笔画粗细；调向正的方向，会减少笔画粗细。外切断应该永远小于等于内切断。</p>\n\n<p>FP创建了一个CSM的表格，为每个高级反锯齿字体提供文本大小和文本颜色。这个表格提供了一个CSM设置的集合，包含了很大范围的字体大小。你还可以定义一个用户自定义的表格，来代替默认值，使用AS的函数，setAdvancedAntiAliasingTable()</p>\n\n<h2 id=\"definefont-和-definetext\">DefineFont 和 DefineText</h2>\n\n<p>在SWF文件格式支持的四种文本类型中，最复杂的是静态字型文本。其它类型使用的是定义静态字型文本的简单变形。</p>\n\n<p>静态字型文本使用两个TAG定义：</p>\n\n<ul>\n <li>DefineFont定义字型集合\n  <br /></li>\n <li>DefineText定义使用那个字体显示的文本字符串</li></ul>\n\n<p>DefineFont标签定义了所有用户DefineText的字型。DefineFont包含了一组SHAPERECORD，描述了字型的边缘。这些SHAPERECORD同样用于DefineShape，定义的是非文本内容。为了把文件大小降到最低，只有使用的字型才会包含进来。DefineText存储的是实际要显示的文本字符串，由字型下标表示。还有文本的包围盒，转换矩阵，属性如颜色，大小。</p>\n\n<p>DefineText包含了一组TEXTRECORD。TEXTRECORD记录了字体，颜色，大小，还有下一个字符的XY坐标。这个类型会应用到接下来的所有字符，直到另一个TEXTRECORD出现。TEXTRECORD还包含一组下标，引用了当前字体的字型表。字符不是由字符编码引用，而是由字型表的下标引用。字型数据还包含文本中每个字符的差值。</p>\n\n<h2 id=\"静态字型文本举例\">静态字型文本举例</h2>\n\n<p>考虑一下使用24大小，以Arial字体显示bob。</p>\n\n<p>首先使用DefineFont定义字型。字型表有两个SHAPERECORD。0位置是小写B的形状，1位置是小写o的形状。(第二个b重复了，不需要再定义)DefineFont还包括一个唯一ID，接下来的DefineText可以引用。</p>\n\n<p>第二，使用DefineText定义文本。TEXTRECORD设置第一个字符的位置，选择Arial字体，设置大小为24，这样字体被缩放到正确大小。(字型是在EMSquare坐标系中定义的，大小是DefineText的一部分)还包含一组GLYPHENTRY。每一个GLYPHENTRY都引用字体形状数组的一个下标。在这个例子里，第一个GLYPHENTRY引用下标0(对应字符b)，第二个引用下标1(o)，第三个引用下标0(b)。每个GLYPHENTRY还包含差值来精确定位字型的位置。</p>\n\n<p>下面的图描述了DefineText如何与DefineFont交互。</p>\n\n<p><img src=\"/assets/definetextfont.png\" alt=\"definetextfont\" /></p>\n\n<h1 id=\"字体标签\">字体标签</h1>\n\n<h2 id=\"definefont\">DefineFont</h2>\n\n<p>DefineFont定义了特定字体的每个字型的边框形状。只有在DefineText中使用的字型才会被定义。DefineFont不能用于动态文本。动态文本需要DefineFont2。</p>\n\n<p>最低文件版本是SWF1。</p>\n\n<p><img src=\"/assets/definefont.png\" alt=\"definefont\" /></p>\n\n<p>字体ID唯一标识了这个字体。可以用于DefineText引用。在SWF文件中字体ID也必须唯一。</p>\n\n<p>如果DefineFontInfo和DefineFont一起的话，要注意DefineFont中的字型顺序要和DefineFontInfo中的字符顺序一致，以字符码排序。OffsetTable和GlyphShapeTable一起使用。这两个表有相同数量的条目，offsets中的顺序和shape中的顺序，一一对应。OffsetTable指定了在GlyphShapeTable中的位置。每一个Offset条目存储的是offset table开始到相应shape的差值(BYTES)。因为GlyphShapeTable与OffsetTable相邻，那么每个表格中的条目数量(字体定义的字型数目)可以通过offsettable中的第一个条目除以2得到（译者注：读者可以自己计算一下，提示：offsetTable中条目的类型。如果不懂，可以联系译者）。</p>\n\n<p>在GlyphShapeTable中的每一个SHAPE的第一个STYLECHANGERECORD不使用LineStyle和LineStyles字段。这种情况下，这两个字段都被设为1。</p>\n\n<h2 id=\"definefontinfo\">DefineFontInfo</h2>\n\n<p>DefineFontInfo定义的是字型字体到设备字体的一个映射。提供了一个字体名和样式，传到平台的文本的渲染引擎，还有一个字符编码表格指定了相应字体的字型，这样可以把DefineText的字型下标转换为字符串。</p>\n\n<p>DefineFontInfo并不会强制把字型文本转换为设备文本。它仅仅是可以这样做。实际是根据devicefont的值或者DefineText中的UseOutlines的值来决定。如果设备字体不可用，FP会继续用字型字体。</p>\n\n<p>最低版本要求是SWF1。</p>\n\n<div class=\"figure\"><img src=\"/assets/definefontinfo1.png\" alt=\"definefontinfo\" />\n <p class=\"caption\">definefontinfo</p></div>\n\n<p><img src=\"/assets/definefontinfo2.png\" alt=\"definefontinfo\" /></p>\n\n<p>CodeTable中的条目必须是字码的升序排序。同时CodeTable中条目的顺序必须和引用的DefineFont中的字型顺序一致。这也要求DefineFont中的字型顺序要保持一致。</p>\n\n<p>SWF6和之后的文件中的文本都要求Unicode文本编码。这样所有的字符编码表都用的是UCS－2(UCS－2是第一个UTF－16的64K字符码)。这种编码为每个字符使用固定2字节大小。这就是说，如果DefineFontInfo出现在SWF6或之后的文件中，那么FontFlagsWideCodes一定被设为1，FontFlagsShiftJIS和FontFlagsANSI一定设为0，CodeTable一定使用的是UI16的UCS－2的编码组成。</p>\n\n<p>另外一点是在SWF6和之后的文件中，字体名一定是用UTF8编码的。在SWF5或之前，文件名是以平台特定的方式编码的，使用系统的码页。平台会使用当前的码页来显示，这样导致不一样的平台之间的显示不一样。如果平台是ANSI系统，字体名称就是ANSI字符串。如果平台是日本的Shift－JIS系统，字体名就会被翻译为Shift－JIS字符串。还有很多其他平台的码页。这种本地依赖非常不好，这也是为什么SWF6转向了统一编码。需要注意的是DefineFontInfo中的字体名不是空字符串结尾的。而是通过FontNameLen来定义长度的。FontNameLen指定了FontName需要的字节数，这不一定要和字符数量一致，因为有些编码，每个字符会使用多于1个字节。</p>\n\n<p>字体名是逐字使用的，直接传入平台的字体系统，定位字体。然而有很多特殊的间接字体名是,根据不同平台映射到不同的字体的。这些间接映射是硬编码到平台特定的FP中的，这些字体是在平台默认字体和最可用字体之间选择的。或者这样考虑，间接映射是为了让所有平台看起来尽可能一致。</p>\n\n<p>下面的表就是支持的间接映射字体名。</p>\n\n<p><img src=\"/assets/westernfonts.png\" alt=\"western\" />\n <br /><img src=\"/assets/japanesefonts.png\" alt=\"japanese\" /></p>\n\n<h2 id=\"definefontinfo2\">DefineFontInfo2</h2>\n\n<p>当生成SWF6或之后的文件时，建议使用DefineFontInfo2，而不是DefineFontInfo。DefineFontInfo2和DefineFontInfo是一样的，除了它增加了一个language code字段。如果使用DefineFontInfo，这个字段被认为是0，这将会导致，平台不一样，表现不一样。</p>\n\n<p>最小的版本要求是SWF6。</p>\n\n<p><img src=\"/assets/definefontinfo22.png\" alt=\"definefontinf2\" /></p>\n\n<h2 id=\"definefont2\">DefineFont2</h2>\n\n<p>DefineFont2扩展了DefineFont功能。包括：</p>\n\n<ul>\n <li>OffsetTable中32位的条目，可以有多于64K的字型字体。\n  <br /></li>\n <li>合并DefineFontInfo的功能，映射到设备字体。\n  <br /></li>\n <li>提高了动态文本的字体规格。</li></ul>\n\n<p>DefineFont2是唯一能用于动态文本的标签。</p>\n\n<p>最小的版本要求是SWF3。</p>\n\n<p><img src=\"/assets/definefont21.png\" alt=\"definefont2\" />\n <br /><img src=\"/assets/definefont22.png\" alt=\"definefont2\" />\n <br /><img src=\"/assets/definefont23.png\" alt=\"definefont2\" />\n <br /><img src=\"/assets/definefont24.png\" alt=\"definefont2\" /></p>\n\n<p>在SWF6和之后的文件中，DefineFont2和DefineFontInfo一样，要求Unicode。CodeTable(还有OffsetTable，GlyphTable， FontAdvanceTable)必须以字码顺序排序。如果DefineFont2仅仅用于动态文本，并且也不需要字型渲染，那么NumGlyphs被设置为0，并且忽略所有相关条目。这样会减少DefineFont2的大小。没有字型的DefineFont2不能够显示静态文本(需要字型索引)和字型文本(需要字型形状定义)。</p>\n\n<p>布局信息(ascent, descent, leading, advance table, bounds table, kerning table)仅仅对动态文本有用。此信息代替了用于静态字型文本的每个字符的布局信息。DefineFont2中的布局信息是相当标准的字体规格信息，可以从标准的字体定义中抽取，如TTF。</p>\n\n<p>就像在DefineFont里一样，DefineFont2里每个SHAPE的第一个STYLECHANGERECORD也不使用LineStyle和LineStyles字段，并且也被设置为1。</p>\n\n<p>DefeinFont2还保留了字体边框表和字距表。这些信息在FP7之后就不用了，但是必须被保留下来，为了DefineFont2的一致性。为FontBoundTable提供一个最小的RECT，把KerningCount永远设置为0，这样可以忽略掉FontKerningTable。</p>\n\n<h2 id=\"definefont3\">DefineFont3</h2>\n\n<p>DefineFont3是和DefineFontAlignZones一起在SWF8中引入的。当使用高级反锯齿功能时，DefineFontAlignZones是可选的，但是推荐使用；它会修改DefineFont3的行为。</p>\n\n<p>DefineFont3扩展了DefineFont2的功能，通过把GlyphShapeTable中的SHAPE坐标提高20倍。所有的EMSquare坐标在导出时，都乘以20，这样就可以精确到1/20个单位。这可以定义更精确的字型，有更好的可视效果。</p>\n\n<p>最低的版本要求是SWF8。</p>\n\n<p><img src=\"/assets/definefont31.png\" alt=\"definefont3\" />\n <br /><img src=\"/assets/definefont32.png\" alt=\"definefont3\" />  <img src=\"/assets/definefont33.png\" alt=\"definefont3\" />  <img src=\"/assets/definefont34.png\" alt=\"definefont3\" /></p>\n\n<h2 id=\"definefontalignzones\">DefineFontAlignZones</h2>\n\n<p>DefineFongAlignZones可以修改DefineFont3。高级文本渲染引擎使用alignment zones来建立字型边界，实现像素对齐。alignment zones对于高质量的字体很重要。</p>\n\n<p>Alignment Zones为每个有很强横竖感的字型都定义了一个包围盒。盒子是通过x坐标，粗细，y坐标，高度描述的。高度或粗细很小时，被设置为0。</p>\n\n<p>例如考虑一下字母I。</p>\n\n<p><img src=\"/assets/definefontalignzonesi.png\" alt=\"I\" /></p>\n\n<p>I在底部和顶部有很强烈的水平感。在主干的边缘，而不是在条形顶部或者衬线上，有很强烈的垂直感。在字母中心块上的强烈横竖感，决定了alignment zones。</p>\n\n<p>最低的版本要求是SWF8。</p>\n\n<p><img src=\"/assets/definefontalignmentzones.png\" alt=\"definefontalignmentzones\" />\n <br /><img src=\"/assets/zonerecord.png\" alt=\"zonerecord\" />\n <br /><img src=\"/assets/zonedata.png\" alt=\"zonedata\" /></p>\n\n<h3 id=\"kerning-record\">Kerning Record</h3>\n\n<p>Kerning Record定义的是在EMSquare坐标系中，两个字型的距离。某对字型更近或更远的话，看起来会更美观。FontKerningCode1和FontKerningCode2是两边的字符编码。FontKerningAdjustment字段有符号的整数，会加在左边字符的差值上。</p>\n\n<p><img src=\"/assets/kerningrecord.png\" alt=\"kerningrecord\" /></p>\n\n<h2 id=\"definefontname\">DefineFontName</h2>\n\n<p>DefineFontName包含了嵌入在SWF文件里的字体名和版权信息。</p>\n\n<p>最低的版本要求是SWF9。</p>\n\n<p><img src=\"/assets/definefontname1.png\" alt=\"definefontname\" />\n <br /><img src=\"/assets/definefontname2.png\" alt=\"definefontname\" /></p>\n\n<h1 id=\"静态文本标签\">静态文本标签</h1>\n\n<h2 id=\"definetext\">DefineText</h2>\n\n<p>DefineText定义了一块静态文本。描述了字体，大小，颜色和每个字符的精确位置。</p>\n\n<p>最低的版本要求是SWF1。</p>\n\n<p><img src=\"/assets/definetext.png\" alt=\"definetext\" /></p>\n\n<p>TextBounds字段是一个矩形区域，包含了这个文本块的所有字符。</p>\n\n<p>GlyphBits和AdvanceBits定义了用于GlyphIndex和GlyhAdvance字段(GLYPHRECORD中的条目里的)的位数。</p>\n\n<h3 id=\"textrecord\">TextRecord</h3>\n\n<p>一个TEXTRECORD指定了接下来的文本样式。可以被用于选择字体，改变字体颜色，改变大小，插入换行，或者设置下一个字符的XY坐标。直到下一个TEXTRECORD出现。</p>\n\n<p>TEXTRECORD还定义了文本的所有字符。字符是通过索引到当前字体的字型表，而不是字符编码。每一个TEXTRECORD都包含一组字符，共享相同的样式，并且在同一行上。</p>\n\n<p><img src=\"/assets/textrecord.png\" alt=\"textrecord\" /></p>\n\n<p>FondID字段用于选择前面定义的字体。唯一标识DefineFont或者DefineFont2的ID。</p>\n\n<p>TextHeight字段定义了字体的高度，用TWIPS单位。如50像素就是TextHeight＝1000。</p>\n\n<p>XOffset字段定义了文本框矩形左边到字型引用点(EMSquare中第一个曲线段偏离的点)的偏移。一般引用点都在底部，接近字型的左边(参看GlyphText的例子)。XOffset一般用来创建缩进文本或者非左对齐文本。如果没有指定XOffset，那就默认0。</p>\n\n<p>YOffset字段定义了文本矩形上边到字型引用点的偏移。这个字段一般用于插入断行，把文本移动到新行的开始。</p>\n\n<p>GlyphCount字段定义了字符个数，还有GLYPHENTRY表格的大小。</p>\n\n<h3 id=\"glyphentry\">GlyphEntry</h3>\n\n<p>GlyphEntry描述的是单个字符，由一个引用到当前字体字型表的索引和差值组成。差值就是当前字符引用点到下一个字符引用点的水平距离。</p>\n\n<p><img src=\"/assets/glyphentry.png\" alt=\"glyphentry\" /></p>\n\n<h2 id=\"definetext2\">DefineText2</h2>\n\n<p>DefineText2几乎和DefineText是一样的。唯一的区别是在DefineText2中的TEXTRECORD使用RGBA来定义字体颜色。这可以产生半透明甚至全透明的字符。</p>\n\n<p>由DefineText2定义的文本永远使用字型渲染。设备文本永远不包含透明性。</p>\n\n<p>最小的版本要求是SWF3。</p>\n\n<p><img src=\"/assets/definetext21.png\" alt=\"definetext2\" />\n <br /><img src=\"/assets/definetext22.png\" alt=\"definetext2\" /></p>\n\n<h1 id=\"动态文本标签\">动态文本标签</h1>\n\n<h2 id=\"defineedittext\">DefineEditText</h2>\n\n<p>DefineEditText定义的是动态文本对象，或者文本域。</p>\n\n<p>文本域和AS里的变量名关联在一起。可以读写变量内容，并且和显示保持一致。如果ReadOnly没有设置，那么用户就可以交互的修改内容。</p>\n\n<p>这里使用的字体一定是DefineFont2定义的，而不能是DefineFont。</p>\n\n<p>最低的版本要求是SWF4。</p>\n\n<p><img src=\"/assets/defineedittext1.png\" alt=\"defineedittext\" />\n <br /><img src=\"/assets/defineedittext2.png\" alt=\"defineedittext\" />\n <br /><img src=\"/assets/defineedittext3.png\" alt=\"defineedittext\" />\n <br /><img src=\"/assets/defineedittext4.png\" alt=\"defineedittext\" />\n <br /><img src=\"/assets/defineedittext5.png\" alt=\"defineedittext\" /></p>\n\n<p>如果HTML字段设置了，InitialText的内容就会被解释为HTML的一个子集。下面是所有支持的标签。</p>\n\n<p><img src=\"/assets/html1.png\" alt=\"html\" />\n <br /><img src=\"/assets/html2.png\" alt=\"html\" /></p>\n\n<h2 id=\"csmtextsettings\">CSMTextSettings</h2>\n\n<p>除了高级文本渲染，渲染引擎还支持修改文本域的标签。CSMTextSetting会修改前面的DefineText，DefineText2，DefineEditText。CSMTextSettings可以打开或者关闭文本域的反锯齿，还可以用于定义quality和option。</p>\n\n<p>最低的版本要求是SWF8。</p>\n\n<p><img src=\"/assets/csmtextsettings1.png\" alt=\"csmtextsetting\" />\n <br /><img src=\"/assets/csmtextsettings2.png\" alt=\"csmtextsetting\" />\n <br /><img src=\"/assets/csmtextsettings3.png\" alt=\"csmtextsetting\" /></p>\n\n<p>粗细和锐度字段会应用到特定文本域，这会覆盖那个文本域的默认值。</p>\n\n<p>在渲染时，通过如下方式计算：</p>\n\n<p><img src=\"/assets/csmtextsettingcalc.png\" alt=\"csmtextsettingcalc\" /></p>\n\n<p>计算时使用字体大小会生成更加线性的缩放效果，并且进行很明显的文本缩放时，线性缩放会生成不好的近似效果。进行文本缩放时最好使用默认表格作为反锯齿表格。</p>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2013-02-06-python-cpp-embed.md" . unix) f post (u . "使用CPP扩展Python") (? . 23) 1505573760 (p+ #"/Users/zhonghua/demo/zhonghua_com/2013/02/\344\275\277\347\224\250cpp\346\211\251\345\261\225python.html" . unix) (u . "/2013/02/%E4%BD%BF%E7%94%A8cpp%E6%89%A9%E5%B1%95python.html") (u . "2013-02-06T00:00:00") (? . 22) (? . 24) () (u . "\n<p>基本需求是这样的，当</p>\n\n<pre><code>const char* p = NULL;\nif(!PyArg_ParseTuple(args, \"s\", &amp;p))\n  return NULL;</code></pre>\n\n<p>看python帮助文档，当在PyArg_ParseTuple中使用格式字符串s时，一定要传入指针的地址。 不能为该指针分配存储空间。char str[100]，这样肯定是不行的。 通过该调用，该指针就指向了一个已经存在的对象。</p>\n\n<p>于是我想，把指针，字符串地址保存起来，需要时，就可以直接输出Python虚拟机内的一个字符串了。 这样不用自己分配内存，管理内存了。 关于引用计数问题，既然是指针指向了一个已经存在的对象，理所当然的认为Python虚拟机会自己搞定引用计数问题。</p>\n\n<p>经过实践</p>\n\n<pre><code>int i = 0;\n\nstatic PyObject*\ntest_test(PyObject* self, PyObject* args)\n{\n  return Py_BuildValue(\"i\", i++);\n}\n\nconst char* ptest[10];\n\nstatic PyObject*\ntest_str(PyObject* self, PyObject* args)\n{\n  const char* p = NULL;\n  if(!PyArg_ParseTuple(args, \"s\", &amp;p))\n    return NULL;\n\n  ptest[i] = p;\n\n  Py_RETURN_NONE;\n}\n\nstatic PyObject*\ntest_flush(PyObject* self, PyObject* args)\n{\n  for(int j = 0; j &lt; 10; ++j){\n    printf(\"%d=%s\\n\", j, ptest[j]);\n  }\n  Py_RETURN_NONE;\n}\n\nstatic PyMethodDef testMethods[] = {\n  {\"test\",     test_test,       METH_VARARGS, \"hello world test\"},\n  {\"str\",      test_str,        METH_VARARGS, \"hello world test\"},\n  {\"flush\",    test_flush,      METH_VARARGS, \"hello world test\"},\n  {NULL, NULL, 0, NULL}\n};\n\nPyMODINIT_FUNC\ninittest(void)\n{\n  (void)Py_InitModule(\"test\", testMethods);\n}</code></pre>\n\n<p>上面是cpp代码</p>\n\n<pre><code>import test\n\nfor i in range(10):\n    strs = \"nihao\"+str(i)\n    test.str(strs)\n    test.test()\n\ntest.flush()    </code></pre>\n\n<p>这是测试用的py代码。</p>\n\n<p>结果证明，偶是错误的。 形式主义害死人啊。</p>\n\n<p>仔细想想，如果在这种情况下，虚拟机可以自己搞定引用计数问题， 也就是PyArg_ParseTuple(args, &ldquo;s&rdquo;, &amp;p)这段代码增加虚拟机内字符串对象的引用计数，什么时候削减该对象的引用呢？ 如果需要自己手动调用delete的话，在写代码时也不符合成对编程，也就是new/delete,malloc/free成对出现的良好习惯。 忽略strdup这个东东。</p>\n\n<p>而且文档里说，指针指向已经存在的一个对象，并没有说引用计数的问题。 而且传入一个指针就想增加引用计数，也不合情理。 如果增加引用计数，cpp代码又没有主动调用delete或者free，导致的内存泄漏，是虚拟机的责任，还是自己代码的责任？ 如果你是设计者，你会怎么简单有效暴力的解决这个问题？！</p>\n\n<p>所以告诫自己，这个地方要自己管理内存。</p>\n\n<p>=====================================================</p>\n\n<p>补充：</p>\n\n<p>PyArg_ParseTuple中的关于传递object对象的格式字符串是大写o，不是0，也不是小写o。是大写O。</p>\n\n<p>=====================================================</p>\n\n<p>同样可想而知，如果在CPP内分配了一段内存，如new char[]，通过buildvalue传递给py时，自己也要记得delete。</p>") #f (u . "\n<p>基本需求是这样的，当</p>\n\n<pre><code>const char* p = NULL;\nif(!PyArg_ParseTuple(args, \"s\", &amp;p))\n  return NULL;</code></pre>\n\n<p>看python帮助文档，当在PyArg_ParseTuple中使用格式字符串s时，一定要传入指针的地址。 不能为该指针分配存储空间。char str[100]，这样肯定是不行的。 通过该调用，该指针就指向了一个已经存在的对象。</p>\n\n<p>于是我想，把指针，字符串地址保存起来，需要时，就可以直接输出Python虚拟机内的一个字符串了。 这样不用自己分配内存，管理内存了。 关于引用计数问题，既然是指针指向了一个已经存在的对象，理所当然的认为Python虚拟机会自己搞定引用计数问题。</p>\n\n<p>经过实践</p>\n\n<pre><code>int i = 0;\n\nstatic PyObject*\ntest_test(PyObject* self, PyObject* args)\n{\n  return Py_BuildValue(\"i\", i++);\n}\n\nconst char* ptest[10];\n\nstatic PyObject*\ntest_str(PyObject* self, PyObject* args)\n{\n  const char* p = NULL;\n  if(!PyArg_ParseTuple(args, \"s\", &amp;p))\n    return NULL;\n\n  ptest[i] = p;\n\n  Py_RETURN_NONE;\n}\n\nstatic PyObject*\ntest_flush(PyObject* self, PyObject* args)\n{\n  for(int j = 0; j &lt; 10; ++j){\n    printf(\"%d=%s\\n\", j, ptest[j]);\n  }\n  Py_RETURN_NONE;\n}\n\nstatic PyMethodDef testMethods[] = {\n  {\"test\",     test_test,       METH_VARARGS, \"hello world test\"},\n  {\"str\",      test_str,        METH_VARARGS, \"hello world test\"},\n  {\"flush\",    test_flush,      METH_VARARGS, \"hello world test\"},\n  {NULL, NULL, 0, NULL}\n};\n\nPyMODINIT_FUNC\ninittest(void)\n{\n  (void)Py_InitModule(\"test\", testMethods);\n}</code></pre>\n\n<p>上面是cpp代码</p>\n\n<pre><code>import test\n\nfor i in range(10):\n    strs = \"nihao\"+str(i)\n    test.str(strs)\n    test.test()\n\ntest.flush()    </code></pre>\n\n<p>这是测试用的py代码。</p>\n\n<p>结果证明，偶是错误的。 形式主义害死人啊。</p>\n\n<p>仔细想想，如果在这种情况下，虚拟机可以自己搞定引用计数问题， 也就是PyArg_ParseTuple(args, &ldquo;s&rdquo;, &amp;p)这段代码增加虚拟机内字符串对象的引用计数，什么时候削减该对象的引用呢？ 如果需要自己手动调用delete的话，在写代码时也不符合成对编程，也就是new/delete,malloc/free成对出现的良好习惯。 忽略strdup这个东东。</p>\n\n<p>而且文档里说，指针指向已经存在的一个对象，并没有说引用计数的问题。 而且传入一个指针就想增加引用计数，也不合情理。 如果增加引用计数，cpp代码又没有主动调用delete或者free，导致的内存泄漏，是虚拟机的责任，还是自己代码的责任？ 如果你是设计者，你会怎么简单有效暴力的解决这个问题？！</p>\n\n<p>所以告诫自己，这个地方要自己管理内存。</p>\n\n<p>=====================================================</p>\n\n<p>补充：</p>\n\n<p>PyArg_ParseTuple中的关于传递object对象的格式字符串是大写o，不是0，也不是小写o。是大写O。</p>\n\n<p>=====================================================</p>\n\n<p>同样可想而知，如果在CPP内分配了一段内存，如new char[]，通过buildvalue传递给py时，自己也要记得delete。</p>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2013-03-03-founders-at-work-after-read.md" . unix) f post (u . "Founders At Work读后感") (? . 24) 1505573871 (p+ #"/Users/zhonghua/demo/zhonghua_com/2013/03/founders-at-work\350\257\273\345\220\216\346\204\237.html" . unix) (u . "/2013/03/founders-at-work%E8%AF%BB%E5%90%8E%E6%84%9F.html") (u . "2013-03-03T00:00:00") (? . 23) (? . 0) () (u . "\n<p>前段时间连续看了好几本书。 乔布斯传看了一半英文，看了一半中文。 黑客与画家看的是英文。 黑客-计算机革命的英雄看的是英文。 DOOM启世录，中文。 FoundersAtWorks，英文。</p>\n\n<p>看英文的速度还是有点慢，需要继续练习。</p>\n\n<p>YC创始人杰西卡，PG的妻子，采访了N多曾经的创业家。我看过之后，激情澎湃。 原来他们早期是这样的，而不止是一个神话般的存在。</p>\n\n<p>1.有想法就去大胆实践出来。根据实际情况调整也好，改变策略也好。最重要的是写出来上线。</p>\n\n<p>paypal最开始只是做加密，后来根据情况调整为做支付。</p>\n\n<p>以前看陈士駿的多少个月赚多少个亿，其中讲到paypal，而且还说，现在硅谷很多的创业者曾经都是paypal的同事。 当时就感觉paypal真牛X。现在更加详细的了解一些过程。</p>\n\n<p>hotmail当时也是调整过来的，做个人信息数据库，又因为个人方便，做web的邮件，之后又把这个想法作为创业点子。</p>\n\n<p>Flickr甚至是在创业写游戏的过程中，临时兴起，做的那么一个项目。 这个时候，我最喜欢一个词restless。 因为我发现，我就是特别喜欢折腾，restless。但是我少一份坚持，坚持把东西做完，上线。</p>\n\n<p>即使不是创业，在普通的学习生活中也可以使用同样的思路。 比如在工作中学习英语。不像在学校，有老师带着学习，有大把的时间，有很好的氛围。 看到有人通过美剧学习，自己也想这样。看到新东方的老师提倡背单词，虽然枯燥，也想坚持下去。 看到有人听歌学习，也想模仿。最后也不知道哪个适合自己，哪个也没做成。</p>\n\n<p>所以简单粗暴直接点，想背单词，那就坚持背下去。在这过程中，觉得怎样适合自己，再做下一步的调整。 就像创业一样，有想法，先实践出来。之后根据情况，调整。</p>\n\n<p>HotOrNot的创始人甚至在找工作的过程中，有了想法，实践出来，上线。 后来因为服务器限制，调整策略，不再允许上传图片，而是上传链接。 虽然损失了一批用户，但是保住了当时他们的站。用一句中国俗语，那就是舍卒保帅。</p>\n\n<p>比如我前端时间做的站也是最开始设计让用户自己上传文件，还做了文件大小限制。 后来调整为从别的地方抓取文件。这个策略是改了，只可惜，目前还没时间正式上线。</p>\n\n<p>2， 创业不是一定要辞职。</p>\n\n<p>网上看到很多人为了创业，在家做游戏APP，辞职。最后失败，甚至生活都一塌糊涂，都快离婚了。 并不是所有创业的人都是一门心思只能干创业的。</p>\n\n<p>Hotmail的创始人刚开始做个人信息数据库时，就是一边上班一边创业，之后调整为一个人上班，一个人全职创业。 全职创业的人有家庭需要养活，由另外一名创始人上班，然后分一部分薪酬。</p>\n\n<p>Excite(一个搜索引擎)的几个创始人聚在一起，有了想法，也是一边上班一边一点一点写自己的代码。</p>\n\n<p>所以这里可能给我们提个醒，除非你能有投资，或者一人吃饱全家不饿，只要是真正想创业的，也可以一边上班，养家糊口，一边业余时间创业。</p>\n\n<p>3， 产品一定要简单快速。</p>\n\n<p>PG在它的博客中强力推荐Lisp。他说这就是他创业成功，或者快于对手产品上线的秘密武器。 他推荐Lisp不是为了让别人转向Lisp编程，而是坚定那些Lisp学习者的信心。 而我就被坚定了信心。 我最开始接触Lisp，还是从Emacs开始。但是一直都没有深入学习。自从看了PG的文章，我开始深入学习Lisp了。</p>\n\n<p>37signals很早就成立了，之后有位哥们进入公司，做一个项目管理工程。 他原来是用php的，后来选择Ruby来开发这个工程，之后把一些公共部分提取到一个地方。 最后把这些公共部分作为一个框架发布了，就是ROR。 目标就是让人能够简单快速的开发一个应用。</p>\n\n<p>4， 不要担心自己的年龄。</p>\n\n<p>曾经我一度后悔自己的大学岁月其实可以过得更充实。 应该尝试去创业。那个时候真的是黄金岁月，没有压力，大把的时间。 后来看到Adobe创始人，准备创业时都快40了。</p>\n\n<p>看到这里，我就不能再给自己找这个接口了。</p>\n\n<p>就总结这么多吧。其实在读的过程中，读到一个词一句话一篇故事时，都是很有感触的。 只是读的过程中，有诸多限制，没法记录下当时的想法，就这样吧。</p>") #f (u . "\n<p>前段时间连续看了好几本书。 乔布斯传看了一半英文，看了一半中文。 黑客与画家看的是英文。 黑客-计算机革命的英雄看的是英文。 DOOM启世录，中文。 FoundersAtWorks，英文。</p>\n\n<p>看英文的速度还是有点慢，需要继续练习。</p>\n\n<p>YC创始人杰西卡，PG的妻子，采访了N多曾经的创业家。我看过之后，激情澎湃。 原来他们早期是这样的，而不止是一个神话般的存在。</p>\n\n<p>1.有想法就去大胆实践出来。根据实际情况调整也好，改变策略也好。最重要的是写出来上线。</p>\n\n<p>paypal最开始只是做加密，后来根据情况调整为做支付。</p>\n\n<p>以前看陈士駿的多少个月赚多少个亿，其中讲到paypal，而且还说，现在硅谷很多的创业者曾经都是paypal的同事。 当时就感觉paypal真牛X。现在更加详细的了解一些过程。</p>\n\n<p>hotmail当时也是调整过来的，做个人信息数据库，又因为个人方便，做web的邮件，之后又把这个想法作为创业点子。</p>\n\n<p>Flickr甚至是在创业写游戏的过程中，临时兴起，做的那么一个项目。 这个时候，我最喜欢一个词restless。 因为我发现，我就是特别喜欢折腾，restless。但是我少一份坚持，坚持把东西做完，上线。</p>\n\n<p>即使不是创业，在普通的学习生活中也可以使用同样的思路。 比如在工作中学习英语。不像在学校，有老师带着学习，有大把的时间，有很好的氛围。 看到有人通过美剧学习，自己也想这样。看到新东方的老师提倡背单词，虽然枯燥，也想坚持下去。 看到有人听歌学习，也想模仿。最后也不知道哪个适合自己，哪个也没做成。</p>\n\n<p>所以简单粗暴直接点，想背单词，那就坚持背下去。在这过程中，觉得怎样适合自己，再做下一步的调整。 就像创业一样，有想法，先实践出来。之后根据情况，调整。</p>\n\n<p>HotOrNot的创始人甚至在找工作的过程中，有了想法，实践出来，上线。 后来因为服务器限制，调整策略，不再允许上传图片，而是上传链接。 虽然损失了一批用户，但是保住了当时他们的站。用一句中国俗语，那就是舍卒保帅。</p>\n\n<p>比如我前端时间做的站也是最开始设计让用户自己上传文件，还做了文件大小限制。 后来调整为从别的地方抓取文件。这个策略是改了，只可惜，目前还没时间正式上线。</p>\n\n<p>2， 创业不是一定要辞职。</p>\n\n<p>网上看到很多人为了创业，在家做游戏APP，辞职。最后失败，甚至生活都一塌糊涂，都快离婚了。 并不是所有创业的人都是一门心思只能干创业的。</p>\n\n<p>Hotmail的创始人刚开始做个人信息数据库时，就是一边上班一边创业，之后调整为一个人上班，一个人全职创业。 全职创业的人有家庭需要养活，由另外一名创始人上班，然后分一部分薪酬。</p>\n\n<p>Excite(一个搜索引擎)的几个创始人聚在一起，有了想法，也是一边上班一边一点一点写自己的代码。</p>\n\n<p>所以这里可能给我们提个醒，除非你能有投资，或者一人吃饱全家不饿，只要是真正想创业的，也可以一边上班，养家糊口，一边业余时间创业。</p>\n\n<p>3， 产品一定要简单快速。</p>\n\n<p>PG在它的博客中强力推荐Lisp。他说这就是他创业成功，或者快于对手产品上线的秘密武器。 他推荐Lisp不是为了让别人转向Lisp编程，而是坚定那些Lisp学习者的信心。 而我就被坚定了信心。 我最开始接触Lisp，还是从Emacs开始。但是一直都没有深入学习。自从看了PG的文章，我开始深入学习Lisp了。</p>\n\n<p>37signals很早就成立了，之后有位哥们进入公司，做一个项目管理工程。 他原来是用php的，后来选择Ruby来开发这个工程，之后把一些公共部分提取到一个地方。 最后把这些公共部分作为一个框架发布了，就是ROR。 目标就是让人能够简单快速的开发一个应用。</p>\n\n<p>4， 不要担心自己的年龄。</p>\n\n<p>曾经我一度后悔自己的大学岁月其实可以过得更充实。 应该尝试去创业。那个时候真的是黄金岁月，没有压力，大把的时间。 后来看到Adobe创始人，准备创业时都快40了。</p>\n\n<p>看到这里，我就不能再给自己找这个接口了。</p>\n\n<p>就总结这么多吧。其实在读的过程中，读到一个词一句话一篇故事时，都是很有感触的。 只是读的过程中，有诸多限制，没法记录下当时的想法，就这样吧。</p>")) ((p+ #"/Users/zhonghua/demo/zhonghua_com/_src/posts/2017-10-11-realm-of-racket-\347\214\234\346\225\260\345\255\227.md" . unix) f post (u . "Realm Of Racket-猜数字") (? . 19) 1507702541 (p+ #"/Users/zhonghua/demo/zhonghua_com/2017/10/realm-of-racket-\347\214\234\346\225\260\345\255\227.html" . unix) (u . "/2017/10/realm-of-racket-%E7%8C%9C%E6%95%B0%E5%AD%97.html") (u . "2017-10-11T13:45:01") (? . 14) (? . 18) (c (u . "RealmOfRacket") c (u . "Lisp") c (u . "Racket")) (u . "\n<p>(A First Racket Program)</p>\n\n<p>猜数字，最简单，最古老的游戏\n <br />游戏虽然简单，但是用上了二分查找的方法</p>\n\n<p>假设数字是18，大概过程是这样</p>\n\n<pre><code>&gt;(guess)  \n50  \n&gt;(smaller)  \n25  \n&gt;(smaller))  \n12  \n&gt;(bigger)  \n18  </code></pre>\n\n<p>三个基本功能，(guess),(smaller),(bigger)</p>\n\n<p>首先定义上下边界\n <br />用define定义变量</p>\n\n<pre><code>&gt;(define lower 1)  \n&gt;lower  \n1  \n&gt;(define upper 100)  \n&gt;upper  \n100  </code></pre>\n\n<p>用define定义函数, 基本形式是</p>\n\n<pre><code>(define (function-name argument-name ...)\n  function-body-expression\n  function-body-expression\n...)</code></pre>\n\n<p>guess的定义如下</p>\n\n<pre><code>(define (guess)\n  (quotient (+ lower upper) 2))</code></pre>\n\n<p>guess函数没有参数，直接写(guess), 接下来就是取lower和upper的中间值</p>\n\n<p>smaller的定义</p>\n\n<pre><code>(define (smaller)\n  (set! upper (max lower (sub1 (guess))))\n  (guess))</code></pre>\n\n<p>set!读作set-bang，基本形式</p>\n\n<pre><code>(set! variable expression)</code></pre>\n\n<p>给variable赋值expression\n <br />smaller先算出新的upper，然后再赋值给upper，然后再展示新的(guess)值</p>\n\n<p>bigger的定义</p>\n\n<pre><code>(define (bigger)\n  (set! lower (min upper (add1 (guess))))\n  (guess))</code></pre>\n\n<p>与smaller类似，计算新的lower，然后展示新的(guess)</p>\n\n<p>main函数</p>\n\n<pre><code>(define (start n m)\n  (set! lower (min n m))\n  (set! upper (max n m))\n  (guess))</code></pre>\n\n<p>跟上面的guess对比，start有参数，(start n m)\n <br />使用min和max，参数的顺序可以任意</p>\n\n<p>假设我们猜的数字是19</p>\n\n<pre><code>&gt;(start 1 30)\n15\n&gt;(bigger))\n23\n&gt;(smaller)\n19)</code></pre>\n\n<p>总结：\n <br />1. 使用define定义变量和函数，函数区分有参数和无参数\n <br />2. 使用set!(set-bang)改变变量的值</p>") #f (u . "\n<p>(A First Racket Program)</p>\n\n<p>猜数字，最简单，最古老的游戏\n <br />游戏虽然简单，但是用上了二分查找的方法</p>\n\n<p>假设数字是18，大概过程是这样</p>\n\n<pre><code>&gt;(guess)  \n50  \n&gt;(smaller)  \n25  \n&gt;(smaller))  \n12  \n&gt;(bigger)  \n18  </code></pre>\n\n<p>三个基本功能，(guess),(smaller),(bigger)</p>\n\n<p>首先定义上下边界\n <br />用define定义变量</p>\n\n<pre><code>&gt;(define lower 1)  \n&gt;lower  \n1  \n&gt;(define upper 100)  \n&gt;upper  \n100  </code></pre>\n\n<p>用define定义函数, 基本形式是</p>\n\n<pre><code>(define (function-name argument-name ...)\n  function-body-expression\n  function-body-expression\n...)</code></pre>\n\n<p>guess的定义如下</p>\n\n<pre><code>(define (guess)\n  (quotient (+ lower upper) 2))</code></pre>\n\n<p>guess函数没有参数，直接写(guess), 接下来就是取lower和upper的中间值</p>\n\n<p>smaller的定义</p>\n\n<pre><code>(define (smaller)\n  (set! upper (max lower (sub1 (guess))))\n  (guess))</code></pre>\n\n<p>set!读作set-bang，基本形式</p>\n\n<pre><code>(set! variable expression)</code></pre>\n\n<p>给variable赋值expression\n <br />smaller先算出新的upper，然后再赋值给upper，然后再展示新的(guess)值</p>\n\n<p>bigger的定义</p>\n\n<pre><code>(define (bigger)\n  (set! lower (min upper (add1 (guess))))\n  (guess))</code></pre>\n\n<p>与smaller类似，计算新的lower，然后展示新的(guess)</p>\n\n<p>main函数</p>\n\n<pre><code>(define (start n m)\n  (set! lower (min n m))\n  (set! upper (max n m))\n  (guess))</code></pre>\n\n<p>跟上面的guess对比，start有参数，(start n m)\n <br />使用min和max，参数的顺序可以任意</p>\n\n<p>假设我们猜的数字是19</p>\n\n<pre><code>&gt;(start 1 30)\n15\n&gt;(bigger))\n23\n&gt;(smaller)\n19)</code></pre>\n\n<p>总结：\n <br />1. 使用define定义变量和函数，函数区分有参数和无参数\n <br />2. 使用set!(set-bang)改变变量的值</p>"))))