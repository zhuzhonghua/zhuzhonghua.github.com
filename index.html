
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>GNO Blog</title>
  <meta name="author" content="zhuzhonghua">

  
  <meta name="description" content="中国的玩家一般都会使用YY作为语音交流系统。 我说的不是这个。 今天听到同事，在说游戏里一个好玩的人，看到游戏里红名的人，就一顿爆揍，之后说一句“汝知错否？！” 配合上当时的情景，确实挺好玩。 我突然想到，如果这句搞笑的话，在游戏里是用语音的形式播放给周围的玩家，是不是更好玩一些？ &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zhuzhonghua.github.com/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="GNO Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">GNO Blog</a></h1>
  
    <h2>GNO's Not Octopress Blog</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com.hk/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:zhuzhonghua.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">列表</a></li>
  <li><a href="http://www.paulgrahamcn.com" target="_blank">PaulGraham中文</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/07/16/you-xi-li-qian-ru-yu-yin-xi-tong/">游戏里嵌入语音系统</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-07-16T14:16:00+08:00" pubdate data-updated="true">Jul 16<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>中国的玩家一般都会使用YY作为语音交流系统。</p>

<p>我说的不是这个。</p>

<p>今天听到同事，在说游戏里一个好玩的人，看到游戏里红名的人，就一顿爆揍，之后说一句“汝知错否？！”</p>

<p>配合上当时的情景，确实挺好玩。</p>

<p>我突然想到，如果这句搞笑的话，在游戏里是用语音的形式播放给周围的玩家，是不是更好玩一些？</p>

<p>现在游戏里的声音，基本上都是固定好的，比如砍人，比如碰撞，这些声音都是事先录制好的。</p>

<p>如果多一些随机的，玩家自己的声音，是不是要有趣一些？！</p>

<p>前段时间比较火的Tom猫，就是用户自己的声音，换个人说出来，就体现出一些好玩的事情。</p>

<p>当然它还有一些其它玩法。</p>

<p>如果这些声音再配合上不同的语调，语气，。。。。</p>

<p>我只是在这里瞎想，不知道有没有公司已经做出这样的系统出来了。</p>

<p>李开复先生就是靠语音系统成名的，而且现在也有很多成熟的技术，我知道的就有读电子书的软件。</p>

<p>所以技术上，应该是可行的。</p>

<p>在此留作Memo，将来自己有机会去主持这样一个游戏的时候，可以试着加入这样的系统。</p>

<p>======分割线=========================================================
Next day 更新。</p>

<p>Siri不是挺火的么？！然后很多公司都去做这样的语音助手。</p>

<p>如果游戏里也加入这样的语音助手，不知道会怎么样？</p>

<p>但目前看到，这是将来的一个技术发展方向。</p>

<p>所以如果想玩，还是有很多东西可以继续玩的。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/07/13/zai-vimzhong-pa-xing/">在Vim中爬行</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-07-13T16:29:00+08:00" pubdate data-updated="true">Jul 13<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>原文
http://www.rudism.com/s/vimcreep
HackerNews 精彩评论
http://news.ycombinator.com/item?id=4235876</p>

<p>一切从足够无知开始。在大学第一年，你尝试过几次，但Nano和Pico很容易且很接近你高中时期在Windows和Mac上的使用体验。但随着时间的推移，而且随着你在大学计算机课程上获得更多的经验，你开始注意到一些事情：所有真正伟大的程序员-用4行代码搞定你用10页代码搞定的任务；一天写了很多可笑并且丰富的类工程，而你却好几个星期挣扎在基础上-没有人使用Nano或者Pico。</p>

<p>你熬夜很晚来完成午夜要完成的任务，碰巧瞥了安静的超级程序员的肩膀一瞥。你的眼睛闪烁发光，看着显示器上一行一行的亮光，在深夜的计算机实验室，你看到了让人敬畏的不可能的代码模式和文本操作，在屏幕上闪过。</p>

<p>“你如何做到的？”你怀疑的问道。</p>

<p>简单的回应了永远改变你的生活的一声：“Vim”</p>

<p>起初，你很沮丧，没有效果。你的浏览器的历史基本上是一个完整在线VIM文档的索引;你的使用Nano和Pico的朋友觉得你疯了；您的使用Emacs的朋友乞求你改变主意；你花了点钱买了一个Vim小抄本为方便参考。即使过了好几个星期的训练后，你仍想要去拿鼠标，然后停下来，意识到，你必须开网页，再学习正确的方法来执行一些平凡的任务，你以前甚至从未想过。</p>

<p>但是，随着时间的推移，你挣扎地越来越少。你不知道什么时候发生的，但Vim不再是一个障碍。相反，它大大超过你的预期。它不再是单纯的文字编辑器，绑定了快捷键，它已经成为你身体的延伸。而且是，作为一个程序员，你的本质延伸。</p>

<p>单独编辑源代码，现在看起来没有充分的使用VIM。你把它装在家里的所有机器上，并用它来写一切，从电子邮件到英语试卷。你在便携设备上安装了一个便携式版本，连同一个很好调试过的，定制过的.vimrc，这样你可以在你去过的任何地方带着vim，陪着你，安慰你，让你觉得你有有一点家的感觉在你的口袋里，无论你在哪里。</p>

<p>VIM进入了你在线生活的每部分。不满足于ViewSourceWith的少量功能，你开始使用Vimperator，然后Pentadactyl。你以前只是在网上冲浪。现在，你就是网络。当你决定写一个iPhone应用程序，你做的第一件事是把XCode的默认编辑器设为MacVim。当你找到了一份工作，写.NET代码，你马上购买了为Visual Studio定制的ViEmu（不满意他的免费表弟，VsVim）。</p>

<p>深夜，当你在你的小房间，让你的键盘奴隶一样的，勤奋的工作，完成一个第二天早上截止的项目，你对自己笑了，因为你知道没有普通的程序员可以在截止日期前完成手头的任务。你录制了宏，你用一个手指轻轻的挪动了整个代码块，你使用了几十个寄存器，你改写和重构整个组件，甚至没有看你的鼠标一眼。这时候，你注意到了您的显示器的反射。瞪着大眼的同事从后面看过来你的肩膀。你停了下来，让他知道，你知道他的存在。</p>

<p>“你如何做到的？”他问道，的声音充满了敬畏。</p>

<p>你微微一笑，准备说出一个字，那曾经改变了你的生活。你的同事应该选择追逐，这个字会引导他进入相同的兔子洞，一个无限组合，无限可能的天地，产生一个高效的形式，那以前只在他最疯狂的梦想中出现过。他提醒你自己，很多年前站在漆黑的实验室，当你说出这个字时，你感觉到他有一丝激动。</p>

<p>“VIM”。</p>

<p>：WQ</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/07/11/dota2-valve-bram-cohen-bt/">Dota2 Valve Bram Cohen BT</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-07-11T11:13:00+08:00" pubdate data-updated="true">Jul 11<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>新闻说，Dota2的中国代理给完美了。   <br/>
多么伟大的游戏，希望完美别浪费了。</p>

<p>只是很多人担心它的收费问题。确实它不像普通的MMO游戏，或者FPS游戏可以卖道具。  <br/>
并且听说它还要免费玩，那就不能通过时间收费了。  <br/>
以前看到别人玩过，说是要靠卖英雄，有些英雄不免费供给玩家用。  <br/>
最新的消息，他们说这会影响游戏的平衡。   <br/>
于是他们要通过商城卖装饰，来盈利。</p>

<p>这是一个点，而且我以前也看到过一个游戏，强大的Avatar系统。
通过切身体验，我会感觉别人的装饰很好玩，很有感。</p>

<p>或许他们应该通过限时装饰来收费，这样能多赚一些钱。  <br/>
而且现实生活中也有这样的情景，女人喜欢买很多衣服。</p>

<p>在这里我构想另一种收费方式。付费战场和免费战场。</p>

<p>付费战场满足人民币玩家花钱的欲望，获得快感。而且让人民币玩家和人民币玩家对抗，产生对抗快感。  <br/>
人民币玩家还可以赠送免费玩家道具来帮助人民币玩家在游戏里和别人对抗。 <br/>
现实生活中就有很多这样的场景，我就曾经玩街机时，被人赠送游戏币，陪玩。</p>

<p>免费战场还是按照原来的方式吸引人气，通过装饰挣钱。
或许付费战场还可以分等级，有些道具很贵只能在有些战场能用。</p>

<p>人法地，地法天，天法道，道法自然。  <br/>
如果没有思路了，可以参考一下现实生活中的例子。</p>

<p>IceFrog原来在Valve工作，哎，暴雪怎么没开发一个Dota类型的网游呢？！  <br/>
不过如果暴雪开发的话，又要耗时好几年，跳几次票，才能出来。 <br/>
不知道这种开发方式好，还是不好。</p>

<p>Valve没有上市，只有250名员工。很多人猜测它的盈利利润其实远远超过了Google这样的巨型公司了。  <br/>
闷声赚大钱的典范。
而且它的文化是，没有老板。Github也采用了这样的文化。</p>

<p>Steam是为了解决他们公司游戏版本更新的问题。
这样不错哦。</p>

<p>游戏的推广确实是个大手笔。  <br/>
像腾讯这样的公司，有自己的推广平台，几乎不要什么钱。这样等于节省了成本，当然盈利也就多了。  <br/>
如果没有什么自己的推广平台，那就要花钱去别人的平台上推广，这样就等于增加了成本。  <br/>
而且这个成本不是一点半点。要比研发费用高很多。  <br/>
不过这样的平台建立也不是容易的。</p>

<p>而Steam最初为了解决版本更新问题，到后来可以发展为推广平台了。而且已经有很多游戏和Steam合作了。</p>

<p>这个思路不错，不知道国内有没有人采用这种方式。
一解决了游戏更新的问题，二可以作为一个推广平台来运营。 岂不是一举两得。</p>

<p>这些东西的背后当然要感谢BT了，那就是感谢BT的作者。</p>

<p>Bram Cohen 生于1975，当然是伟大的程序员了，为什么非得说是计算机程序员呢？！难道还有第二种程序员？！  <br/>
1993年毕业于Stuyvesant中学，难道没有上过大学？！牛X。  <br/>
他曾在几家网络公司工作过，做过的最后一个项目是MojoNation，从事他最为擅长的“网络数据分布传输技术”的研发。
之后因为老板没有接受他的意见，推广它，所以他不干了。
此后他离职在家，潜心研发这种新技术。BT的Beta测试版在2001年问世了。
在同年的一次Linux开源软件大会中，他的BT软件首次亮相。
试用时，极客们发现，在传输百兆以上的大型文件时，BT的速度要比普通的ADSL快上千倍。
而且使用的人数越多，种子就越多，速度也就越快，因此数据传输不再受带宽和流量的限制。
极客们如获至宝般争相下载BT软件，并把它作为传播Linux和大型程序的主要工具。
2002年，在一场黑客论坛上，他公开了BT的所有源代码，表示希望以开源的方式让BT更加完善。
这一举动让BT声名大噪，使用人数成倍增长。
BitTorrent真正流行起来是在2003年初，它被用来发布一个新版的Linux。
与此同时，还有一些日本卡通的fans凭籍它来共享动画片。
当然他为了推广，吸引更多的人来使用这个软件，并测试它，也做了很多其它事情。这里就不说了。
BitTorrent对于Cohen来说，一直是一种脑力训练而不是一种赚钱的途径。
BitTorrent不但是免费的，而且还是开源的。
这意味着只要有足够能力，你完全可以把BitTorrent融入到你自己的程序里面。
尽管BitTorrent获得了如此巨大的成功，但它并没有为Cohen带来过一分钱。
他当时只好利用一张信用卡的免息期来透支，填补另一张信用卡的帐单来过活。
Cohen那时并不知道，BitTorrent会为他带来一份工作。
某天，他的事情为Valve软件公司的常务董事Gabe Newell所获悉。
尽管Valve正在开发令游戏玩家望眼欲穿的Half-Life 2，但是它同时也在建立一个名为Steam的在线分发网络。
由于Cohen掌握这个领域的技术，所以Valve为他提供了一个职位。
Cohen从十月 份起搬到西雅图，开始了他的工作。
一直以来，Cohen都有通过他的网站bitconjurer.org来接受BitTorrent用户的捐款，但是这笔金额一直很少。
然而从10月份开始，Cohen父亲鼓励他请求的更直接一点。
如今，Cohen称，他每天都能收到上百美元的捐款。
“在过去的几个月，我的生活方式发生了相当戏剧性的变化，获得工作还有捐款的到来，”Cohen说，“这好极了。”
Cohen患有Asperger综合症，中文名为孤独样精神障碍，这使他具有高度的集中力，但是在社交上存在障碍。
Cohen目前和他的妻子孩子居住在华盛顿的Bellevue。</p>

<p>这里做个评论，BT从原型开发，到测试版本开发，到可用，到流行，到为作者带来收入，这中间也经历了好几年。  <br/>
那同样作为程序员的我们，不要想着某一天写了一个XX软件，第二天就爆发了。  <br/>
这告诉我们，要懂得积累，沉淀，专注。</p>

<p>他的个人网站上，有他的twitter地址。前面说他接受捐款的网站就是他的个人网站了。
他的facebook主页： www.facebook.com/bram.cohen</p>

<p>他现在在bittorrent.com工作，作为老板。  <br/>
最新的消息是这个http://www.36kr.com/p/83143.html</p>

<p>让我们拭目以待他目标实现的那一天吧。</p>

<p>BT这个伟大的东东，中国也有个国内版本，那就是bitcomet。  <br/>
当时在市场上也是曾经的王者。  <br/>
只不过迅雷加入了这个战场，而bitcomet的作者又因为无厘头的原因，最终就变成这个状态了。  <br/>
现在他们已经转战游戏了，希望能在游戏领域获得成功。 <br/>
只是目前还没有什么成名作。</p>

<p>BT这个东西是好东西，就看你能不能发挥了。Valve用它作出了自己的Steam平台，或许我们也可以考虑一下这个方向。</p>

<p>我最近使用了一个快玩的软件，就是流氓快播的公司开发的。 <br/>
不知道他下载游戏时，是不是用的P2P？如果是的话，那就在这个领域前进了一步了。</p>

<p>而且任何做游戏，尤其是端游的团队，都应该研究一下BT这个东西，解决下载的问题。  <br/>
微端游戏或许应该走这样一个方向。 另外一个方向，是我在研究的。不过Beta版本还没有出来，等出来再炫耀吧。</p>

<p>现在一般页游都是通过CDN来解决问题的，如果WEB也有了P2P的东东，那岂不是和谐的世界。  <br/>
我已经加入了一个WebP2P的邮件列表，关注一下这个方向的最新进展。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/07/04/paulgraham-dot-com/">PaulGraham.com</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-07-04T14:23:00+08:00" pubdate data-updated="true">Jul 4<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>PaulGraham.com中文</p>

<p>Hackers and Painters 这本书2004,2005年就出版了。
虽然那时他还不是投资人，但依然不影响这本书的价值。
中文版 黑客与画家 却在2010年左右才出来。
中间差了5,6年的时间，我们才能看到中文版本。</p>

<p>多么悲哀的一件事情。
所以我要做这样一个网站。把5，6年的时间缩短为5，6天的时间。
www.paulgrahamcn.com</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/06/13/lispgen-yuan/">Lisp根源</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-06-13T20:46:00+08:00" pubdate data-updated="true">Jun 13<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.paulgrahamcn.com/article/rootsoflisp" target="_blank">Lisp根源</a></p>

<p>约翰麦卡锡于1960年发表了一篇非凡的论文,他在这篇论文中对编程的贡献有如 欧几里德对几何的贡献.1他向我们展示了,在只给定几个简单的操作符和一个 表示函数的记号的基础上, 如何构造出一个完整的编程语言. 麦卡锡称这种语 言为Lisp, 意为List Processing, 因为他的主要思想之一是用一种简单的数据 结构表(list)来代表代码和数据.</p>

<p>值得注意的是,麦卡锡所作的发现,不仅是计算机史上划时代的大事, 而且是一种 在我们这个时代编程越来越趋向的模式.我认为目前为止只有两种真正干净利落, 始终如一的编程模式:C语言模式和Lisp语言模式.此二者就象两座高地, 在它们 中间是尤如沼泽的低地.随着计算机变得越来越强大,新开发的语言一直在坚定地 趋向于Lisp模式. 二十年来,开发新编程语言的一个流行的秘决是,取C语言的计 算模式,逐渐地往上加Lisp模式的特性,例如运行时类型和无用单元收集.</p>

<p>在这篇文章中我尽可能用最简单的术语来解释约翰麦卡锡所做的发现. 关键是我 们不仅要学习某个人四十年前得出的有趣理论结果, 而且展示编程语言的发展方 向. Lisp的不同寻常之处&#8211;也就是它优质的定义&#8211;是它能够自己来编写自己. 为了理解约翰麦卡锡所表述的这个特点,我们将追溯他的步伐,并将他的数学标记 转换成能够运行的Common Lisp代码.</p>

<p>七个原始操作符</p>

<p>开始我们先定义表达式.表达式或是一个原子(atom),它是一个字母序列(如 foo),或是一个由零个或多个表达式组成的表(list), 表达式之间用空格分开, 放入一对括号中. 以下是一些表达式:</p>

<pre><code>foo
()
(foo)
(foo bar)
(a b (c) d)
</code></pre>

<p>最后一个表达式是由四个元素组成的表, 第三个元素本身是由一个元素组成的表.</p>

<p>在算术中表达式 1 + 1 得出值2. 正确的Lisp表达式也有值. 如果表达式e得出 值v,我们说e返回v. 下一步我们将定义几种表达式以及它们的返回值.</p>

<p>如果一个表达式是表,我们称第一个元素为操作符,其余的元素为自变量.我们将 定义七个原始(从公理的意义上说)操作符: quote,atom,eq,car,cdr,cons,和 cond.</p>

<pre><code>(quote x) 返回x.为了可读性我们把(quote x)简记 为'x.

&gt; (quote a)
a
&gt; 'a
a
&gt; (quote (a b c))
(a b c)

(atom x)返回原子t如果x的值是一个原子或是空表,否则返回(). 在Lisp中我们 按惯例用原子t表示真, 而用空表表示假.

&gt; (atom 'a)
t
&gt; (atom '(a b c))
()
&gt; (atom '())
t

既然有了一个自变量需要求值的操作符, 我们可以看一下quote的作用. 通过引 用(quote)一个表,我们避免它被求值. 一个未被引用的表作为自变量传给象 atom这样的操作符将被视为代码:

&gt; (atom (atom 'a))
t

反之一个被引用的表仅被视为表, 在此例中就是有两个元素的表:

&gt; (atom '(atom 'a))
()

这与我们在英语中使用引号的方式一致. Cambridge(剑桥)是一个位于麻萨诸塞 州有90000人口的城镇. 而``Cambridge''是一个由9个字母组成的单词.

引用看上去可能有点奇怪因为极少有其它语言有类似的概念. 它和Lisp最与众 不同的特征紧密联系:代码和数据由相同的数据结构构成, 而我们用quote操作符 来区分它们.

(eq x y)返回t如果x和y的值是同一个原子或都是空表, 否则返回().

&gt; (eq 'a 'a)
t
&gt; (eq 'a 'b)
()
&gt; (eq '() '())
t

(car x)期望x的值是一个表并且返回x的第一个元素.

&gt; (car '(a b c))
a

(cdr x)期望x的值是一个表并且返回x的第一个元素之后的所有元素.

&gt; (cdr '(a b c))
(b c)

(cons x y)期望y的值是一个表并且返回一个新表,它的第一个元素是x的值, 后 面跟着y的值的各个元素.

&gt; (cons 'a '(b c))
(a b c)
&gt; (cons 'a (cons 'b (cons 'c '())))
(a b c)
&gt; (car (cons 'a '(b c)))
a
&gt; (cdr (cons 'a '(b c)))
(b c)
</code></pre>

<p>(cond ($p<em>{1}$&#8230;$e</em>{1}$) &#8230;($p<em>{n}$&#8230;$e</em>{n}$)) 的求值规则如下. p表达式依次求值直到有一个 返回t. 如果能找到这样的p表达式,相应的e表达式的值作为整个cond表达式的 返回值.</p>

<pre><code>&gt; (cond ((eq 'a 'b) 'first)
        ((atom 'a)  'second))
second
</code></pre>

<p>当表达式以七个原始操作符中的五个开头时,它的自变量总是要求值的.2 我们称这样 的操作符为函数.</p>

<p>函数的表示
接着我们定义一个记号来描述函数.函数表示为(lambda ($p<em>{1}$&#8230;$p</em>{n}$) e),其中 $p<em>{1}$&#8230;$p</em>{n}$是原子(叫做参数),e是表达式. 如果表达式的第一个元素形式如 上</p>

<pre><code>((lambda ($p_{1}$...$p_{n}$) e) $a_{1}$...$a_{n}$)
</code></pre>

<p>则称为函数调用.它的值计算如下.每一个表达式$a<em>{i}$先求值,然后e再求值.在e的 求值过程中,每个出现在e中的$p</em>{i}$的值是相应的$a_{i}$在最近一 次的函数调用中的值.</p>

<pre><code>&gt; ((lambda (x) (cons x '(b))) 'a)
(a b)
&gt; ((lambda (x y) (cons x (cdr y)))
   'z
   '(a b c))
(z b c)
</code></pre>

<p>如果一个表达式的第一个元素f是原子且f不是原始操作符</p>

<pre><code>(f $a_{1}$...$a_{n}$)
</code></pre>

<p>并且f的值是一个函数(lambda ($p<em>{1}$&#8230;$p</em>{n}$)),则以上表达式的值就是</p>

<pre><code>((lambda ($p_{1}$...$p_{n}$) e) $a_{1}$...$a_{n}$)
</code></pre>

<p>的值. 换句话说,参数在表达式中不但可以作为自变量也可以作为操作符使用:</p>

<pre><code>&gt; ((lambda (f) (f '(b c)))
   '(lambda (x) (cons 'a x)))
(a b c)
</code></pre>

<p>有另外一个函数记号使得函数能提及它本身,这样我们就能方便地定义递归函 数.3 记号</p>

<pre><code>(label f (lambda ($p_{1}$...$p_{n}$) e))
</code></pre>

<p>表示一个象(lambda ($p<em>{1}$&#8230;$p</em>{n}$) e)那样的函数,加上这样的特性: 任何出现在e中的f将求值为此label表达式, 就好象f是此函数的参数.</p>

<p>假设我们要定义函数(subst x y z), 它取表达式x,原子y和表z做参数,返回一个 象z那样的表, 不过z中出现的y(在任何嵌套层次上)被x代替.</p>

<pre><code>&gt; (subst 'm 'b '(a b (a b c) d))
(a m (a m c) d)
</code></pre>

<p>我们可以这样表示此函数</p>

<pre><code>(label subst (lambda (x y z)
               (cond ((atom z)
                      (cond ((eq z y) x)
                            ('t z)))
                     ('t (cons (subst x y (car z))
                               (subst x y (cdr z)))))))
</code></pre>

<p>我们简记f=(label f (lambda ($p<em>{1}$&#8230;$p</em>{n}$) e))为</p>

<pre><code>(defun f ($p_{1}$...$p_{n}$) e)
</code></pre>

<p>于是</p>

<pre><code>(defun subst (x y z)
  (cond ((atom z)
         (cond ((eq z y) x)
               ('t z)))
        ('t (cons (subst x y (car z))
                  (subst x y (cdr z))))))
</code></pre>

<p>偶然地我们在这儿看到如何写cond表达式的缺省子句. 第一个元素是&#8217;t的子句总 是会成功的. 于是</p>

<pre><code>(cond (x y) ('t z))
</code></pre>

<p>等同于我们在某些语言中写的</p>

<pre><code>if x then y else z
</code></pre>

<p>一些函数
既然我们有了表示函数的方法,我们根据七个原始操作符来定义一些新的函数. 为了方便我们引进一些常见模式的简记法. 我们用cxr,其中x是a或d的序列,来 简记相应的car和cdr的组合. 比如(cadr e)是(car (cdr e))的简记,它返回e的 第二个元素.</p>

<pre><code>&gt; (cadr '((a b) (c d) e))
(c d)
&gt; (caddr '((a b) (c d) e))
e
&gt; (cdar '((a b) (c d) e))
(b)
</code></pre>

<p>我们还用(list $e<em>{1}$&#8230;$e</em>{n}$)表示(cons $e<em>{1}$&#8230;(cons $e</em>{n}$&#8217;()) &#8230;).</p>

<pre><code>&gt; (cons 'a (cons 'b (cons 'c '())))
(a b c)
&gt; (list 'a 'b 'c)
(a b c)
</code></pre>

<p>现在我们定义一些新函数. 我在函数名后面加了点,以区别函数和定义它们的原 始函数,也避免与现存的common Lisp的函数冲突.</p>

<p>(null. x)测试它的自变量是否是空表.</p>

<pre><code>(defun null. (x)
  (eq x '()))

&gt; (null. 'a)
()
&gt; (null. '())
t
</code></pre>

<p>(and. x y)返回t如果它的两个自变量都是t, 否则返回().</p>

<pre><code>(defun and. (x y)
  (cond (x (cond (y 't) ('t '())))
        ('t '())))

&gt; (and. (atom 'a) (eq 'a 'a))
t
&gt; (and. (atom 'a) (eq 'a 'b))
()
</code></pre>

<p>(not. x)返回t如果它的自变量返回(),返回()如果它的自变量返回t.</p>

<pre><code>(defun not. (x)
  (cond (x '())
        ('t 't)))

&gt; (not. (eq 'a 'a))
()
&gt; (not. (eq 'a 'b))
t
</code></pre>

<p>(append. x y)取两个表并返回它们的连结.</p>

<pre><code>(defun append. (x y)
   (cond ((null. x) y)
         ('t (cons (car x) (append. (cdr x) y)))))

&gt; (append. '(a b) '(c d))
(a b c d)
&gt; (append. '() '(c d))
(c d)
</code></pre>

<p>(pair. x y)取两个相同长度的表,返回一个由双元素表构成的表,双元素表是相 应位置的x,y的元素对.</p>

<pre><code>(defun pair. (x y)
  (cond ((and. (null. x) (null. y)) '())
        ((and. (not. (atom x)) (not. (atom y)))
         (cons (list (car x) (car y))
               (pair. (cdr) (cdr y))))))

&gt; (pair. '(x y z) '(a b c))
((x a) (y b) (z c))
</code></pre>

<p>(assoc. x y)取原子x和形如pair.函数所返回的表y,返回y中第一个符合如下条 件的表的第二个元素:它的第一个元素是x.</p>

<pre><code>(defun assoc. (x y)
  (cond ((eq (caar y) x) (cadar y))
        ('t (assoc. x (cdr y)))))

&gt; (assoc. 'x '((x a) (y b)))
a
&gt; (assoc. 'x '((x new) (x a) (y b)))
new
</code></pre>

<p>一个惊喜
因此我们能够定义函数来连接表,替换表达式等等.也许算是一个优美的表示法, 那下一步呢? 现在惊喜来了. 我们可以写一个函数作为我们语言的解释器:此函 数取任意Lisp表达式作自变量并返回它的值. 如下所示:</p>

<pre><code>(defun eval. (e a)
  (cond 
    ((atom e) (assoc. e a))
    ((atom (car e))
     (cond 
       ((eq (car e) 'quote) (cadr e))
       ((eq (car e) 'atom)  (atom   (eval. (cadr e) a)))
       ((eq (car e) 'eq)    (eq     (eval. (cadr e) a)
                                    (eval. (caddr e) a)))
       ((eq (car e) 'car)   (car    (eval. (cadr e) a)))
       ((eq (car e) 'cdr)   (cdr    (eval. (cadr e) a)))
       ((eq (car e) 'cons)  (cons   (eval. (cadr e) a)
                                    (eval. (caddr e) a)))
       ((eq (car e) 'cond)  (evcon. (cdr e) a))
       ('t (eval. (cons (assoc. (car e) a)
                        (cdr e))
                  a))))
    ((eq (caar e) 'label)
     (eval. (cons (caddar e) (cdr e))
            (cons (list (cadar e) (car e)) a)))
    ((eq (caar e) 'lambda)
     (eval. (caddar e)
            (append. (pair. (cadar e) (evlis. (cdr  e) a))
                     a)))))

(defun evcon. (c a)
  (cond ((eval. (caar c) a)
         (eval. (cadar c) a))
        ('t (evcon. (cdr c) a))))

(defun evlis. (m a)
  (cond ((null. m) '())
        ('t (cons (eval.  (car m) a)
                  (evlis. (cdr m) a)))))
</code></pre>

<p>eval.的定义比我们以前看到的都要长. 让我们考虑它的每一部分是如何工作的.</p>

<p>eval.有两个自变量: e是要求值的表达式, a是由一些赋给原子的值构成的表,这 些值有点象函数调用中的参数. 这个形如pair.的返回值的表叫做环境. 正是 为了构造和搜索这种表我们才写了pair.和assoc..</p>

<p>eval.的骨架是一个有四个子句的cond表达式. 如何对表达式求值取决于它的类 型. 第一个子句处理原子. 如果e是原子, 我们在环境中寻找它的值:</p>

<pre><code>&gt; (eval. 'x '((x a) (y b)))
a
</code></pre>

<p>第二个子句是另一个cond, 它处理形如(a &#8230;)的表达式, 其中a是原子. 这包 括所有的原始操作符, 每个对应一条子句.</p>

<pre><code>&gt; (eval. '(eq 'a 'a) '())
t
&gt; (eval. '(cons x '(b c))
         '((x a) (y b)))
(a b c)
</code></pre>

<p>这几个子句(除了quote)都调用eval.来寻找自变量的值.</p>

<p>最后两个子句更复杂些. 为了求cond表达式的值我们调用了一个叫 evcon.的辅助函数. 它递归地对cond子句进行求值,寻找第一个元素返回t的子句. 如果找到 了这样的子句, 它返回此子句的第二个元素.</p>

<pre><code>&gt; (eval. '(cond ((atom x) 'atom)
                ('t 'list))
         '((x '(a b))))
list
</code></pre>

<p>第二个子句的最后部分处理函数调用. 它把原子替换为它的值(应该是lambda 或label表达式)然后对所得结果表达式求值. 于是</p>

<pre><code>(eval. '(f '(b c))
       '((f (lambda (x) (cons 'a x)))))
</code></pre>

<p>变为</p>

<pre><code>(eval. '((lambda (x) (cons 'a x)) '(b c))
       '((f (lambda (x) (cons 'a x)))))
</code></pre>

<p>它返回(a b c).</p>

<p>eval.的最后cond两个子句处理第一个元素是lambda或label的函数调用.为了对label 表达式求值, 先把函数名和函数本身压入环境, 然后调用eval.对一个内部有 lambda的表达式求值. 即:</p>

<pre><code>(eval. '((label firstatom (lambda (x)
                            (cond ((atom x) x)
                                  ('t (firstatom (car x))))))
         y)
       '((y ((a b) (c d)))))
</code></pre>

<p>变为</p>

<pre><code>(eval. '((lambda (x)
           (cond ((atom x) x)
                 ('t (firstatom (car x)))))
         y)
        '((firstatom
           (label firstatom (lambda (x)
                            (cond ((atom x) x)
                                  ('t (firstatom (car x)))))))
          (y ((a b) (c d)))))
</code></pre>

<p>最终返回a.</p>

<p>最后,对形如((lambda ($p<em>{1}$&#8230;$p</em>{n}$) e) $a<em>{1}$&#8230;$a</em>{n}$)的表达式求值,先调用evlis.来 求得自变量($a<em>{1}$&#8230;$a</em>{n}$)对应的值($v<em>{1}$&#8230;$v</em>{n}$),把($p<em>{1}$$v</em>{1}$)&#8230;($p<em>{n}$$v</em>{n}$)添加到 环境里, 然后对e求值. 于是</p>

<pre><code>(eval. '((lambda (x y) (cons x (cdr y)))
         'a
         '(b c d))
       '())
</code></pre>

<p>变为</p>

<pre><code>(eval. '(cons x (cdr y))
       '((x a) (y (b c d))))
</code></pre>

<p>最终返回(a c d).</p>

<p>后果</p>

<p>既然理解了eval是如何工作的, 让我们回过头考虑一下这意味着什么. 我们在这 儿得到了一个非常优美的计算模型. 仅用quote,atom,eq,car,cdr,cons,和cond, 我们定义了函数eval.,它事实上实现了我们的语言,用它可以定义任何我们想要 的额外的函数.</p>

<p>当然早已有了各种计算模型&#8211;最著名的是图灵机. 但是图灵机程序难以读懂. 如果你要一种描述算法的语言, 你可能需要更抽象的, 而这就是约翰麦卡锡定义 Lisp的目标之一.</p>

<p>约翰麦卡锡于1960年定义的语言还缺不少东西. 它没有副作用, 没有连续执行 (它得和副作用在一起才有用), 没有实际可用的数,4 没有动态可视域. 但这些限制可 以令人惊讶地用极少的额外代码来补救. Steele和Sussman在一篇叫做&#8220;解释器 的艺术&#8221;的著名论文中描述了如何做到这点.5</p>

<p>如果你理解了约翰麦卡锡的eval, 那你就不仅仅是理解了程序语言历史中的一个 阶段. 这些思想至今仍是Lisp的语义核心. 所以从某种意义上, 学习约翰麦卡 锡的原著向我们展示了Lisp究竟是什么. 与其说Lisp是麦卡锡的设计,不如说是 他的发现. 它不是生来就是一门用于人工智能, 快速原型开发或同等层次任务的 语言. 它是你试图公理化计算的结果(之一).</p>

<p>随着时间的推移, 中级语言, 即被中间层程序员使用的语言, 正一致地向Lisp靠 近. 因此通过理解eval你正在明白将来的主流计算模式会是什么样.</p>

<p>注释
把约翰麦卡锡的记号翻译为代码的过程中我尽可能地少做改动. 我有过让代码 更容易阅读的念头, 但是我还是想保持原汁原味.</p>

<p>在约翰麦卡锡的论文中,假用f来表示, 而不是空表. 我用空表表示假以使例子能 在Common Lisp中运行. (fixme)</p>

<p>我略过了构造dotted pairs, 因为你不需要它来理解eval. 我也没有提apply, 虽然是apply(它的早期形式, 主要作用是引用自变量), 被约翰麦卡锡在1960年 称为普遍函数, eval只是不过是被apply调用的子程序来完成所有的工作.</p>

<p>我定义了list和cxr等作为简记法因为麦卡锡就是这么做的. 实际上 cxr等可以 被定义为普通的函数. List也可以这样, 如果我们修改eval, 这很容易做到, 让 函数可以接受任意数目的自变量.</p>

<p>麦卡锡的论文中只有五个原始操作符. 他使用了cond和quote,但可能把它们作 为他的元语言的一部分. 同样他也没有定义逻辑操作符and和not, 这不是个问题, 因为它们可以被定义成合适的函数.</p>

<p>在eval.的定义中我们调用了其它函数如pair.和assoc.,但任何我们用原始操作 符定义的函数调用都可以用eval.来代替. 即</p>

<pre><code>(assoc. (car e) a)
</code></pre>

<p>能写成</p>

<pre><code>(eval. '((label assoc.
                (lambda (x y)
                  (cond ((eq (caar y) x) (cadar y))
                        ('t (assoc. x (cdr y))))))
         (car e)
         a)
        (cons (list 'e e) (cons (list 'a a) a)))
</code></pre>

<p>麦卡锡的eval有一个错误. 第16行是(相当于)(evlis. (cdr e) a)而不是(cdr e), 这使得自变量在一个有名函数的调用中被求值两次. 这显示当论文发表的 时候, eval的这种描述还没有用IBM 704机器语言实现. 它还证明了如果不去运 行程序, 要保证不管多短的程序的正确性是多么困难.</p>

<p>我还在麦卡锡的论文中碰到一个问题. 在定义了eval之后, 他继续给出了一些 更高级的函数&#8211;接受其它函数作为自变量的函数. 他定义了maplist:</p>

<pre><code>(label maplist
       (lambda (x f)
         (cond ((null x) '())
               ('t (cons (f x) (maplist (cdr x) f))))))
</code></pre>

<p>然后用它写了一个做微分的简单函数diff. 但是diff传给maplist一个用x做参 数的函数, 对它的引用被maplist中的参数x所捕获.6</p>

<p>这是关于动态可视域危险性的雄辩证据, 即使是最早的更高级函数的例子也因为 它而出错. 可能麦卡锡在1960年还没有充分意识到动态可视域的含意. 动态可 视域令人惊异地在Lisp实现中存在了相当长的时间&#8211;直到Sussman和Steele于 1975年开发了Scheme. 词法可视域没使eval的定义复杂多少, 却使编译器更难 写了.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/06/12/chen-lun-yu-hai/">沉沦欲海</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-06-12T23:02:00+08:00" pubdate data-updated="true">Jun 12<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.paulgrahamcn.com/article/addiction">沉沦欲海</a></p>

<p>（坠入诱惑的怀抱，真容易；而且，坠落的过程应该加速吧？）</p>

<p>烈酒、香烟、海洛因和可卡因的共同点：比以前的东西，令人更加容易上瘾。这类东西即使不是全部、也大部分属于令人上瘾之物。而且，令人担忧的是，制造这类东西的过程正在加速。</p>

<p>我们不想停下来。这也是治疗疾病的过程：技术进步。技术进步的后果，比我们想要的多。当如愿时，我们觉得技术进步是一个好东西。如果新技术能提高太阳能电池几个百分点，那就更好了。当技术进步事与愿违时——如从鸦片中提炼出海洛因——那可就是坏东西了。但过程是一样的。</p>

<p>没人怀疑这过程正在加速；意味着：我们现在喜欢的许多事物，最终会让我们沉湎其中。</p>

<p>目前，我不知道该如何形容那些我们过于沉迷的事物。最近似的词要算“成瘾”吧。在我的生活中，该词的用法越来越普遍了。原因清晰：我们得用这个词，来形容越来越多的事情。极端的例子是可卡因和甲安菲他命。集约饲养和花样翻新的加工，快速做出食品上架，你可以在美国各个城镇看到制成品。“魔兽世界”和“法姆维尔”代替了棋盘格和单人棋牌游戏；电视节目够厉害吧，可还是打不过Facebook。</p>

<p>比起40年前，这世道越来越沉迷各种事物了。除非这类技术进步受制于各项法律，这世道接下来的40年，会比过去的40年更沉迷。</p>

<p>未来40年将有一些很棒的东西。我没有逃避的意思。酒精是一味危险的药物，但我宁愿生活的世界里有酒。许多人能与酒相安无事；但必须小心。我们喜欢的东西越多，意味要小心的东西越多。</p>

<p>不幸的是，许多人做不到。当世界变得越来越沉迷的时候，正常生活的两种思路会更加分裂了。一种“正常”是统计意义上的：别人都在做的事情。另一种是“正常”处理事情：这最有效。</p>

<p>这两种想法已经非常分裂了。在美国大部分地方，那些尝试过简朴生活的人，已经看起来象怪物了。这个趋势会越来越明显。从现在开始，可以用一个简单粗暴的原则：如果别人不认为你古怪，那么你的日子就糟糕了。</p>

<p>社会最终会对新的成瘾事物产生抗体。我亲眼看见香烟的变迁。香烟刚出现时，就象传染病一样，在各个人群中传播。吸烟很快变成一件正常的事情（统计上的）。到处都有烟灰缸。当我小的时候，即使我父母不吸烟，家里也为客人准备了烟灰缸。</p>

<p>随着吸烟有害健康的知识普及，民风为之一变。过去20年，吸烟从一件看起来完全正常的事情，变成了肮脏的坏习惯；从电影明星当众吞云吐雾，到一小群瘾君子挤在办公楼外过瘾。当然，很大程度上要归功法律，但如果民风尚未改变之前，法律是不会出台的。</p>

<p>但这需要时间——大概100年吧。社会产生抗体的速度，如果比不上技术进步甩出新诱惑的速度，那么社会习俗保护我们的能力就越来越弱。如果不想成为新诱惑的祭品——为后代提供伤心的例子——我们就得靠自己——明白逃离的对象和方法。真正明智的办法（或较明智的办法）是：怀疑一切新事物。</p>

<p>事实上，这样做还不够。我们不止要担心新玩意，也要考虑已存在的、越来越让人沉迷的事物。这个想法约束了我。我已经躲开许多诱惑了，但互联网绊住了我，当我使用它时，它变得让人着迷了。</p>

<p>我知道很多人网络成瘾。我们都想办法摆脱。如，这就是我不要iPhone的原因；我最不愿意做的事情，就是出门还随身携带互联网。我最新的爱好是远足。我过去认为锻炼方式中，跑步比远足好，因为前者花的时间少。现在，远足的慢悠悠看起来是优点，因为花在小径上的时间越多，不受干扰的思考时间就越多。</p>

<p>听起来很另类吧？当你想解决一些问题，而这些问题还没有约定俗成的解决办法时，都会显得很另类。或许不能以“奥康姆剃刀”为借口；或许，我只是另类。但我肯定，诱惑会越来越多，逃离诱惑的苦苦挣扎将会是每个——要妥当安排生活——人的命运。我们拒绝的事情，将决定我们的生活。</p>

<p>注释：</p>

<p>（1）能将技术进步局限在想要的范围内吗？如果不是警察国家，只能有限度做到。即便如此，各种限制措施还会出现事与愿违的副作用。技术进步中，“好”和“坏”并非泾渭分明，所以人们会发现——拖延了后者，也就拖延了前者。实际情况中，就象《禁酒令》和“打击毒品”，各种限制带来的坏处经常比好处多。</p>

<p>（2）技术一直在加速发展。以旧石器时期的标准，新石器时期的技术进步太快了。</p>

<p>（3）除非我们能批量生产社会习俗。我怀疑，近期美国基督福音的复兴，部分原因是抵制毒品。绝望中，人们拿起了这剂猛药；如果孩子们不听他们的话，或许会听上帝的话。但这剂药的后果，不仅仅是孩子们拒绝了毒品。最后，也会拒绝科学。</p>

<p>我担心，未来只有一小部分人自己寻找穿过荒原的路；而其他人只是跟团旅行。或者更糟，只有政府指定的一条线路。</p>

<p>（4）通常，大家用“拖拖拉拉”形容泡在网上的状态。我觉得只说大家没在工作，简直太客气了。我们就不会说那些醉醺醺、没在工作的人，只是“拖拉”。</p>

<p>（5）有几个人告诉我，有些地方用手提电脑，会很扎眼，他们喜欢iPad，是因为能在这些地方用。换句话说，就一时髦玩意。（当然，这话也可以形容iPhone，但这个优点不明显，因为这东西听起来象手机，况且人人当手机使。）</p>

<p>===========================</p>

<p>The Acceleration of Addictiveness</p>

<p>July 2010</p>

<p>What hard liquor, cigarettes, heroin, and crack have in common is that they&#8217;re all more concentrated forms of less addictive predecessors. Most if not all the things we describe as addictive are. And the scary thing is, the process that created them is accelerating.</p>

<p>We wouldn&#8217;t want to stop it. It&#8217;s the same process that cures diseases: technological progress. Technological progress means making things do more of what we want. When the thing we want is something we want to want, we consider technological progress good. If some new technique makes solar cells x% more efficient, that seems strictly better. When progress concentrates something we don&#8217;t want to want—when it transforms opium into heroin—it seems bad. But it&#8217;s the same process at work. [1]</p>

<p>No one doubts this process is accelerating, which means increasing numbers of things we like will be transformed into things we like too much. [2]</p>

<p>As far as I know there&#8217;s no word for something we like too much. The closest is the colloquial sense of &#8220;addictive.&#8221; That usage has become increasingly common during my lifetime. And it&#8217;s clear why: there are an increasing number of things we need it for. At the extreme end of the spectrum are crack and meth. Food has been transformed by a combination of factory farming and innovations in food processing into something with way more immediate bang for the buck, and you can see the results in any town in America. Checkers and solitaire have been replaced by World of Warcraft and FarmVille. TV has become much more engaging, and even so it can&#8217;t compete with Facebook.</p>

<p>The world is more addictive than it was 40 years ago. And unless the forms of technological progress that produced these things are subject to different laws than technological progress in general, the world will get more addictive in the next 40 years than it did in the last 40.</p>

<p>The next 40 years will bring us some wonderful things. I don&#8217;t mean to imply they&#8217;re all to be avoided. Alcohol is a dangerous drug, but I&#8217;d rather live in a world with wine than one without. Most people can coexist with alcohol; but you have to be careful. More things we like will mean more things we have to be careful about.</p>

<p>Most people won&#8217;t, unfortunately. Which means that as the world becomes more addictive, the two senses in which one can live a normal life will be driven ever further apart. One sense of &#8220;normal&#8221; is statistically normal: what everyone else does. The other is the sense we mean when we talk about the normal operating range of a piece of machinery: what works best.</p>

<p>These two senses are already quite far apart. Already someone trying to live well would seem eccentrically abstemious in most of the US. That phenomenon is only going to become more pronounced. You can probably take it as a rule of thumb from now on that if people don&#8217;t think you&#8217;re weird, you&#8217;re living badly.</p>

<p>Societies eventually develop antibodies to addictive new things. I&#8217;ve seen that happen with cigarettes. When cigarettes first appeared, they spread the way an infectious disease spreads through a previously isolated population. Smoking rapidly became a (statistically) normal thing. There were ashtrays everywhere. We had ashtrays in our house when I was a kid, even though neither of my parents smoked. You had to for guests.</p>

<p>As knowledge spread about the dangers of smoking, customs changed. In the last 20 years, smoking has been transformed from something that seemed totally normal into a rather seedy habit: from something movie stars did in publicity shots to something small huddles of addicts do outside the doors of office buildings. A lot of the change was due to legislation, of course, but the legislation couldn&#8217;t have happened if customs hadn&#8217;t already changed.</p>

<p>It took a while though—on the order of 100 years. And unless the rate at which social antibodies evolve can increase to match the accelerating rate at which technological progress throws off new addictions, we&#8217;ll be increasingly unable to rely on customs to protect us. [3] Unless we want to be canaries in the coal mine of each new addiction—the people whose sad example becomes a lesson to future generations—we&#8217;ll have to figure out for ourselves what to avoid and how. It will actually become a reasonable strategy (or a more reasonable strategy) to suspect everything new.</p>

<p>In fact, even that won&#8217;t be enough. We&#8217;ll have to worry not just about new things, but also about existing things becoming more addictive. That&#8217;s what bit me. I&#8217;ve avoided most addictions, but the Internet got me because it became addictive while I was using it. [4]</p>

<p>Most people I know have problems with Internet addiction. We&#8217;re all trying to figure out our own customs for getting free of it. That&#8217;s why I don&#8217;t have an iPhone, for example; the last thing I want is for the Internet to follow me out into the world. [5] My latest trick is taking long hikes. I used to think running was a better form of exercise than hiking because it took less time. Now the slowness of hiking seems an advantage, because the longer I spend on the trail, the longer I have to think without interruption.</p>

<p>Sounds pretty eccentric, doesn&#8217;t it? It always will when you&#8217;re trying to solve problems where there are no customs yet to guide you. Maybe I can&#8217;t plead Occam&#8217;s razor; maybe I&#8217;m simply eccentric. But if I&#8217;m right about the acceleration of addictiveness, then this kind of lonely squirming to avoid it will increasingly be the fate of anyone who wants to get things done. We&#8217;ll increasingly be defined by what we say no to.</p>

<p>Notes</p>

<p>[1] Could you restrict technological progress to areas where you wanted it? Only in a limited way, without becoming a police state. And even then your restrictions would have undesirable side effects. &#8220;Good&#8221; and &#8220;bad&#8221; technological progress aren&#8217;t sharply differentiated, so you&#8217;d find you couldn&#8217;t slow the latter without also slowing the former. And in any case, as Prohibition and the &#8220;war on drugs&#8221; show, bans often do more harm than good.</p>

<p>[2] Technology has always been accelerating. By Paleolithic standards, technology evolved at a blistering pace in the Neolithic period.</p>

<p>[3] Unless we mass produce social customs. I suspect the recent resurgence of evangelical Christianity in the US is partly a reaction to drugs. In desperation people reach for the sledgehammer; if their kids won&#8217;t listen to them, maybe they&#8217;ll listen to God. But that solution has broader consequences than just getting kids to say no to drugs. You end up saying no to science as well.</p>

<p>I worry we may be heading for a future in which only a few people plot their own itinerary through no-land, while everyone else books a package tour. Or worse still, has one booked for them by the government.</p>

<p>[4] People commonly use the word &#8220;procrastination&#8221; to describe what they do on the Internet. It seems to me too mild to describe what&#8217;s happening as merely not-doing-work. We don&#8217;t call it procrastination when someone gets drunk instead of working.</p>

<p>[5] Several people have told me they like the iPad because it lets them bring the Internet into situations where a laptop would be too conspicuous. In other words, it&#8217;s a hip flask. (This is true of the iPhone too, of course, but this advantage isn&#8217;t as obvious because it reads as a phone, and everyone&#8217;s used to those.)</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/06/12/bao-chi-zhuan-zhu/">保持专注</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-06-12T23:01:00+08:00" pubdate data-updated="true">Jun 12<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.paulgrahamcn.com/article/distration">保持专注</a></p>

<p>我一觉醒来，喝杯咖啡，看看新闻，然后查收邮件，接着再看看新闻，然后回复几封邮件，然后突然意识到快该吃午饭了，工作却没有什么实质进展。而且这种现象越来越严重。Ycombinator创始人Paul Graham也面临着类似的问题。</p>

<p>分心会导致拖延。很多人在无所事事的时候感到不自在；人们通过做些其他的事情来避开工作。</p>

<p>所以战胜拖延的一个办法就是消除分心的事物。但是可没那么简单，因为很多人都在努力让你分心。分心不是一成不变的障碍，你不可能像避开马路上的石头那样避开分心的事物。分心的事物会自己找上门来。</p>

<p>Chesterfield把摆放不当的东西称为垃圾。同样，在错误的时间出现的欲望就是分心。科技的不断进步带来了越来越多的分心事物。也就是说当我们学会避免一些分心事物的时候，总会有新的分心事物出现，就好比是抗药细菌一样。</p>

<p>比如电视，经过50年的不断改进，电视已经成为一种视觉毒品。我在13岁的时候意识到看电视会上瘾，就不再看电视了。但是我最近从书上看到普通美国人每天看四个小时的电视。人一生的四分之一的时间啊。</p>

<p>现在电视走向衰退了，但只是因为人们找到了更容易上瘾的办法来消磨时间。尤其危险的是电脑。这并不是巧合。大量的办公室员工坐在联网的电脑前，分心经常导致拖延。</p>

<p>至少对我而言，电脑曾经只是为工作专用。我只是为了接收邮件或者ftp文件才拨号上网，大部分时间都离线。我所做的一切就是写代码和编程。现在我感觉到好比有人又把电视摆到了我的桌子上。一点鼠标就可以得到极易上瘾的东西。在工作中遇到问题了？嗯，我想知道网上有什么新消息。最好上网查一下。</p>

<p>多年以来我一直避开那些浪费时间的东西，电视，游戏和新闻组（Usernet），但是我还是受到了分心的干扰，因为我根本没有意识到分心的存在。上网本来是很安全的事情，但是慢慢地变得越来越危险。有时候，我一觉醒来，喝杯咖啡，看看新闻，然后查收邮件，接着再看看新闻，然后回复几封邮件，然后突然意识到快该吃午饭了，工作却没有什么实质进展。而且这种现象越来越严重。</p>

<p>我用了很长时间才发现互联网是多么让人分心，因为这个问题是断断续续的。我经常把它当作一个偶尔出现的问题忽略掉。在一个项目中期，分心倒不算大问题。但是当我完成项目，决定下一步做什么的时候，互联网尤其让我抓狂。</p>

<p>人们没有意识到这种危险的另外一个原因就是因为它尚未遭到社会否定。如果我整个上午都坐在沙发上看电视，我会很快意识到这一点。这是一种明显的危险信号，有点像一个人喝闷酒。但是使用互联网看上去依然和工作没什么两样。</p>

<p>但是，我终于意识到互联网太让我分心了，我不得不去改变它。说实话，我不得不在我的分心事物黑名单中增加一个新程序：firefox
这个问题很棘手，因为大部分人需要使用互联网工作。如果你酗酒严重，你可以通过戒酒来解决问题。但是你不能通过绝食来解决暴食的问题。我不能像对待其他分心事物一样完全戒掉互联网。</p>

<p>首先我尝试用规则约束自己。比如，我告诉自己一天只上两次网。但是这些计划都无法长期奏效。最后总会有一些事情让我打破这个规则，然后又重蹈覆辙。</p>

<p>你不得不把上瘾的东西当成是有知觉的对手，他好比是你大脑里的一个小家伙，他总能找到让你“再犯”的办法。只要你给他留下活路，他总会死灰复燃。</p>

<p>关键问题似乎是视觉。大部分坏习惯都是由于缺乏自制力养成的。所以你必须克制自己，不给自己偷偷犯错的机会。必须要设定警报。</p>

<p>从长期来看，应对互联网分心问题的有效办法将是监控互联网活动的软件。但是我还发现了一个更加有效的解决办法：使用单独的电脑上网。</p>

<p>现在，我常用电脑上的无线宽带处于关闭状态，除非传送文件或者编辑网页才使用，我使用放在另外一间屋子里的另一台笔记本电脑查收邮件或者浏览网页。（最有意思的是，这台电脑是Steve Huffman编写Reddit时使用的电脑。当Steve和Alexis慈善拍卖旧笔记本时，我为Y Combinator博物馆买下了这些旧笔记本。）</p>

<p>我的规则是我可以在网上停留很长时间，只要是在那台笔记本上。事实证明这足够了，当我不得不坐在另一间屋子里查收邮件或浏览网页时，我会很清楚自己在做什么。至少对我而言，非常清楚每天上网超过一个小时是多么的困难。</p>

<p>我的常用电脑只用于工作，如果你也这么做，你很可能会惊讶于电脑断网后的感觉。坐在一台只能用于工作目的的电脑前让我保持警觉，因为它告诉我已经浪费了多少时间。</p>

<h1>哇。我在这台电脑上只能工作。好吧，赶紧工作吧。</h1>

<p>Disconnecting Distration</p>

<p>Note: The strategy described at the end of this essay didn&#8217;t work. It would work for a while, and then I&#8217;d gradually find myself using the Internet on my work computer. I&#8217;m trying other strategies now, but I think this time I&#8217;ll wait till I&#8217;m sure they work before writing about them.</p>

<p>May 2008</p>

<p>Procrastination feeds on distractions. Most people find it uncomfortable just to sit and do nothing; you avoid work by doing something else.</p>

<p>So one way to beat procrastination is to starve it of distractions. But that&#8217;s not as straightforward as it sounds, because there are people working hard to distract you. Distraction is not a static obstacle that you avoid like you might avoid a rock in the road. Distraction seeks you out.</p>

<p>Chesterfield described dirt as matter out of place. Distracting is, similarly, desirable at the wrong time. And technology is continually being refined to produce more and more desirable things. Which means that as we learn to avoid one class of distractions, new ones constantly appear, like drug-resistant bacteria.</p>

<p>Television, for example, has after 50 years of refinement reached the point where it&#8217;s like visual crack. I realized when I was 13 that TV was addictive, so I stopped watching it. But I read recently that the average American watches 4 hours of TV a day. A quarter of their life.</p>

<p>TV is in decline now, but only because people have found even more addictive ways of wasting time. And what&#8217;s especially dangerous is that many happen at your computer. This is no accident. An ever larger percentage of office workers sit in front of computers connected to the Internet, and distractions always evolve toward the procrastinators.</p>

<p>I remember when computers were, for me at least, exclusively for work. I might occasionally dial up a server to get mail or ftp files, but most of the time I was offline. All I could do was write and program. Now I feel as if someone snuck a television onto my desk. Terribly addictive things are just a click away. Run into an obstacle in what you&#8217;re working on? Hmm, I wonder what&#8217;s new online. Better check.</p>

<p>After years of carefully avoiding classic time sinks like TV, games, and Usenet, I still managed to fall prey to distraction, because I didn&#8217;t realize that it evolves. Something that used to be safe, using the Internet, gradually became more and more dangerous. Some days I&#8217;d wake up, get a cup of tea and check the news, then check email, then check the news again, then answer a few emails, then suddenly notice it was almost lunchtime and I hadn&#8217;t gotten any real work done. And this started to happen more and more often.</p>

<p>It took me surprisingly long to realize how distracting the Internet had become, because the problem was intermittent. I ignored it the way you let yourself ignore a bug that only appears intermittently. When I was in the middle of a project, distractions weren&#8217;t really a problem. It was when I&#8217;d finished one project and was deciding what to do next that they always bit me.</p>

<p>Another reason it was hard to notice the danger of this new type of distraction was that social customs hadn&#8217;t yet caught up with it. If I&#8217;d spent a whole morning sitting on a sofa watching TV, I&#8217;d have noticed very quickly. That&#8217;s a known danger sign, like drinking alone. But using the Internet still looked and felt a lot like work.</p>

<p>Eventually, though, it became clear that the Internet had become so much more distracting that I had to start treating it differently. Basically, I had to add a new application to my list of known time sinks: Firefox.</p>

<hr />

<p>The problem is a hard one to solve because most people still need the Internet for some things. If you drink too much, you can solve that problem by stopping entirely. But you can&#8217;t solve the problem of overeating by stopping eating. I couldn&#8217;t simply avoid the Internet entirely, as I&#8217;d done with previous time sinks.</p>

<p>At first I tried rules. For example, I&#8217;d tell myself I was only going to use the Internet twice a day. But these schemes never worked for long. Eventually something would come up that required me to use it more than that. And then I&#8217;d gradually slip back into my old ways.</p>

<p>Addictive things have to be treated as if they were sentient adversaries—as if there were a little man in your head always cooking up the most plausible arguments for doing whatever you&#8217;re trying to stop doing. If you leave a path to it, he&#8217;ll find it.</p>

<p>The key seems to be visibility. The biggest ingredient in most bad habits is denial. So you have to make it so that you can&#8217;t merely slip into doing the thing you&#8217;re trying to avoid. It has to set off alarms.</p>

<p>Maybe in the long term the right answer for dealing with Internet distractions will be software that watches and controls them. But in the meantime I&#8217;ve found a more drastic solution that definitely works: to set up a separate computer for using the Internet.</p>

<p>I now leave wifi turned off on my main computer except when I need to transfer a file or edit a web page, and I have a separate laptop on the other side of the room that I use to check mail or browse the web. (Irony of ironies, it&#8217;s the computer Steve Huffman wrote Reddit on. When Steve and Alexis auctioned off their old laptops for charity, I bought them for the Y Combinator museum.)</p>

<p>My rule is that I can spend as much time online as I want, as long as I do it on that computer. And this turns out to be enough. When I have to sit on the other side of the room to check email or browse the web, I become much more aware of it. Sufficiently aware, in my case at least, that it&#8217;s hard to spend more than about an hour a day online.</p>

<p>And my main computer is now freed for work. If you try this trick, you&#8217;ll probably be struck by how different it feels when your computer is disconnected from the Internet. It was alarming to me how foreign it felt to sit in front of a computer that could only be used for work, because that showed how much time I must have been wasting.</p>

<p>Wow. All I can do at this computer is work. Ok, I better work then.</p>

<p>That&#8217;s the good part. Your old bad habits now help you to work. You&#8217;re used to sitting in front of that computer for hours at a time. But you can&#8217;t browse the web or check email now. What are you going to do? You can&#8217;t just sit there. So you start working.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/06/12/javafeng-pi/">Java封皮</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-06-12T23:00:00+08:00" pubdate data-updated="true">Jun 12<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.paulgrahamcn.com/article/javacover">Java封皮</a></p>

<p>译者：<a href="http://www.sophiazheng.com">郑思</a> 转载请注明</p>

<p>这篇文章脱胎于我跟几个程序员的聊天：为什么Java总让人感觉奇怪？先声明，本文绝无批判Java之意，这可是一篇关于黑客嗅觉的案例研究。</p>

<p>日积月累，黑客们逐渐进化出神秘而敏锐的嗅觉，他们能闻出愉悦身心的好技术，也能辨出乏味技术的臭味儿。</p>

<p>我想，试着思考为什么Java散发出一种令人不快的气味，并将述诸文字，或许会很有趣。</p>

<p>一些读者觉得我的尝试挺有趣，毕竟，我写的东西之前还没人写过。还有一些人建议，最好还是别去碰我不懂的领域，不然我会引火烧身。因此，让我再次澄清一下，下文的主题并不是Java（天哪，这门语言我竟然从来都没码过！），而是黑客的嗅觉（对此我深思熟虑，想了不少）。</p>

<p>格言有云：“不可从封面妄自揣测书的内容。”这句话语出有典。有段时期，为了满足不同书商的不同品位，书籍以定制的平装硬皮封面装订。在那些日子里，你无法从封面上辨别一本书。但是，出版业大大地发展了，现今出版商正致力于让你一眼就能从门面上看出书里讲了些什么。</p>

<p>我在书店花了很多时间，我觉得，自己似乎明白了出版商想要通过一本书告诉我的。我没花在书店的时间，大部分都花在电脑前。我同意，在某种程度上，我学会了通过技术的门面去辨别技术的含量。</p>

<p>这或许仅仅是运气，但是我还是成功地从不少技术手中给自己赢得了时间，那些技术已被证明不过是个臭蛋。</p>

<p>到目前为止，Java对我来说看上去都挺像个臭蛋。</p>

<p>我的程序没有一个是用Java写成的，从来没有看过Java的参考书。尽管如此，我还是有一种预感，那就是，Java不会成为一门非常成功的语言。未来或许将揭示我的愚蠢；企图预测科技的走向是门危险的生意。但是，我愿意写下为什么我不喜欢Java的门面，当做时间胶囊，交由未来检验。</p>

<p>1、Java炒作过度。实际标准却没有得到提升。没有人不得不推动C语言，或Unix 又或HTML。一个真正的标准趋势在大多数人听到它之前，往往已经建立了。在黑客第六感的扫描仪里，Perl与Java一样伟大，甚至要伟大的多，仅仅是凭借它自身的语言优势。</p>

<p>2、Java的目标很低。Gosling明确地说，Java为使用C语言的程序员而设计，设计的并不难。设计该门语言的目标是，让它成为另一个C++。C从更高级的语言中提取了一些概念。就像Sitcom的创建者，又或垃圾食品、三天两夜游的创建者那样，Java语言的创建者有意识地为一群不如他们聪明的人设计了一个产品。从历史上来说，那些为其他人使用的语言下场很惨淡：cobol、PL/I, Pascal, Ada,C++。优秀的语言都为自己的创建器所设计：比如C、Perl，Smalltalk，Lisp。</p>

<p>3、Java别有有心。有人曾经说过，如果人们只在有话要说的时候，才写书，而不是在他们想写的时候写书，世界将会美好得多。诚如此言，我们在大多数时间里听到Java，并不是因为它是一门编程语言，而是因为它是Sun打破微软统治地位的战略计划的一部分。</p>

<p>4、没有程序员喜欢Java。C语言、Perl、Python、Smalltalk还有Lisp的程序员都喜欢自己所使用的语言。我还没听人说过他们发自内心热爱Java。</p>

<p>【2001年就有Python了？我勒个去。无知家庭主妇再次被震撼了。】</p>

<p>5、人们被迫使用Java。我认识一些使用Java的人，他们使用Java出于被迫。要么是用Java写的程序容易融到资金，要么是客户希望他们用Java编写程序，要么是管理人员让他们使用Java。这些人都是聪明人。假如某项技术很不错，他们绝对会二话不说，主动采用。</p>

<p>6、设计Java的人太多了。最好的编程语言通常都是由开发的小团体设计出来的。而Java似乎是由某个委员会运行管理的。如果时间证明Java是门不错的语言，这将是历史上头一个由委员会设计出优秀语言。</p>

<p>7、Java带着官僚主义的习性。凭我对Java浅薄的了解，该门语言在执行时有许多协议。一门好的语言真的不需如此。好语言让你能做出你想要的东西，还不会挡你的路。</p>

<p>8、Java是个伪君子。 现在，Sun假设Java就是基层，努力让Java看上去像Perl或Python，是一门开源语言。实际上，它在巨型公司的控制之下。因此，这门语言的单调乏味与一家大公司如出一辙。</p>

<p>9、Java为大型企业而设计。大型组织与黑客的目标并不相同。大型企业需要适合于平庸程序员组成的大型团队所使用的语言。这样的语言拥有速度限制，防止傻瓜损害他们的进度，就好像跟在U型牵引卡车后面。而黑客们只想要权力。历史上，为大型机构设计的语言（PL/I, Ada)输给了黑客们所使用的语言（C，perl). 原因: 今日的年轻黑客就是明日的CTO。</p>

<p>10、喜欢Java的人有问题。基本上，我所钦佩的程序员没有一个人喜欢Java。谁喜欢Java？那些身穿西服的商务人士，他们甚至不懂一门语言与另一门语言的差别，但他们了解，他们持续不断地听到Java的名字；大公司的程序员，他们看到有比C + +更好语言就会惊讶；还有叽叽喳喳的本科生，他们随时准备喜欢上一门帮助他们得到工作的语言（考试究竟会考些什么？）。这些人的意见跟风摇摆。</p>

<p>11、Java的父公司已经风烛残年。Sun的商业模式在两方面都遭到了削弱。与台式机使用同一类型的英特尔处理器很便宜，而且运行速度也足够当服务器了。作为Solaris服务器操作系统，FreeBSD似乎是个不错的开放系统。Sun的广告暗示，你需要工业强度的Sun服务器。如果广告是真的，那么雅虎该第一个买下Sun。但我在那里工作的时候，这里服务器不过是使用了FreeBSD的英特尔盒。Sun的未来大有问题。如果Sun的运行陷入困境，Java也会被拖下水。</p>

<p>12、国防部喜欢Java。国防部鼓励开发人员使用Java。这在我看来，这糟的不能再糟了。国防部保卫国家的工作干得很不赖（虽然价格不菲），但他们喜欢计划、程序和协议。他们的文化是黑客文化的对立面; 软件的问题上，他们往往会赌错。上一次，国防部最喜欢的编程语言是Ada。</p>

<p>记住，本文对Java的内容并未置评，但我批评了它的门面。我对Java了解不多，因此谈不上喜欢或不喜欢。上文讲述了我丝毫不渴望了解它的原因。</p>

<p>本文可能看起来稍显傲慢，因为我在了解语言之前，就甚至试图评论它。但是，这是所有程序员都必须做的事情。我们有太多的技术，不可能每样都学习。你要学会花时间从外在的迹象判断，这一门技巧是否值得你花时间学习。我也同样傲慢地放弃了COBOL，ADA，Visual Basic，IBM AS400，VRML，ISO 9000，SET协议，VMS系统，Novell NetWare与CORBA等等。它们只是看起来很可疑。</p>

<h1>我对Java的判断可能并不正确。它或许是一门由某个大公司扳倒竞争对手的语言；是由委员会设计、符合“主流”口味、捧到天上的语言；是一门被国防部宠爱的语言，同时仍然是一个整洁，优美，功能强大的语言，让我发自内心地喜欢用它编程。确有此种可能。但看上去可能甚微。</h1>

<p>Java&#8217;s Cover April 2001</p>

<p>This essay developed out of conversations I&#8217;ve had with several other programmers about why Java smelled suspicious. It&#8217;s not a critique of Java! It is a case study of hacker&#8217;s radar.</p>

<p>Over time, hackers develop a nose for good (and bad) technology. I thought it might be interesting to try and write down what made Java seem suspect to me.</p>

<p>Some people who&#8217;ve read this think it&#8217;s an interesting attempt to write about something that hasn&#8217;t been written about before. Others say I will get in trouble for appearing to be writing about things I don&#8217;t understand. So, just in case it does any good, let me clarify that I&#8217;m not writing here about Java (which I have never used) but about hacker&#8217;s radar (which I have thought about a lot).</p>

<p>The aphorism &#8220;you can&#8217;t tell a book by its cover&#8221; originated in the times when books were sold in plain cardboard covers, to be bound by each purchaser according to his own taste. In those days, you couldn&#8217;t tell a book by its cover. But publishing has advanced since then: present-day publishers work hard to make the cover something you can tell a book by.</p>

<p>I spend a lot of time in bookshops and I feel as if I have by now learned to understand everything publishers mean to tell me about a book, and perhaps a bit more. The time I haven&#8217;t spent in bookshops I&#8217;ve spent mostly in front of computers, and I feel as if I&#8217;ve learned, to some degree, to judge technology by its cover as well. It may be just luck, but I&#8217;ve saved myself from a few technologies that turned out to be real stinkers.</p>

<p>So far, Java seems like a stinker to me. I&#8217;ve never written a Java program, never more than glanced over reference books about it, but I have a hunch that it won&#8217;t be a very successful language. I may turn out to be mistaken; making predictions about technology is a dangerous business. But for what it&#8217;s worth, as a sort of time capsule, here&#8217;s why I don&#8217;t like the look of Java:</p>

<ol>
<li><p>It has been so energetically hyped. Real standards don&#8217;t have to be promoted. No one had to promote C, or Unix, or HTML. A real standard tends to be already established by the time most people hear about it. On the hacker radar screen, Perl is as big as Java, or bigger, just on the strength of its own merits.</p></li>
<li><p>It&#8217;s aimed low. In the original Java white paper, Gosling explicitly says Java was designed not to be too difficult for programmers used to C. It was designed to be another C++: C plus a few ideas taken from more advanced languages. Like the creators of sitcoms or junk food or package tours, Java&#8217;s designers were consciously designing a product for people not as smart as them. Historically, languages designed for other people to use have been bad: Cobol, PL/I, Pascal, Ada, C++. The good languages have been those that were designed for their own creators: C, Perl, Smalltalk, Lisp.</p></li>
<li><p>It has ulterior motives. Someone once said that the world would be a better place if people only wrote books because they had something to say, rather than because they wanted to write a book. Likewise, the reason we hear about Java all the time is not because it has something to say about programming languages. We hear about Java as part of a plan by Sun to undermine Microsoft.</p></li>
<li><p>No one loves it. C, Perl, Python, Smalltalk, and Lisp programmers love their languages. I&#8217;ve never heard anyone say that they loved Java.</p></li>
<li><p>People are forced to use it. A lot of the people I know using Java are using it because they feel they have to. Either it&#8217;s something they felt they had to do to get funded, or something they thought customers would want, or something they were told to do by management. These are smart people; if the technology was good, they&#8217;d have used it voluntarily.</p></li>
<li><p>It has too many cooks. The best programming languages have been developed by small groups. Java seems to be run by a committee. If it turns out to be a good language, it will be the first time in history that a committee has designed a good language.</p></li>
<li><p>It&#8217;s bureaucratic. From what little I know about Java, there seem to be a lot of protocols for doing things. Really good languages aren&#8217;t like that. They let you do what you want and get out of the way.</p></li>
<li><p>It&#8217;s pseudo-hip. Sun now pretends that Java is a grassroots, open-source language effort like Perl or Python. This one just happens to be controlled by a giant company. So the language is likely to have the same drab clunkiness as anything else that comes out of a big company.</p></li>
<li><p>It&#8217;s designed for large organizations. Large organizations have different aims from hackers. They want languages that are (believed to be) suitable for use by large teams of mediocre programmers&#8211; languages with features that, like the speed limiters in U-Haul trucks, prevent fools from doing too much damage. Hackers don&#8217;t like a language that talks down to them. Hackers just want power. Historically, languages designed for large organizations (PL/I, Ada) have lost, while hacker languages (C, Perl) have won. The reason: today&#8217;s teenage hacker is tomorrow&#8217;s CTO.</p></li>
<li><p>The wrong people like it. The programmers I admire most are not, on the whole, captivated by Java. Who does like Java? Suits, who don&#8217;t know one language from another, but know that they keep hearing about Java in the press; programmers at big companies, who are amazed to find that there is something even better than C++; and plug-and-chug undergrads, who are ready to like anything that might get them a job (will this be on the test?). These people&#8217;s opinions change with every wind.</p></li>
<li><p>Its daddy is in a pinch. Sun&#8217;s business model is being undermined on two fronts. Cheap Intel processors, of the same type used in desktop machines, are now more than fast enough for servers. And FreeBSD seems to be at least as good an OS for servers as Solaris. Sun&#8217;s advertising implies that you need Sun servers for industrial strength applications. If this were true, Yahoo would be first in line to buy Suns; but when I worked there, the servers were all Intel boxes running FreeBSD. This bodes ill for Sun&#8217;s future. If Sun runs into trouble, they could drag Java down with them.</p></li>
<li><p>The DoD likes it. The Defense Department is encouraging developers to use Java. This seems to me the most damning sign of all. The Defense Department does a fine (though expensive) job of defending the country, but they love plans and procedures and protocols. Their culture is the opposite of hacker culture; on questions of software they will tend to bet wrong. The last time the DoD really liked a programming language, it was Ada.</p></li>
</ol>


<p>Bear in mind, this is not a critique of Java, but a critique of its cover. I don&#8217;t know Java well enough to like it or dislike it. This is just an explanation of why I don&#8217;t find that I&#8217;m eager to learn it.</p>

<p>It may seem cavalier to dismiss a language before you&#8217;ve even tried writing programs in it. But this is something all programmers have to do. There are too many technologies out there to learn them all. You have to learn to judge by outward signs which will be worth your time. I have likewise cavalierly dismissed Cobol, Ada, Visual Basic, the IBM AS400, VRML, ISO 9000, the SET protocol, VMS, Novell Netware, and CORBA, among others. They just smelled wrong.</p>

<p>It could be that in Java&#8217;s case I&#8217;m mistaken. It could be that a language promoted by one big company to undermine another, designed by a committee for a &#8220;mainstream&#8221; audience, hyped to the skies, and beloved of the DoD, happens nonetheless to be a clean, beautiful, powerful language that I would love programming in. It could be, but it seems very unlikely.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/06/12/hu-lian-wang-cheng-xu-zhong-de-lisp/">互联网程序中的lisp</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-06-12T22:58:00+08:00" pubdate data-updated="true">Jun 12<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.paulgrahamcn.com/article/lispinweb">互联网程序中的lisp</a></p>

<p>互联网程序中的lisp</p>

<p>摘录自2001年4月在剑桥，MA的BBNlabs所作演讲
理想的语言</p>

<p>一个使用lisp写互联网程序的原因是：你“能”使用lisp。 当你写下一个只会在个人服务器上运行的程序时，你想用什么语言，就用什么语言。</p>

<p>在很长一段时间里，并没有太多语言可供撰写应用程序的程序员选择。编写应用程序意味着编写运行在桌面上的软件。 有一种固执的偏见认为，桌面软件必须使用与操作系统相同的语言编写。 例如，十年前，所有的应用程序都是用C语言撰写的。</p>

<p>现在，基于Web的应用使得上述情况发生了改变。只要你控制得了服务器， 你就可以用任何你想用的语言来写软件。这对你来说心安理得：因为你同时拥有操作系统和编译器的源代码。 如果语言与操作系统之间出了问题，你可以自己修复。</p>

<p>然而，新的自由是一把双刃剑。自由意味着你必须做出选择。 在以前，选择语言很容易。如果你是一个软件项目的负责人，而有些讨厌的家伙建议你使用一种你从来没用的语言来写软件，你只需对他们说：“那种语言一点儿也不实用，”就能结束争论。</p>

<p>现在，基于互联网的应用改变了一切。此刻，你对语言的选择权不得不屈服于市场的力量。 如果你还想对这股改变的趋势装作视而不见，还使用c或c++， 就像我们竞争对手的选择一样，那你就是在准备被时代抛弃。创业小公司只有使用更强大的语言才能制胜。</p>

<p>渐进式开发</p>

<p>使用lisp语言开发的软件带着某种开发风格。它的传统之一是采用渐进式的发展：尽快开始编写程序，越快越好，哪怕该程序暂时什么事情也完成不了。然后逐渐为程序添加主要功能，每一次改写之前的代码还能继续运行。</p>

<p>我觉得，这种编写方式让你迅速高效地编写出软件。 Lisp能将迅速高效的工作方式带入了使用它编写出的程序里，因为Lisp程序员已经这么工作了30年之久。</p>

<p>Viaweb编辑器是一个典型的渐进开发的产物。它始于一个120行的小程序，目的是为了生成网站。在我刚刚写完的一本书里的需要以网站为例子，于是我写了Viaweb。 最终，Viaweb编辑器成长为有约25,000行代码的程序。 我并不认为我有一两天时间能让停止现有代码，好让自己坐下来，改写所有代码。</p>

<p>整个开发过程是一个逐渐变化的长期过程。 这种发展方式非常符合网络程序的滚动发行方式。 这也是更高效的泛型编程方法。</p>

<p>互动的TopLevel</p>

<p>Lisp的互动TopLevel有助于快速开发软件。 但对我们而言，Lisp最大的优势或许是发掘bug。 正如我之前所说，在网络程序中，用户数据存储在你的服务器上，通常会不断重现出bug。</p>

<p>当客服拿着编辑器的错误报告来找我的时候，我会把Lisp代码装入解释器中，并以用户的账号登陆。 如果我能重现错误，我会中断循环，看看到底问题出在哪里。 通常，我可以立即修复错误，并发布一个修复补丁。 当我说“立即”，我的意思是，投诉的用户还没有挂断他的手机呢。</p>

<p>迅速修复错误为我们占据了相当有利的竞争地位。 如果我们能够快速找到并修正错误，而用户仍在讲电话， 我们就给用户成功留下了这一印象：程序的错误不过是他们自己想象出来的罢了。所以，有时我们告诉客服，请让用户重新登录，检查一下问题是否存在。 当然，等用户重新登录，他们使用的已经是新发布的版本了，错误早已修复，程序运行良好。 我知道这么做有点“卑鄙”，但同时也很有趣。</p>

<p>HTML的宏</p>

<p>Lisp的宏是我们的另一制胜点。我们在viaweb编辑器中广泛的使用了宏。 准确地描述，我们所使用的是一个“大宏”。我们非常依赖lisp；而宏会告诉你这种依赖究竟达到了何种程度。 因为，根本没有其他语言能拥有这样的宏。</p>

<p>一个我们使用宏的目的是生成HTML。宏与HTML彼此有种天然的默契。因为HTML是一个前缀表达式，这一点很像Lisp。HTML是递归的，这一点也很像Lisp。 因此，我们能在宏调用中调用宏，从生成最复杂的HTML，并且进程仍然可控。</p>

<p>嵌入语言</p>

<p>我们使用宏的另一大用途是嵌入语言——我们称其为Rtml。 （关于Rtml究竟代表些什么，解释版本不一。其实我是以Robert Morris的名字为它命名的。Rober Morris是Viaweb的共同创始人，他的用户名是Rtm）(Robert Morris, the other founder of Viaweb, whose username is Rtm.) 。我们软件的每一页面都是由RTML所写的程序生成的。 我们将这些程序称为模版，这样听起来就没那么吓人。其实，它们是如假包换的Lisp程序。Rtml是一个宏与内置的Lisp操作符的组合。</p>

<p>用户可以编写自己的Rtml模板，来实现他们所期望的网页外观。 我们生成了一个结构编辑器来操纵模板，这个编辑器很像用户在Interlisp中所使用的结构化编辑器。 对用户来说，他不必在自由模式下输入，只需要把现成的代码剪切、粘贴起来即可，不必担心语法错误。 这同时意味着，我们不需要显示底层的S表达式的括号：我们通过缩进来表示。 这样，这门语言就更易懂了。</p>

<p>我们特意设计Rtml，让它避免了运行错误： 每个Rtml程序都会生成一些网页，你可以不断调试网页，直至最后生成你想要的前端效果。</p>

<p>最开始，我们设想我们的用户是网站顾问，还设想他们会频繁使用Rtml。 因此，我们提供了不少默认模板，内含分块与项目网页等等， 目的是用户可以使用、修改，从而生成他想要的页面。</p>

<p>事实上，网络顾问并不喜欢Viaweb。顾问们，通常来说，都喜欢使用一般人很难上手的产品，这才能保证顾问会得到持续雇佣。 顾问们会访问我们的网站，发现我们的软件很容易使用， 它能让任何人在五分钟内建立起网上商店，他们便会说，我怎么可能用这么简单的玩意儿呢？ 因此，我们没在顾问身上赚到钱。相反，用户大部分都是终端用户，他们自己就是商人。 他们喜欢设计自己网站的感觉。他们不想学编程。他们只使用默认模板。</p>

<p>因此，Rtml最终没有变成程序的主界面。 它扮演了两个角色。首先，对于老练的用户来说，Rtml是只安全阀，提供完成内置模板无法提供的功能。在做viaweb的过程中，有人提出了一个相当有用的意见：用户始终希望升级，即使他们永远不会真的去用。 Rtml就是我们的升级路线。如果你想，你就能绝对控制您网页的每一个角落。</p>

<p>几百个用户中只有一个人会真的撰写自己的模板。这就提供给Rtml第二个优势。 通过查看这些用户如何修改内置模板，我们就可以知道我们需要还能给他们添加些什么。 我们最终的目标是：用户不需要使用Rtml。我们的内置模板应该提供出人们想要的一切内容。 以新的视角来观察，Rtml担任了警告者，它告诉我们，软件中还缺些什么。</p>

<p>编写者——我们是从Rtml的第三个优点中受益最多的人。 即使我们是唯一使用Rtml的人，设计这门语言也值了。 在软件中设计这样的一个抽象层为我们挣得了竞争优势。 首先，它使我们软件的设计干净、简介。我们的竞争对手使用C或Perl代码生成网页，而我们拥有高层语言来生成网页，同时指定页面样式。 这使得代码更干净，更容易修改。 我已经提到过，网络程序是通过渐进式的修改来发布的，渐进式修改要求我们了解修改的严重性。通过将代码分层设计，我们能更优雅地处理修改。 底层修改（也就是修改Rtml本身）影响甚广，也很少发生，通常需要编程者深思熟虑。而修改上层（模板代码）可以快速执行，无需担心太多后果。</p>

<p>Rtml很像Lisp，主要由Lisp宏组成。它的在线编辑器操作S表达式。 当人们运行模板时，模板就被编译成lisp函数。</p>

<p>Rtml在很大程度上依赖于关键字参数，因为那时我一直在思考Common Lisp的关键字参数，这一部分颇为棘手。由于网络软件的发布方式，我们必须设计易修改的软件。 Rtml本身很容易修改，就像该软件的其他部分一样。 大多数Rtml操作符设计为采用关键字参数。这一设定帮了我们大忙。 如果我要添加一个操作符的行为方式，只需要添加一个新的关键字参数， 现有的模板仍然可用。少数的Rtml操作符没有采取关键字参数， 因为我没想到日后有改变这些操作符的需求，可是结果总让我悔不当初。 如果我能从头再来，我想修改的事情之一是，让一切Rtml操作符都采用关键字参数。</p>

<p>事实上，我们在编辑器里嵌入了好几门其他语言。 其中一门语言是用以描述图片的，我们并没有将其暴露给用户。 Viaweb包含由C语言撰写的图像生成器，能够接收对图像的描述、创建图像、 并返回它的URL。我们也是使用S表达式来描述这些图像的。</p>

<p>闭包模拟子程序</p>

<p>使用网页作为UI的问题之一，是web页面的无状态属性。 我们使用词法闭包来模拟子程序行为。 如果你理解延续，那么我们所做的事情可以解释为， 我们以延续传递风格编写软件。</p>

<p>当大多数网络软件生成一个页面上的链接时，往往设想， 假如用户点击该链接，那么程序将要调用该CGI脚本及其参数。 而我们的软件生成链接时，则设想假如用户点击该链接，程序将运行这段代码。 这一段代码可以是任意一段代码，可能（事实上，通常情况下）也可以包含任意变量，并从上下文获取值。</p>

<p>我们是通过宏做到这一点的。宏带着包含闭包的初始参数，紧跟着一段代码。 代码将通过一个唯一ID存储在全局散列表中，这段代码的输出将通过文中的代码生成，并出现在一个链接里，链接的url包含了散列键。假若链接被点击，我们的软件会找到并调用相应的代码，然后继续这一循环。假如代码是闭包，则引用其上下文。 我们飞快地编写了CGI脚本。</p>

<p>到目前为止，我所说的听起来还很空洞，所以让我给你举个例子， 感受一下这一技术带来的显著差异。</p>

<p>在网络程序中，用户经常需要编辑多属性的对象。多数属性都可以表示为表单域或菜单。 例如，假设你编辑的对象代表一个人，你可能得到一个域储存姓名； 一个选择职称的菜单框，等等。</p>

<p>现在，有些对象带有Color属性，我们该怎么办？ 假如沿用普通的CGI脚本，那么这些属性都将集中在一个表单里， 底部带着个”更新”按钮，这么一来操作就很麻烦了。 你也可以使用一个文本字段，让用户手动输入RGB值， 但终端用户都不喜欢这么操作。 要不然，你可以设置一个包含可选颜色的菜单，但你必须限制颜色的数量。又或者你可以提供标准的色彩表，那么你需要256个菜单项，每个菜单项的名字都需要独一无二的命名。</p>

<p>Viaweb能够将一个颜色作为样本来代表当前值， 并跟随一个“修改”按钮。假设用户点击“修改”按钮， 他们就会来到带有色彩表的页面进行选择。 选择后，他们可以回到编辑对象属性的页面，发现颜色已经改变。 这就是我所说的闭包模拟子程序行为。 看起来，软件让用户选择一个颜色，并返回。实际并非如此；程序生成一个新的CGI调用，但对用户而言，我们正在处理一个子程序。我们写代码的方式表达出，假如用户点击了链接，并前往颜色选择页面，最后返回原有页面。 我只举了我们使用该技术的一个例子。 总而言之，这一技术让我们的程序看起来远比竞争对手更复杂。</p>

<p>===================================</p>

<p>Lisp in Web-Based Applications</p>

<p>Paul Graham</p>

<p>(This is an excerpt of a talk given at BBN Labs in Cambridge, MA, in
April 2001.)</p>

<p>Any Language You Want</p>

<p>One of the reasons to use Lisp in writing Web-based applications
is that you <em>can</em> use Lisp.  When you&#8217;re writing software that is
only going to run on your own servers, you can use whatever language
you want.</p>

<p>For a long time programmers didn&#8217;t have a lot of choice about what
language to use for writing application programs.  Until recently,
writing application programs meant writing software to run on
desktop computers.  In desktop software there was a strong bias
toward writing the application in the same language as the operating
system.  Ten years ago, for all practical purposes, applications
were written in C.</p>

<p>With Web-based applications, that changes.  You control the servers,
and you can write your software in any language you want.  You can
take it for granted now that you have the source code of both your
operating system and your compilers.  If there does turn out to be
any kind of problem between the language and the OS, you can fix
it yourself.</p>

<p>This new freedom is a double-edged sword, however.  Having more
choices means that you now have to think about which choice to
make.  It was easier in the old days.  If you were in charge of a
software project, and some troublesome person suggested writing
the software in a different language from whatever you usually
used, you could just tell them that it would be impractical, and
that would be the end of it.</p>

<p>Now, with server-based applications, everything is changed.  You&#8217;re
now subject to market forces in what language you choose.  If you
try to pretend that nothing has changed, and just use C and C++,
like most of our competitors did, you are setting yourself up for
a fall.  A little startup using a more powerful language will eat
your lunch.</p>

<p>Incremental Development</p>

<p>There is a certain style of software development associated with
Lisp.  One of its traditions is incremental development:  you start
by writing, as quickly as possible, a program that does almost
nothing.  Then you gradually add features to it, but at every step
you have working code.</p>

<p>I think this way you get better software, written faster.  Everything
about Lisp is tuned to this style of programming, because Lisp
programmers have worked this way for at least thirty years.</p>

<p>The Viaweb editor must be one of the most extreme cases of incremental
development.  It began with a 120-line program for generating Web
sites that I had used in an example in a book that I finished just
before we started Viaweb.  The Viaweb editor, which eventually grew
to be about 25,000 lines of code, grew incrementally from this
program.  I never once sat down and rewrote the whole thing.  I
don&#8217;t think I was ever more than a day or two without running code.
The whole development process was one long series of gradual changes.</p>

<p>This style of development fits well with the rolling releases that
are possible with Web-based software.  It&#8217;s also a faster way to
get software written generally.</p>

<p>Interactive Toplevel</p>

<p>Lisp&#8217;s interactive toplevel is a great help in developing software
rapidly.  But the biggest advantage for us was probably in finding
bugs.  As I mentioned before, with Web-based applications you have
the users&#8217; data on your servers and can usually reproduce bugs.</p>

<p>When one of the customer support people came to me with a report
of a bug in the editor, I would load the code into the Lisp
interpreter and log into the user&#8217;s account.  If I was able to
reproduce the bug I&#8217;d get an actual break loop, telling me exactly
what was going wrong.  Often I could fix the code and release a
fix right away.  And when I say right away, I mean while the user
was still on the phone.</p>

<p>Such fast turnaround on bug fixes put us into an impossibly tempting
position.  If we could catch and fix a bug while the user was still
on the phone, it was very tempting for us to give the user the
impression that they were imagining it.  And so we sometimes (to
their delight) had the customer support people tell the user to
just try logging in again and see if they still had the problem.
And of course when the user logged back in they&#8217;d get the newly
released version of the software with the bug fixed, and everything
would work fine.  I realize this was a bit sneaky of us, but it
was also a lot of fun.</p>

<p>Macros for Html</p>

<p>Lisp macros were another big win for us.  We used them very
extensively in the Viaweb editor.  It could accurately be described
as one big macro.  And that gives you an idea of how much we depended
on Lisp, because no other language has macros in the sense that
Lisp does.</p>

<p>One way we used macros was to generate Html.  There is a very
natural fit between macros and Html, because Html is a prefix
notation like Lisp, and Html is recursive like Lisp.  So we had
macro calls within macro calls, generating the most complicated
Html, and it was all still very manageable.</p>

<p>Embedded Languages</p>

<p>Another big use for macros was the embedded language we had for
describing pages, called Rtml.  (We made up various explanations
for what Rtml was supposed to stand for, but actually I named it
after Robert Morris, the other founder of Viaweb, whose username
is Rtm.)</p>

<p>Every page made by our software was generated by a program written
in Rtml.  We called these programs templates to make them less
frightening, but they were real programs.  In fact, they were Lisp
programs.  Rtml was a combination of macros and the built-in Lisp
operators.</p>

<p>Users could write their own Rtml templates to describe what they
wanted their pages to look like.  We had a structure editor for
manipulating these templates, a lot like the structure editor they
had in Interlisp.  Instead of typing free-form text, you cut and
pasted bits of code together.  This meant that it was impossible
to get syntax errors.  It also meant that we didn&#8217;t have to display
the parentheses in the underlying s-expressions:  we could show
structure by indentation.  By this means we made the language look
a lot less threatening.</p>

<p>We also designed Rtml so that there could be no errors at runtime:
every Rtml program yielded some kind of Web page, and you could
debug it by hacking it until it produced the page you meant it to.</p>

<p>Initially we expected our users to be Web consultants, and we
expected them to use Rtml a lot.  We provided some default templates
for section pages and item pages and so on, and the idea was that
the users could take them and modify them to make whatever pages
they wanted.</p>

<p>In fact it turned out that Web consultants didn&#8217;t like Viaweb.
Consultants, as a general rule, like to use products that are too
hard for their clients to use, because it guarantees them ongoing
employment.  Consultants would come to our Web site, which said
all over it that our software was so easy to use that it would let
anyone make an online store in five minutes, and they&#8217;d say, there&#8217;s
no way we&#8217;re using that.  So we didn&#8217;t get a lot of interest from
Web consultants.  Instead the users all tended to be end-users,
the actual merchants themselves.  They loved the idea of being in
control of their own Web sites.  And this kind of user did not want
to do any kind of programming.  They just used the default templates.</p>

<p>So Rtml didn&#8217;t end up being the main interface to the program.  It
ended up playing two roles.  First of all, it was an escape valve
for the really sophisticated users, who wanted something our built-in
templates couldn&#8217;t provide.  Somewhere in the course of doing
Viaweb, someone gave me a very useful piece of advice: users always
want an upgrade path, even though as a rule they&#8217;ll never take it.
Rtml was our upgrade path.  If you wanted to, you could get absolute
control over everything on your pages.</p>

<p>Only one out of every couple hundred users actually wrote their
own templates.  And this led to the second advantage of Rtml.  By
looking at the way these users modified our built-in templates, we
knew what we needed to add to them.  Eventually we made it our goal
that no one should ever have to use Rtml.  Our built-in templates
should do everything people wanted.  In this new approach, Rtml
served us as a warning sign that something was missing in our
software.</p>

<p>The third and biggest win from using Rtml was the advantage we
ourselves got from it.  Even if we had been the only people who
used Rtml, it would have been very much worth while writing the
software that way.  Having that extra layer of abstraction in our
software gave us a big advantage over competitors.  It made the
design of our software much cleaner, for one thing.  Instead of
just having bits of actual C or Perl code that generated our Web
pages, like our competitors, we had a very high-level language for
generating Web pages, and our page styles specified in that.  It
made the code much cleaner and easier to modify.  I&#8217;ve already
mentioned that Web-based applications get released as a series of
many small modifications.  When you do that you want to be able to
know how serious any given modification is.  By dividing your code
into layers, you get a better handle on this.  Modifying stuff in
lower layers (Rtml itself) was a serious matter to be done rarely,
and after much thought.  Whereas modifying the top layers (template
code) was something you could do quickly without worrying too much
about the consequences.</p>

<p>Rtml was a very Lispy proposition.  It was mostly Lisp macros, to
start with.  The online editor was, behind the scenes, manipulating
s-expressions.  And when people ran templates, they got compiled
into Lisp functions by calling compile at runtime.</p>

<p>Rtml even depended heavily on keyword parameters, which up to that
time I had always considered one of the more dubious features of
Common Lisp.  Because of the way Web-based software gets released,
you have to design the software so that it&#8217;s easy to change.  And
Rtml itself had to be easy to change, just like any other part of
the software.  Most of the operators in Rtml were designed to take
keyword parameters, and what a help that turned out to be.  If I
wanted to add another dimension to the behavior of one of the
operators, I could just add a new keyword parameter, and everyone&#8217;s
existing templates would continue to work.  A few of the Rtml
operators didn&#8217;t take keyword parameters, because I didn&#8217;t think
I&#8217;d ever need to change them, and almost every one I ended up
kicking myself about later.  If I could go back and start over from
scratch, one of the things I&#8217;d change would be that I&#8217;d make every
Rtml operator take keyword parameters.</p>

<p>We had a couple embedded languages within the editor, in fact.
Another one, which we didn&#8217;t expose directly to the users, was for
describing images.  Viaweb included an image generator, written in
C, that could take a description of an image, create that image,
and return its url.  We used s-expressions to describe these images
as well.</p>

<p>Closures Simulate Subroutines</p>

<p>One of the problems with using Web pages as a UI is the inherent
statelessness of Web sessions.  We got around this by using lexical
closures to simulate subroutine-like behavior.  If you understand
about continuations, one way to explain what we did would be to
say that we wrote our software in continuation-passing style.</p>

<p>When most web-based software generates a link on a page, it tends
to be thinking, if the user clicks on this link, I want to call
this cgi script with these arguments.  When our software generated
a link, it could think, if the user clicks on this link, I want to
run this piece of code.  And the piece of code could an arbitrary
piece of code, possibly (in fact, usually) containing free variables
whose value came from the surrounding context.</p>

<p>The way we did this was to write a macro that took an initial
argument expected to be a closure, followed by a body of code.
The code would then get stored in a global hash table under a unique
id, and whatever output was generated by the code in the body would
appear within a link whose url contained that hash key.  If that
link was the next one clicked on, our software would find and call
the corresponding bit of code, and the chain would continue.
Effectively we were writing cgi scripts on the fly, except that
they were closures that could refer to the surrounding context.</p>

<p>So far this sounds very theoretical, so let me give you an example
of where this technique made an obvious difference.  One of the
things you often want to do in Web-based applications is edit an
object with various types of properties.  Many of the properties
of an object can be represented as form fields or menus.  If you&#8217;re
editing an object representing a person, for example, you might
get a field, for their name, a menu choice for their title, and so
on.</p>

<p>Now what happens when some object has a property that is a color?
If you use ordinary cgi scripts, where everything has to happen on
one form, with an Update button at the bottom, you are going to
have a hard time.  You could use a text field and make the user
type an rgb number into it, but end-users don&#8217;t like that.  Or you
could have a menu of possible colors, but then you have to limit
the possible colors, or otherwise even to offer just the standard
Web colormap, you&#8217;d need 256 menu items with barely distinguishable
names.</p>

<p>What we were able to do, in Viaweb, was display a color as a swatch
representing the current value, followed by a button that said
&#8220;Change.&#8221;  If the user clicked on the Change button they&#8217;d go to
a page with an imagemap of colors to choose among.  And after they
chose a color, they&#8217;d be back on the page where they were editing
the object&#8217;s properties, with that color changed.  This is what I
mean about simulating subroutine-like behavior.  The software could
behave as if it were returning from having chosen a color.  It
wasn&#8217;t, of course; it was making a new cgi call that looked like
going back up a stack.  But by using closures, we could make it
look to the user, and to ourselves, as if we were just doing a
subroutine call.  We could write the code to say, if the user clicks
on this link, go to the color selection page, and then come back
here.  This was just one of the places were we took advantage of
this possibility.  It made our software visibly more sophisticated
than that of our competitors.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/06/12/pythonde-shen-mi/">Python的神秘</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-06-12T22:57:00+08:00" pubdate data-updated="true">Jun 12<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.paulgrahamcn.com/article/pypar">Python的神秘</a></p>

<p>Python悖论——计算机也有方言？</p>

<p>在最近一次访谈中，我有个说法让很多人不爽：开发Python项目的程序员比搞Java项目的聪明。</p>

<p>我可不是说Java程序员就笨。我只是说Python程序员聪明。学一门新的编程语言费时费力。学Python的人绝不是为了找工作才学的，而是因为他们打心底里就喜欢编程，又不满意已经会的语言。</p>

<p>这正是那种公司需要的程序员。我找不到贴切地说法，姑且称之为Python悖论：如果一家公司刻意采用深奥的语言编程，就能招到更优秀的程序员，因为只有真心实意学编程语言的人才会来应聘。对于程序员，这个悖论更是显而易见：要想找个好工作，就要学一种不是仅仅为了找工作的语言。</p>

<p>迄今为止，只有少数几家聪明的公司意识到了这一点。但它们现在的确也用这种选拔方式：这些公司恰恰是程序员们趋之若鹜的。例如谷歌。发布Java编程招聘的时候，他们也要求有Python的经验。</p>

<p>我有个朋友，常用的语言几乎没有他不会的，但大部分项目他都用Python。他说，最主要的原因是喜欢其源代码。这种选择语言的理由貌似很无聊。不过还是有点道理的：编程的时候，读代码花的时间比写代码多。你堆砌源代码的方式就像雕塑家堆粘土一样。粘土里疙瘩太多，雕塑家就会抓狂，源代码太烂，严谨的程序员也会发疯。</p>

<p>说到源代码太烂，人们自然就会想到Perl。不过我所指的不是Perl那种肤浅的烂。句法僵化算不上真烂，基于错误概念编程才令人痛不欲生。Perl就像是卡通娃娃口吐秽语，但它也有Python所不及的理念。</p>

<p>点到为止。这两种语言当然都在发展。但它们，以及Ruby (还有Icon、Joy、J、Lisp和Smalltalk)，都有一个共同点，创造它们、使用它们的人都是真正关心编程的人。而这些人往往是编程高手。</p>

<p>================================</p>

<p>August 2004 In a recent talk I said something that upset a lot of people: that you could get smarter programmers to work on a Python project than you could to work on a Java project.</p>

<p>I didn&#8217;t mean by this that Java programmers are dumb. I meant that Python programmers are smart. It&#8217;s a lot of work to learn a new programming language. And people don&#8217;t learn Python because it will get them a job; they learn it because they genuinely like to program and aren&#8217;t satisfied with the languages they already know.</p>

<p>Which makes them exactly the kind of programmers companies should want to hire. Hence what, for lack of a better name, I&#8217;ll call the Python paradox: if a company chooses to write its software in a comparatively esoteric language, they&#8217;ll be able to hire better programmers, because they&#8217;ll attract only those who cared enough to learn it. And for programmers the paradox is even more pronounced: the language to learn, if you want to get a good job, is a language that people don&#8217;t learn merely to get a job.</p>

<p>Only a few companies have been smart enough to realize this so far. But there is a kind of selection going on here too: they&#8217;re exactly the companies programmers would most like to work for. Google, for example. When they advertise Java programming jobs, they also want Python experience.</p>

<p>A friend of mine who knows nearly all the widely used languages uses Python for most of his projects. He says the main reason is that he likes the way source code looks. That may seem a frivolous reason to choose one language over another. But it is not so frivolous as it sounds: when you program, you spend more time reading code than writing it. You push blobs of source code around the way a sculptor does blobs of clay. So a language that makes source code ugly is maddening to an exacting programmer, as clay full of lumps would be to a sculptor.</p>

<p>At the mention of ugly source code, people will of course think of Perl. But the superficial ugliness of Perl is not the sort I mean. Real ugliness is not harsh-looking syntax, but having to build programs out of the wrong concepts. Perl may look like a cartoon character swearing, but there are cases where it surpasses Python conceptually.</p>

<p>So far, anyway. Both languages are of course moving targets. But they share, along with Ruby (and Icon, and Joy, and J, and Lisp, and Smalltalk) the fact that they&#8217;re created by, and used by, people who really care about programming. And those tend to be the ones who do it well.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/07/16/you-xi-li-qian-ru-yu-yin-xi-tong/">游戏里嵌入语音系统</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/07/13/zai-vimzhong-pa-xing/">在Vim中爬行</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/07/11/dota2-valve-bram-cohen-bt/">dota2 valve Bram Cohen BT</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/07/04/paulgraham-dot-com/">PaulGraham.com</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/06/13/lispgen-yuan/">Lisp根源</a>
      </li>
    
  </ul>
</section>





<section>
  <h1>About Me</h1>
  <p>MMO服务器程序</p>
  <p>主要使用C＋＋，配合各种脚本 </p>
  <p>Email: secondsquare@gmail.com </p>
  <p>QQ: 406344976 </p>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - zhuzhonghua -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
