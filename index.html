
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>GNO Blog</title>
  <meta name="author" content="zhuzhonghua">

  
  <meta name="description" content="一切从足够无知开始。在大学第一年，你尝试过几次，但Nano和Pico很容易且很接近你高中时期在Windows和Mac上的使用体验。但随着时间的推移，而且随着你在大学计算机课程上获得更多的经验，你开始注意到一些事情：所有真正伟大的程序员-用4行代码搞定你用10页代码搞定的任务； &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zhuzhonghua.github.com/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="GNO Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">GNO Blog</a></h1>
  
    <h2>GNO's Not Octopress Blog</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com.hk/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:zhuzhonghua.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">列表</a></li>
  <li><a href="http://www.paulgrahamcn.com" target="_blank">PaulGraham中文</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/07/13/zai-vimzhong-pa-xing/">在Vim中爬行</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-07-13T16:29:00+08:00" pubdate data-updated="true">Jul 13<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>一切从足够无知开始。在大学第一年，你尝试过几次，但Nano和Pico很容易且很接近你高中时期在Windows和Mac上的使用体验。但随着时间的推移，而且随着你在大学计算机课程上获得更多的经验，你开始注意到一些事情：所有真正伟大的程序员-用4行代码搞定你用10页代码搞定的任务；一天写了很多可笑并且丰富的类工程，而你却好几个星期挣扎在基础上-没有人使用Nano或者Pico。</p>

<p>你熬夜很晚来完成午夜要完成的任务，碰巧瞥了安静的超级程序员的肩膀一瞥。你的眼睛闪烁发光，看着显示器上一行一行的亮光，在深夜的计算机实验室，你看到了让人敬畏的不可能的代码模式和文本操作，在屏幕上闪过。</p>

<p>“你如何做到的？”你怀疑的问道。</p>

<p>简单的回应了永远改变你的生活的一声：“Vim”</p>

<p>起初，你很沮丧，没有效果。你的浏览器的历史基本上是一个完整在线VIM文档的索引;你的使用Nano和Pico的朋友觉得你疯了；您的使用Emacs的朋友乞求你改变主意；你花了点钱买了一个Vim小抄本为方便参考。即使过了好几个星期的训练后，你仍想要去拿鼠标，然后停下来，意识到，你必须开网页，再学习正确的方法来执行一些平凡的任务，你以前甚至从未想过。</p>

<p>但是，随着时间的推移，你挣扎地越来越少。你不知道什么时候发生的，但Vim不再是一个障碍。相反，它大大超过你的预期。它不再是单纯的文字编辑器，绑定了快捷键，它已经成为你身体的延伸。而且是，作为一个程序员，你的本质延伸。</p>

<p>单独编辑源代码，现在看起来没有充分的使用VIM。你把它装在家里的所有机器上，并用它来写一切，从电子邮件到英语试卷。你在便携设备上安装了一个便携式版本，连同一个很好调试过的，定制过的.vimrc，这样你可以在你去过的任何地方带着vim，陪着你，安慰你，让你觉得你有有一点家的感觉在你的口袋里，无论你在哪里。</p>

<p>VIM进入了你在线生活的每部分。不满足于ViewSourceWith的少量功能，你开始使用Vimperator，然后Pentadactyl。你以前只是在网上冲浪。现在，你就是网络。当你决定写一个iPhone应用程序，你做的第一件事是把XCode的默认编辑器设为MacVim。当你找到了一份工作，写.NET代码，你马上购买了为Visual Studio定制的ViEmu（不满意他的免费表弟，VsVim）。</p>

<p>深夜，当你在你的小房间，让你的键盘奴隶一样的，勤奋的工作，完成一个第二天早上截止的项目，你对自己笑了，因为你知道没有普通的程序员可以在截止日期前完成手头的任务。你录制了宏，你用一个手指轻轻的挪动了整个代码块，你使用了几十个寄存器，你改写和重构整个组件，甚至没有看你的鼠标一眼。这时候，你注意到了您的显示器的反射。瞪着大眼的同事从后面看过来你的肩膀。你停了下来，让他知道，你知道他的存在。</p>

<p>“你如何做到的？”他问道，的声音充满了敬畏。</p>

<p>你微微一笑，准备说出一个字，那曾经改变了你的生活。你的同事应该选择追逐，这个字会引导他进入相同的兔子洞，一个无限组合，无限可能的天地，产生一个高效的形式，那以前只在他最疯狂的梦想中出现过。他提醒你自己，很多年前站在漆黑的实验室，当你说出这个字时，你感觉到他有一丝激动。</p>

<p>“VIM”。</p>

<p>：WQ</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/07/11/dota2-valve-bram-cohen-bt/">Dota2 Valve Bram Cohen BT</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-07-11T11:13:00+08:00" pubdate data-updated="true">Jul 11<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>新闻说，Dota2的中国代理给完美了。   <br/>
多么伟大的游戏，希望完美别浪费了。</p>

<p>只是很多人担心它的收费问题。确实它不像普通的MMO游戏，或者FPS游戏可以卖道具。  <br/>
并且听说它还要免费玩，那就不能通过时间收费了。  <br/>
以前看到别人玩过，说是要靠卖英雄，有些英雄不免费供给玩家用。  <br/>
最新的消息，他们说这会影响游戏的平衡。   <br/>
于是他们要通过商城卖装饰，来盈利。</p>

<p>这是一个点，而且我以前也看到过一个游戏，强大的Avatar系统。
通过切身体验，我会感觉别人的装饰很好玩，很有感。</p>

<p>或许他们应该通过限时装饰来收费，这样能多赚一些钱。  <br/>
而且现实生活中也有这样的情景，女人喜欢买很多衣服。</p>

<p>在这里我构想另一种收费方式。付费战场和免费战场。</p>

<p>付费战场满足人民币玩家花钱的欲望，获得快感。而且让人民币玩家和人民币玩家对抗，产生对抗快感。  <br/>
人民币玩家还可以赠送免费玩家道具来帮助人民币玩家在游戏里和别人对抗。 <br/>
现实生活中就有很多这样的场景，我就曾经玩街机时，被人赠送游戏币，陪玩。</p>

<p>免费战场还是按照原来的方式吸引人气，通过装饰挣钱。
或许付费战场还可以分等级，有些道具很贵只能在有些战场能用。</p>

<p>人法地，地法天，天法道，道法自然。  <br/>
如果没有思路了，可以参考一下现实生活中的例子。</p>

<p>IceFrog原来在Valve工作，哎，暴雪怎么没开发一个Dota类型的网游呢？！  <br/>
不过如果暴雪开发的话，又要耗时好几年，跳几次票，才能出来。 <br/>
不知道这种开发方式好，还是不好。</p>

<p>Valve没有上市，只有250名员工。很多人猜测它的盈利利润其实远远超过了Google这样的巨型公司了。  <br/>
闷声赚大钱的典范。
而且它的文化是，没有老板。Github也采用了这样的文化。</p>

<p>Steam是为了解决他们公司游戏版本更新的问题。
这样不错哦。</p>

<p>游戏的推广确实是个大手笔。  <br/>
像腾讯这样的公司，有自己的推广平台，几乎不要什么钱。这样等于节省了成本，当然盈利也就多了。  <br/>
如果没有什么自己的推广平台，那就要花钱去别人的平台上推广，这样就等于增加了成本。  <br/>
而且这个成本不是一点半点。要比研发费用高很多。  <br/>
不过这样的平台建立也不是容易的。</p>

<p>而Steam最初为了解决版本更新问题，到后来可以发展为推广平台了。而且已经有很多游戏和Steam合作了。</p>

<p>这个思路不错，不知道国内有没有人采用这种方式。
一解决了游戏更新的问题，二可以作为一个推广平台来运营。 岂不是一举两得。</p>

<p>这些东西的背后当然要感谢BT了，那就是感谢BT的作者。</p>

<p>Bram Cohen 生于1975，当然是伟大的程序员了，为什么非得说是计算机程序员呢？！难道还有第二种程序员？！  <br/>
1993年毕业于Stuyvesant中学，难道没有上过大学？！牛X。  <br/>
他曾在几家网络公司工作过，做过的最后一个项目是MojoNation，从事他最为擅长的“网络数据分布传输技术”的研发。
之后因为老板没有接受他的意见，推广它，所以他不干了。
此后他离职在家，潜心研发这种新技术。BT的Beta测试版在2001年问世了。
在同年的一次Linux开源软件大会中，他的BT软件首次亮相。
试用时，极客们发现，在传输百兆以上的大型文件时，BT的速度要比普通的ADSL快上千倍。
而且使用的人数越多，种子就越多，速度也就越快，因此数据传输不再受带宽和流量的限制。
极客们如获至宝般争相下载BT软件，并把它作为传播Linux和大型程序的主要工具。
2002年，在一场黑客论坛上，他公开了BT的所有源代码，表示希望以开源的方式让BT更加完善。
这一举动让BT声名大噪，使用人数成倍增长。
BitTorrent真正流行起来是在2003年初，它被用来发布一个新版的Linux。
与此同时，还有一些日本卡通的fans凭籍它来共享动画片。
当然他为了推广，吸引更多的人来使用这个软件，并测试它，也做了很多其它事情。这里就不说了。
BitTorrent对于Cohen来说，一直是一种脑力训练而不是一种赚钱的途径。
BitTorrent不但是免费的，而且还是开源的。
这意味着只要有足够能力，你完全可以把BitTorrent融入到你自己的程序里面。
尽管BitTorrent获得了如此巨大的成功，但它并没有为Cohen带来过一分钱。
他当时只好利用一张信用卡的免息期来透支，填补另一张信用卡的帐单来过活。
Cohen那时并不知道，BitTorrent会为他带来一份工作。
某天，他的事情为Valve软件公司的常务董事Gabe Newell所获悉。
尽管Valve正在开发令游戏玩家望眼欲穿的Half-Life 2，但是它同时也在建立一个名为Steam的在线分发网络。
由于Cohen掌握这个领域的技术，所以Valve为他提供了一个职位。
Cohen从十月 份起搬到西雅图，开始了他的工作。
一直以来，Cohen都有通过他的网站bitconjurer.org来接受BitTorrent用户的捐款，但是这笔金额一直很少。
然而从10月份开始，Cohen父亲鼓励他请求的更直接一点。
如今，Cohen称，他每天都能收到上百美元的捐款。
“在过去的几个月，我的生活方式发生了相当戏剧性的变化，获得工作还有捐款的到来，”Cohen说，“这好极了。”
Cohen患有Asperger综合症，中文名为孤独样精神障碍，这使他具有高度的集中力，但是在社交上存在障碍。
Cohen目前和他的妻子孩子居住在华盛顿的Bellevue。</p>

<p>这里做个评论，BT从原型开发，到测试版本开发，到可用，到流行，到为作者带来收入，这中间也经历了好几年。  <br/>
那同样作为程序员的我们，不要想着某一天写了一个XX软件，第二天就爆发了。  <br/>
这告诉我们，要懂得积累，沉淀，专注。</p>

<p>他的个人网站上，有他的twitter地址。前面说他接受捐款的网站就是他的个人网站了。
他的facebook主页： www.facebook.com/bram.cohen</p>

<p>他现在在bittorrent.com工作，作为老板。  <br/>
最新的消息是这个http://www.36kr.com/p/83143.html</p>

<p>让我们拭目以待他目标实现的那一天吧。</p>

<p>BT这个伟大的东东，中国也有个国内版本，那就是bitcomet。  <br/>
当时在市场上也是曾经的王者。  <br/>
只不过迅雷加入了这个战场，而bitcomet的作者又因为无厘头的原因，最终就变成这个状态了。  <br/>
现在他们已经转战游戏了，希望能在游戏领域获得成功。 <br/>
只是目前还没有什么成名作。</p>

<p>BT这个东西是好东西，就看你能不能发挥了。Valve用它作出了自己的Steam平台，或许我们也可以考虑一下这个方向。</p>

<p>我最近使用了一个快玩的软件，就是流氓快播的公司开发的。 <br/>
不知道他下载游戏时，是不是用的P2P？如果是的话，那就在这个领域前进了一步了。</p>

<p>而且任何做游戏，尤其是端游的团队，都应该研究一下BT这个东西，解决下载的问题。  <br/>
微端游戏或许应该走这样一个方向。 另外一个方向，是我在研究的。不过Beta版本还没有出来，等出来再炫耀吧。</p>

<p>现在一般页游都是通过CDN来解决问题的，如果WEB也有了P2P的东东，那岂不是和谐的世界。  <br/>
我已经加入了一个WebP2P的邮件列表，关注一下这个方向的最新进展。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/07/04/paulgraham-dot-com/">PaulGraham.com</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-07-04T14:23:00+08:00" pubdate data-updated="true">Jul 4<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>PaulGraham.com中文</p>

<p>Hackers and Painters 这本书2004,2005年就出版了。
虽然那时他还不是投资人，但依然不影响这本书的价值。
中文版 黑客与画家 却在2010年左右才出来。
中间差了5,6年的时间，我们才能看到中文版本。</p>

<p>多么悲哀的一件事情。
所以我要做这样一个网站。把5，6年的时间缩短为5，6天的时间。
www.paulgrahamcn.com</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/06/13/lispgen-yuan/">Lisp根源</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-06-13T20:46:00+08:00" pubdate data-updated="true">Jun 13<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.paulgrahamcn.com/article/rootsoflisp" target="_blank">Lisp根源</a></p>

<p>约翰麦卡锡于1960年发表了一篇非凡的论文,他在这篇论文中对编程的贡献有如 欧几里德对几何的贡献.1他向我们展示了,在只给定几个简单的操作符和一个 表示函数的记号的基础上, 如何构造出一个完整的编程语言. 麦卡锡称这种语 言为Lisp, 意为List Processing, 因为他的主要思想之一是用一种简单的数据 结构表(list)来代表代码和数据.</p>

<p>值得注意的是,麦卡锡所作的发现,不仅是计算机史上划时代的大事, 而且是一种 在我们这个时代编程越来越趋向的模式.我认为目前为止只有两种真正干净利落, 始终如一的编程模式:C语言模式和Lisp语言模式.此二者就象两座高地, 在它们 中间是尤如沼泽的低地.随着计算机变得越来越强大,新开发的语言一直在坚定地 趋向于Lisp模式. 二十年来,开发新编程语言的一个流行的秘决是,取C语言的计 算模式,逐渐地往上加Lisp模式的特性,例如运行时类型和无用单元收集.</p>

<p>在这篇文章中我尽可能用最简单的术语来解释约翰麦卡锡所做的发现. 关键是我 们不仅要学习某个人四十年前得出的有趣理论结果, 而且展示编程语言的发展方 向. Lisp的不同寻常之处&#8211;也就是它优质的定义&#8211;是它能够自己来编写自己. 为了理解约翰麦卡锡所表述的这个特点,我们将追溯他的步伐,并将他的数学标记 转换成能够运行的Common Lisp代码.</p>

<p>七个原始操作符</p>

<p>开始我们先定义表达式.表达式或是一个原子(atom),它是一个字母序列(如 foo),或是一个由零个或多个表达式组成的表(list), 表达式之间用空格分开, 放入一对括号中. 以下是一些表达式:</p>

<pre><code>foo
()
(foo)
(foo bar)
(a b (c) d)
</code></pre>

<p>最后一个表达式是由四个元素组成的表, 第三个元素本身是由一个元素组成的表.</p>

<p>在算术中表达式 1 + 1 得出值2. 正确的Lisp表达式也有值. 如果表达式e得出 值v,我们说e返回v. 下一步我们将定义几种表达式以及它们的返回值.</p>

<p>如果一个表达式是表,我们称第一个元素为操作符,其余的元素为自变量.我们将 定义七个原始(从公理的意义上说)操作符: quote,atom,eq,car,cdr,cons,和 cond.</p>

<pre><code>(quote x) 返回x.为了可读性我们把(quote x)简记 为'x.

&gt; (quote a)
a
&gt; 'a
a
&gt; (quote (a b c))
(a b c)

(atom x)返回原子t如果x的值是一个原子或是空表,否则返回(). 在Lisp中我们 按惯例用原子t表示真, 而用空表表示假.

&gt; (atom 'a)
t
&gt; (atom '(a b c))
()
&gt; (atom '())
t

既然有了一个自变量需要求值的操作符, 我们可以看一下quote的作用. 通过引 用(quote)一个表,我们避免它被求值. 一个未被引用的表作为自变量传给象 atom这样的操作符将被视为代码:

&gt; (atom (atom 'a))
t

反之一个被引用的表仅被视为表, 在此例中就是有两个元素的表:

&gt; (atom '(atom 'a))
()

这与我们在英语中使用引号的方式一致. Cambridge(剑桥)是一个位于麻萨诸塞 州有90000人口的城镇. 而``Cambridge''是一个由9个字母组成的单词.

引用看上去可能有点奇怪因为极少有其它语言有类似的概念. 它和Lisp最与众 不同的特征紧密联系:代码和数据由相同的数据结构构成, 而我们用quote操作符 来区分它们.

(eq x y)返回t如果x和y的值是同一个原子或都是空表, 否则返回().

&gt; (eq 'a 'a)
t
&gt; (eq 'a 'b)
()
&gt; (eq '() '())
t

(car x)期望x的值是一个表并且返回x的第一个元素.

&gt; (car '(a b c))
a

(cdr x)期望x的值是一个表并且返回x的第一个元素之后的所有元素.

&gt; (cdr '(a b c))
(b c)

(cons x y)期望y的值是一个表并且返回一个新表,它的第一个元素是x的值, 后 面跟着y的值的各个元素.

&gt; (cons 'a '(b c))
(a b c)
&gt; (cons 'a (cons 'b (cons 'c '())))
(a b c)
&gt; (car (cons 'a '(b c)))
a
&gt; (cdr (cons 'a '(b c)))
(b c)
</code></pre>

<p>(cond ($p<em>{1}$&#8230;$e</em>{1}$) &#8230;($p<em>{n}$&#8230;$e</em>{n}$)) 的求值规则如下. p表达式依次求值直到有一个 返回t. 如果能找到这样的p表达式,相应的e表达式的值作为整个cond表达式的 返回值.</p>

<pre><code>&gt; (cond ((eq 'a 'b) 'first)
        ((atom 'a)  'second))
second
</code></pre>

<p>当表达式以七个原始操作符中的五个开头时,它的自变量总是要求值的.2 我们称这样 的操作符为函数.</p>

<p>函数的表示
接着我们定义一个记号来描述函数.函数表示为(lambda ($p<em>{1}$&#8230;$p</em>{n}$) e),其中 $p<em>{1}$&#8230;$p</em>{n}$是原子(叫做参数),e是表达式. 如果表达式的第一个元素形式如 上</p>

<pre><code>((lambda ($p_{1}$...$p_{n}$) e) $a_{1}$...$a_{n}$)
</code></pre>

<p>则称为函数调用.它的值计算如下.每一个表达式$a<em>{i}$先求值,然后e再求值.在e的 求值过程中,每个出现在e中的$p</em>{i}$的值是相应的$a_{i}$在最近一 次的函数调用中的值.</p>

<pre><code>&gt; ((lambda (x) (cons x '(b))) 'a)
(a b)
&gt; ((lambda (x y) (cons x (cdr y)))
   'z
   '(a b c))
(z b c)
</code></pre>

<p>如果一个表达式的第一个元素f是原子且f不是原始操作符</p>

<pre><code>(f $a_{1}$...$a_{n}$)
</code></pre>

<p>并且f的值是一个函数(lambda ($p<em>{1}$&#8230;$p</em>{n}$)),则以上表达式的值就是</p>

<pre><code>((lambda ($p_{1}$...$p_{n}$) e) $a_{1}$...$a_{n}$)
</code></pre>

<p>的值. 换句话说,参数在表达式中不但可以作为自变量也可以作为操作符使用:</p>

<pre><code>&gt; ((lambda (f) (f '(b c)))
   '(lambda (x) (cons 'a x)))
(a b c)
</code></pre>

<p>有另外一个函数记号使得函数能提及它本身,这样我们就能方便地定义递归函 数.3 记号</p>

<pre><code>(label f (lambda ($p_{1}$...$p_{n}$) e))
</code></pre>

<p>表示一个象(lambda ($p<em>{1}$&#8230;$p</em>{n}$) e)那样的函数,加上这样的特性: 任何出现在e中的f将求值为此label表达式, 就好象f是此函数的参数.</p>

<p>假设我们要定义函数(subst x y z), 它取表达式x,原子y和表z做参数,返回一个 象z那样的表, 不过z中出现的y(在任何嵌套层次上)被x代替.</p>

<pre><code>&gt; (subst 'm 'b '(a b (a b c) d))
(a m (a m c) d)
</code></pre>

<p>我们可以这样表示此函数</p>

<pre><code>(label subst (lambda (x y z)
               (cond ((atom z)
                      (cond ((eq z y) x)
                            ('t z)))
                     ('t (cons (subst x y (car z))
                               (subst x y (cdr z)))))))
</code></pre>

<p>我们简记f=(label f (lambda ($p<em>{1}$&#8230;$p</em>{n}$) e))为</p>

<pre><code>(defun f ($p_{1}$...$p_{n}$) e)
</code></pre>

<p>于是</p>

<pre><code>(defun subst (x y z)
  (cond ((atom z)
         (cond ((eq z y) x)
               ('t z)))
        ('t (cons (subst x y (car z))
                  (subst x y (cdr z))))))
</code></pre>

<p>偶然地我们在这儿看到如何写cond表达式的缺省子句. 第一个元素是&#8217;t的子句总 是会成功的. 于是</p>

<pre><code>(cond (x y) ('t z))
</code></pre>

<p>等同于我们在某些语言中写的</p>

<pre><code>if x then y else z
</code></pre>

<p>一些函数
既然我们有了表示函数的方法,我们根据七个原始操作符来定义一些新的函数. 为了方便我们引进一些常见模式的简记法. 我们用cxr,其中x是a或d的序列,来 简记相应的car和cdr的组合. 比如(cadr e)是(car (cdr e))的简记,它返回e的 第二个元素.</p>

<pre><code>&gt; (cadr '((a b) (c d) e))
(c d)
&gt; (caddr '((a b) (c d) e))
e
&gt; (cdar '((a b) (c d) e))
(b)
</code></pre>

<p>我们还用(list $e<em>{1}$&#8230;$e</em>{n}$)表示(cons $e<em>{1}$&#8230;(cons $e</em>{n}$&#8217;()) &#8230;).</p>

<pre><code>&gt; (cons 'a (cons 'b (cons 'c '())))
(a b c)
&gt; (list 'a 'b 'c)
(a b c)
</code></pre>

<p>现在我们定义一些新函数. 我在函数名后面加了点,以区别函数和定义它们的原 始函数,也避免与现存的common Lisp的函数冲突.</p>

<p>(null. x)测试它的自变量是否是空表.</p>

<pre><code>(defun null. (x)
  (eq x '()))

&gt; (null. 'a)
()
&gt; (null. '())
t
</code></pre>

<p>(and. x y)返回t如果它的两个自变量都是t, 否则返回().</p>

<pre><code>(defun and. (x y)
  (cond (x (cond (y 't) ('t '())))
        ('t '())))

&gt; (and. (atom 'a) (eq 'a 'a))
t
&gt; (and. (atom 'a) (eq 'a 'b))
()
</code></pre>

<p>(not. x)返回t如果它的自变量返回(),返回()如果它的自变量返回t.</p>

<pre><code>(defun not. (x)
  (cond (x '())
        ('t 't)))

&gt; (not. (eq 'a 'a))
()
&gt; (not. (eq 'a 'b))
t
</code></pre>

<p>(append. x y)取两个表并返回它们的连结.</p>

<pre><code>(defun append. (x y)
   (cond ((null. x) y)
         ('t (cons (car x) (append. (cdr x) y)))))

&gt; (append. '(a b) '(c d))
(a b c d)
&gt; (append. '() '(c d))
(c d)
</code></pre>

<p>(pair. x y)取两个相同长度的表,返回一个由双元素表构成的表,双元素表是相 应位置的x,y的元素对.</p>

<pre><code>(defun pair. (x y)
  (cond ((and. (null. x) (null. y)) '())
        ((and. (not. (atom x)) (not. (atom y)))
         (cons (list (car x) (car y))
               (pair. (cdr) (cdr y))))))

&gt; (pair. '(x y z) '(a b c))
((x a) (y b) (z c))
</code></pre>

<p>(assoc. x y)取原子x和形如pair.函数所返回的表y,返回y中第一个符合如下条 件的表的第二个元素:它的第一个元素是x.</p>

<pre><code>(defun assoc. (x y)
  (cond ((eq (caar y) x) (cadar y))
        ('t (assoc. x (cdr y)))))

&gt; (assoc. 'x '((x a) (y b)))
a
&gt; (assoc. 'x '((x new) (x a) (y b)))
new
</code></pre>

<p>一个惊喜
因此我们能够定义函数来连接表,替换表达式等等.也许算是一个优美的表示法, 那下一步呢? 现在惊喜来了. 我们可以写一个函数作为我们语言的解释器:此函 数取任意Lisp表达式作自变量并返回它的值. 如下所示:</p>

<pre><code>(defun eval. (e a)
  (cond 
    ((atom e) (assoc. e a))
    ((atom (car e))
     (cond 
       ((eq (car e) 'quote) (cadr e))
       ((eq (car e) 'atom)  (atom   (eval. (cadr e) a)))
       ((eq (car e) 'eq)    (eq     (eval. (cadr e) a)
                                    (eval. (caddr e) a)))
       ((eq (car e) 'car)   (car    (eval. (cadr e) a)))
       ((eq (car e) 'cdr)   (cdr    (eval. (cadr e) a)))
       ((eq (car e) 'cons)  (cons   (eval. (cadr e) a)
                                    (eval. (caddr e) a)))
       ((eq (car e) 'cond)  (evcon. (cdr e) a))
       ('t (eval. (cons (assoc. (car e) a)
                        (cdr e))
                  a))))
    ((eq (caar e) 'label)
     (eval. (cons (caddar e) (cdr e))
            (cons (list (cadar e) (car e)) a)))
    ((eq (caar e) 'lambda)
     (eval. (caddar e)
            (append. (pair. (cadar e) (evlis. (cdr  e) a))
                     a)))))

(defun evcon. (c a)
  (cond ((eval. (caar c) a)
         (eval. (cadar c) a))
        ('t (evcon. (cdr c) a))))

(defun evlis. (m a)
  (cond ((null. m) '())
        ('t (cons (eval.  (car m) a)
                  (evlis. (cdr m) a)))))
</code></pre>

<p>eval.的定义比我们以前看到的都要长. 让我们考虑它的每一部分是如何工作的.</p>

<p>eval.有两个自变量: e是要求值的表达式, a是由一些赋给原子的值构成的表,这 些值有点象函数调用中的参数. 这个形如pair.的返回值的表叫做环境. 正是 为了构造和搜索这种表我们才写了pair.和assoc..</p>

<p>eval.的骨架是一个有四个子句的cond表达式. 如何对表达式求值取决于它的类 型. 第一个子句处理原子. 如果e是原子, 我们在环境中寻找它的值:</p>

<pre><code>&gt; (eval. 'x '((x a) (y b)))
a
</code></pre>

<p>第二个子句是另一个cond, 它处理形如(a &#8230;)的表达式, 其中a是原子. 这包 括所有的原始操作符, 每个对应一条子句.</p>

<pre><code>&gt; (eval. '(eq 'a 'a) '())
t
&gt; (eval. '(cons x '(b c))
         '((x a) (y b)))
(a b c)
</code></pre>

<p>这几个子句(除了quote)都调用eval.来寻找自变量的值.</p>

<p>最后两个子句更复杂些. 为了求cond表达式的值我们调用了一个叫 evcon.的辅助函数. 它递归地对cond子句进行求值,寻找第一个元素返回t的子句. 如果找到 了这样的子句, 它返回此子句的第二个元素.</p>

<pre><code>&gt; (eval. '(cond ((atom x) 'atom)
                ('t 'list))
         '((x '(a b))))
list
</code></pre>

<p>第二个子句的最后部分处理函数调用. 它把原子替换为它的值(应该是lambda 或label表达式)然后对所得结果表达式求值. 于是</p>

<pre><code>(eval. '(f '(b c))
       '((f (lambda (x) (cons 'a x)))))
</code></pre>

<p>变为</p>

<pre><code>(eval. '((lambda (x) (cons 'a x)) '(b c))
       '((f (lambda (x) (cons 'a x)))))
</code></pre>

<p>它返回(a b c).</p>

<p>eval.的最后cond两个子句处理第一个元素是lambda或label的函数调用.为了对label 表达式求值, 先把函数名和函数本身压入环境, 然后调用eval.对一个内部有 lambda的表达式求值. 即:</p>

<pre><code>(eval. '((label firstatom (lambda (x)
                            (cond ((atom x) x)
                                  ('t (firstatom (car x))))))
         y)
       '((y ((a b) (c d)))))
</code></pre>

<p>变为</p>

<pre><code>(eval. '((lambda (x)
           (cond ((atom x) x)
                 ('t (firstatom (car x)))))
         y)
        '((firstatom
           (label firstatom (lambda (x)
                            (cond ((atom x) x)
                                  ('t (firstatom (car x)))))))
          (y ((a b) (c d)))))
</code></pre>

<p>最终返回a.</p>

<p>最后,对形如((lambda ($p<em>{1}$&#8230;$p</em>{n}$) e) $a<em>{1}$&#8230;$a</em>{n}$)的表达式求值,先调用evlis.来 求得自变量($a<em>{1}$&#8230;$a</em>{n}$)对应的值($v<em>{1}$&#8230;$v</em>{n}$),把($p<em>{1}$$v</em>{1}$)&#8230;($p<em>{n}$$v</em>{n}$)添加到 环境里, 然后对e求值. 于是</p>

<pre><code>(eval. '((lambda (x y) (cons x (cdr y)))
         'a
         '(b c d))
       '())
</code></pre>

<p>变为</p>

<pre><code>(eval. '(cons x (cdr y))
       '((x a) (y (b c d))))
</code></pre>

<p>最终返回(a c d).</p>

<p>后果</p>

<p>既然理解了eval是如何工作的, 让我们回过头考虑一下这意味着什么. 我们在这 儿得到了一个非常优美的计算模型. 仅用quote,atom,eq,car,cdr,cons,和cond, 我们定义了函数eval.,它事实上实现了我们的语言,用它可以定义任何我们想要 的额外的函数.</p>

<p>当然早已有了各种计算模型&#8211;最著名的是图灵机. 但是图灵机程序难以读懂. 如果你要一种描述算法的语言, 你可能需要更抽象的, 而这就是约翰麦卡锡定义 Lisp的目标之一.</p>

<p>约翰麦卡锡于1960年定义的语言还缺不少东西. 它没有副作用, 没有连续执行 (它得和副作用在一起才有用), 没有实际可用的数,4 没有动态可视域. 但这些限制可 以令人惊讶地用极少的额外代码来补救. Steele和Sussman在一篇叫做&#8220;解释器 的艺术&#8221;的著名论文中描述了如何做到这点.5</p>

<p>如果你理解了约翰麦卡锡的eval, 那你就不仅仅是理解了程序语言历史中的一个 阶段. 这些思想至今仍是Lisp的语义核心. 所以从某种意义上, 学习约翰麦卡 锡的原著向我们展示了Lisp究竟是什么. 与其说Lisp是麦卡锡的设计,不如说是 他的发现. 它不是生来就是一门用于人工智能, 快速原型开发或同等层次任务的 语言. 它是你试图公理化计算的结果(之一).</p>

<p>随着时间的推移, 中级语言, 即被中间层程序员使用的语言, 正一致地向Lisp靠 近. 因此通过理解eval你正在明白将来的主流计算模式会是什么样.</p>

<p>注释
把约翰麦卡锡的记号翻译为代码的过程中我尽可能地少做改动. 我有过让代码 更容易阅读的念头, 但是我还是想保持原汁原味.</p>

<p>在约翰麦卡锡的论文中,假用f来表示, 而不是空表. 我用空表表示假以使例子能 在Common Lisp中运行. (fixme)</p>

<p>我略过了构造dotted pairs, 因为你不需要它来理解eval. 我也没有提apply, 虽然是apply(它的早期形式, 主要作用是引用自变量), 被约翰麦卡锡在1960年 称为普遍函数, eval只是不过是被apply调用的子程序来完成所有的工作.</p>

<p>我定义了list和cxr等作为简记法因为麦卡锡就是这么做的. 实际上 cxr等可以 被定义为普通的函数. List也可以这样, 如果我们修改eval, 这很容易做到, 让 函数可以接受任意数目的自变量.</p>

<p>麦卡锡的论文中只有五个原始操作符. 他使用了cond和quote,但可能把它们作 为他的元语言的一部分. 同样他也没有定义逻辑操作符and和not, 这不是个问题, 因为它们可以被定义成合适的函数.</p>

<p>在eval.的定义中我们调用了其它函数如pair.和assoc.,但任何我们用原始操作 符定义的函数调用都可以用eval.来代替. 即</p>

<pre><code>(assoc. (car e) a)
</code></pre>

<p>能写成</p>

<pre><code>(eval. '((label assoc.
                (lambda (x y)
                  (cond ((eq (caar y) x) (cadar y))
                        ('t (assoc. x (cdr y))))))
         (car e)
         a)
        (cons (list 'e e) (cons (list 'a a) a)))
</code></pre>

<p>麦卡锡的eval有一个错误. 第16行是(相当于)(evlis. (cdr e) a)而不是(cdr e), 这使得自变量在一个有名函数的调用中被求值两次. 这显示当论文发表的 时候, eval的这种描述还没有用IBM 704机器语言实现. 它还证明了如果不去运 行程序, 要保证不管多短的程序的正确性是多么困难.</p>

<p>我还在麦卡锡的论文中碰到一个问题. 在定义了eval之后, 他继续给出了一些 更高级的函数&#8211;接受其它函数作为自变量的函数. 他定义了maplist:</p>

<pre><code>(label maplist
       (lambda (x f)
         (cond ((null x) '())
               ('t (cons (f x) (maplist (cdr x) f))))))
</code></pre>

<p>然后用它写了一个做微分的简单函数diff. 但是diff传给maplist一个用x做参 数的函数, 对它的引用被maplist中的参数x所捕获.6</p>

<p>这是关于动态可视域危险性的雄辩证据, 即使是最早的更高级函数的例子也因为 它而出错. 可能麦卡锡在1960年还没有充分意识到动态可视域的含意. 动态可 视域令人惊异地在Lisp实现中存在了相当长的时间&#8211;直到Sussman和Steele于 1975年开发了Scheme. 词法可视域没使eval的定义复杂多少, 却使编译器更难 写了.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/06/12/chen-lun-yu-hai/">沉沦欲海</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-06-12T23:02:00+08:00" pubdate data-updated="true">Jun 12<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.paulgrahamcn.com/article/addiction">沉沦欲海</a></p>

<p>（坠入诱惑的怀抱，真容易；而且，坠落的过程应该加速吧？）</p>

<p>烈酒、香烟、海洛因和可卡因的共同点：比以前的东西，令人更加容易上瘾。这类东西即使不是全部、也大部分属于令人上瘾之物。而且，令人担忧的是，制造这类东西的过程正在加速。</p>

<p>我们不想停下来。这也是治疗疾病的过程：技术进步。技术进步的后果，比我们想要的多。当如愿时，我们觉得技术进步是一个好东西。如果新技术能提高太阳能电池几个百分点，那就更好了。当技术进步事与愿违时——如从鸦片中提炼出海洛因——那可就是坏东西了。但过程是一样的。</p>

<p>没人怀疑这过程正在加速；意味着：我们现在喜欢的许多事物，最终会让我们沉湎其中。</p>

<p>目前，我不知道该如何形容那些我们过于沉迷的事物。最近似的词要算“成瘾”吧。在我的生活中，该词的用法越来越普遍了。原因清晰：我们得用这个词，来形容越来越多的事情。极端的例子是可卡因和甲安菲他命。集约饲养和花样翻新的加工，快速做出食品上架，你可以在美国各个城镇看到制成品。“魔兽世界”和“法姆维尔”代替了棋盘格和单人棋牌游戏；电视节目够厉害吧，可还是打不过Facebook。</p>

<p>比起40年前，这世道越来越沉迷各种事物了。除非这类技术进步受制于各项法律，这世道接下来的40年，会比过去的40年更沉迷。</p>

<p>未来40年将有一些很棒的东西。我没有逃避的意思。酒精是一味危险的药物，但我宁愿生活的世界里有酒。许多人能与酒相安无事；但必须小心。我们喜欢的东西越多，意味要小心的东西越多。</p>

<p>不幸的是，许多人做不到。当世界变得越来越沉迷的时候，正常生活的两种思路会更加分裂了。一种“正常”是统计意义上的：别人都在做的事情。另一种是“正常”处理事情：这最有效。</p>

<p>这两种想法已经非常分裂了。在美国大部分地方，那些尝试过简朴生活的人，已经看起来象怪物了。这个趋势会越来越明显。从现在开始，可以用一个简单粗暴的原则：如果别人不认为你古怪，那么你的日子就糟糕了。</p>

<p>社会最终会对新的成瘾事物产生抗体。我亲眼看见香烟的变迁。香烟刚出现时，就象传染病一样，在各个人群中传播。吸烟很快变成一件正常的事情（统计上的）。到处都有烟灰缸。当我小的时候，即使我父母不吸烟，家里也为客人准备了烟灰缸。</p>

<p>随着吸烟有害健康的知识普及，民风为之一变。过去20年，吸烟从一件看起来完全正常的事情，变成了肮脏的坏习惯；从电影明星当众吞云吐雾，到一小群瘾君子挤在办公楼外过瘾。当然，很大程度上要归功法律，但如果民风尚未改变之前，法律是不会出台的。</p>

<p>但这需要时间——大概100年吧。社会产生抗体的速度，如果比不上技术进步甩出新诱惑的速度，那么社会习俗保护我们的能力就越来越弱。如果不想成为新诱惑的祭品——为后代提供伤心的例子——我们就得靠自己——明白逃离的对象和方法。真正明智的办法（或较明智的办法）是：怀疑一切新事物。</p>

<p>事实上，这样做还不够。我们不止要担心新玩意，也要考虑已存在的、越来越让人沉迷的事物。这个想法约束了我。我已经躲开许多诱惑了，但互联网绊住了我，当我使用它时，它变得让人着迷了。</p>

<p>我知道很多人网络成瘾。我们都想办法摆脱。如，这就是我不要iPhone的原因；我最不愿意做的事情，就是出门还随身携带互联网。我最新的爱好是远足。我过去认为锻炼方式中，跑步比远足好，因为前者花的时间少。现在，远足的慢悠悠看起来是优点，因为花在小径上的时间越多，不受干扰的思考时间就越多。</p>

<p>听起来很另类吧？当你想解决一些问题，而这些问题还没有约定俗成的解决办法时，都会显得很另类。或许不能以“奥康姆剃刀”为借口；或许，我只是另类。但我肯定，诱惑会越来越多，逃离诱惑的苦苦挣扎将会是每个——要妥当安排生活——人的命运。我们拒绝的事情，将决定我们的生活。</p>

<p>注释：</p>

<p>（1）能将技术进步局限在想要的范围内吗？如果不是警察国家，只能有限度做到。即便如此，各种限制措施还会出现事与愿违的副作用。技术进步中，“好”和“坏”并非泾渭分明，所以人们会发现——拖延了后者，也就拖延了前者。实际情况中，就象《禁酒令》和“打击毒品”，各种限制带来的坏处经常比好处多。</p>

<p>（2）技术一直在加速发展。以旧石器时期的标准，新石器时期的技术进步太快了。</p>

<p>（3）除非我们能批量生产社会习俗。我怀疑，近期美国基督福音的复兴，部分原因是抵制毒品。绝望中，人们拿起了这剂猛药；如果孩子们不听他们的话，或许会听上帝的话。但这剂药的后果，不仅仅是孩子们拒绝了毒品。最后，也会拒绝科学。</p>

<p>我担心，未来只有一小部分人自己寻找穿过荒原的路；而其他人只是跟团旅行。或者更糟，只有政府指定的一条线路。</p>

<p>（4）通常，大家用“拖拖拉拉”形容泡在网上的状态。我觉得只说大家没在工作，简直太客气了。我们就不会说那些醉醺醺、没在工作的人，只是“拖拉”。</p>

<p>（5）有几个人告诉我，有些地方用手提电脑，会很扎眼，他们喜欢iPad，是因为能在这些地方用。换句话说，就一时髦玩意。（当然，这话也可以形容iPhone，但这个优点不明显，因为这东西听起来象手机，况且人人当手机使。）</p>

<p>===========================</p>

<p>The Acceleration of Addictiveness</p>

<p>July 2010</p>

<p>What hard liquor, cigarettes, heroin, and crack have in common is that they&#8217;re all more concentrated forms of less addictive predecessors. Most if not all the things we describe as addictive are. And the scary thing is, the process that created them is accelerating.</p>

<p>We wouldn&#8217;t want to stop it. It&#8217;s the same process that cures diseases: technological progress. Technological progress means making things do more of what we want. When the thing we want is something we want to want, we consider technological progress good. If some new technique makes solar cells x% more efficient, that seems strictly better. When progress concentrates something we don&#8217;t want to want—when it transforms opium into heroin—it seems bad. But it&#8217;s the same process at work. [1]</p>

<p>No one doubts this process is accelerating, which means increasing numbers of things we like will be transformed into things we like too much. [2]</p>

<p>As far as I know there&#8217;s no word for something we like too much. The closest is the colloquial sense of &#8220;addictive.&#8221; That usage has become increasingly common during my lifetime. And it&#8217;s clear why: there are an increasing number of things we need it for. At the extreme end of the spectrum are crack and meth. Food has been transformed by a combination of factory farming and innovations in food processing into something with way more immediate bang for the buck, and you can see the results in any town in America. Checkers and solitaire have been replaced by World of Warcraft and FarmVille. TV has become much more engaging, and even so it can&#8217;t compete with Facebook.</p>

<p>The world is more addictive than it was 40 years ago. And unless the forms of technological progress that produced these things are subject to different laws than technological progress in general, the world will get more addictive in the next 40 years than it did in the last 40.</p>

<p>The next 40 years will bring us some wonderful things. I don&#8217;t mean to imply they&#8217;re all to be avoided. Alcohol is a dangerous drug, but I&#8217;d rather live in a world with wine than one without. Most people can coexist with alcohol; but you have to be careful. More things we like will mean more things we have to be careful about.</p>

<p>Most people won&#8217;t, unfortunately. Which means that as the world becomes more addictive, the two senses in which one can live a normal life will be driven ever further apart. One sense of &#8220;normal&#8221; is statistically normal: what everyone else does. The other is the sense we mean when we talk about the normal operating range of a piece of machinery: what works best.</p>

<p>These two senses are already quite far apart. Already someone trying to live well would seem eccentrically abstemious in most of the US. That phenomenon is only going to become more pronounced. You can probably take it as a rule of thumb from now on that if people don&#8217;t think you&#8217;re weird, you&#8217;re living badly.</p>

<p>Societies eventually develop antibodies to addictive new things. I&#8217;ve seen that happen with cigarettes. When cigarettes first appeared, they spread the way an infectious disease spreads through a previously isolated population. Smoking rapidly became a (statistically) normal thing. There were ashtrays everywhere. We had ashtrays in our house when I was a kid, even though neither of my parents smoked. You had to for guests.</p>

<p>As knowledge spread about the dangers of smoking, customs changed. In the last 20 years, smoking has been transformed from something that seemed totally normal into a rather seedy habit: from something movie stars did in publicity shots to something small huddles of addicts do outside the doors of office buildings. A lot of the change was due to legislation, of course, but the legislation couldn&#8217;t have happened if customs hadn&#8217;t already changed.</p>

<p>It took a while though—on the order of 100 years. And unless the rate at which social antibodies evolve can increase to match the accelerating rate at which technological progress throws off new addictions, we&#8217;ll be increasingly unable to rely on customs to protect us. [3] Unless we want to be canaries in the coal mine of each new addiction—the people whose sad example becomes a lesson to future generations—we&#8217;ll have to figure out for ourselves what to avoid and how. It will actually become a reasonable strategy (or a more reasonable strategy) to suspect everything new.</p>

<p>In fact, even that won&#8217;t be enough. We&#8217;ll have to worry not just about new things, but also about existing things becoming more addictive. That&#8217;s what bit me. I&#8217;ve avoided most addictions, but the Internet got me because it became addictive while I was using it. [4]</p>

<p>Most people I know have problems with Internet addiction. We&#8217;re all trying to figure out our own customs for getting free of it. That&#8217;s why I don&#8217;t have an iPhone, for example; the last thing I want is for the Internet to follow me out into the world. [5] My latest trick is taking long hikes. I used to think running was a better form of exercise than hiking because it took less time. Now the slowness of hiking seems an advantage, because the longer I spend on the trail, the longer I have to think without interruption.</p>

<p>Sounds pretty eccentric, doesn&#8217;t it? It always will when you&#8217;re trying to solve problems where there are no customs yet to guide you. Maybe I can&#8217;t plead Occam&#8217;s razor; maybe I&#8217;m simply eccentric. But if I&#8217;m right about the acceleration of addictiveness, then this kind of lonely squirming to avoid it will increasingly be the fate of anyone who wants to get things done. We&#8217;ll increasingly be defined by what we say no to.</p>

<p>Notes</p>

<p>[1] Could you restrict technological progress to areas where you wanted it? Only in a limited way, without becoming a police state. And even then your restrictions would have undesirable side effects. &#8220;Good&#8221; and &#8220;bad&#8221; technological progress aren&#8217;t sharply differentiated, so you&#8217;d find you couldn&#8217;t slow the latter without also slowing the former. And in any case, as Prohibition and the &#8220;war on drugs&#8221; show, bans often do more harm than good.</p>

<p>[2] Technology has always been accelerating. By Paleolithic standards, technology evolved at a blistering pace in the Neolithic period.</p>

<p>[3] Unless we mass produce social customs. I suspect the recent resurgence of evangelical Christianity in the US is partly a reaction to drugs. In desperation people reach for the sledgehammer; if their kids won&#8217;t listen to them, maybe they&#8217;ll listen to God. But that solution has broader consequences than just getting kids to say no to drugs. You end up saying no to science as well.</p>

<p>I worry we may be heading for a future in which only a few people plot their own itinerary through no-land, while everyone else books a package tour. Or worse still, has one booked for them by the government.</p>

<p>[4] People commonly use the word &#8220;procrastination&#8221; to describe what they do on the Internet. It seems to me too mild to describe what&#8217;s happening as merely not-doing-work. We don&#8217;t call it procrastination when someone gets drunk instead of working.</p>

<p>[5] Several people have told me they like the iPad because it lets them bring the Internet into situations where a laptop would be too conspicuous. In other words, it&#8217;s a hip flask. (This is true of the iPhone too, of course, but this advantage isn&#8217;t as obvious because it reads as a phone, and everyone&#8217;s used to those.)</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/06/12/bao-chi-zhuan-zhu/">保持专注</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-06-12T23:01:00+08:00" pubdate data-updated="true">Jun 12<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.paulgrahamcn.com/article/distration">保持专注</a></p>

<p>我一觉醒来，喝杯咖啡，看看新闻，然后查收邮件，接着再看看新闻，然后回复几封邮件，然后突然意识到快该吃午饭了，工作却没有什么实质进展。而且这种现象越来越严重。Ycombinator创始人Paul Graham也面临着类似的问题。</p>

<p>分心会导致拖延。很多人在无所事事的时候感到不自在；人们通过做些其他的事情来避开工作。</p>

<p>所以战胜拖延的一个办法就是消除分心的事物。但是可没那么简单，因为很多人都在努力让你分心。分心不是一成不变的障碍，你不可能像避开马路上的石头那样避开分心的事物。分心的事物会自己找上门来。</p>

<p>Chesterfield把摆放不当的东西称为垃圾。同样，在错误的时间出现的欲望就是分心。科技的不断进步带来了越来越多的分心事物。也就是说当我们学会避免一些分心事物的时候，总会有新的分心事物出现，就好比是抗药细菌一样。</p>

<p>比如电视，经过50年的不断改进，电视已经成为一种视觉毒品。我在13岁的时候意识到看电视会上瘾，就不再看电视了。但是我最近从书上看到普通美国人每天看四个小时的电视。人一生的四分之一的时间啊。</p>

<p>现在电视走向衰退了，但只是因为人们找到了更容易上瘾的办法来消磨时间。尤其危险的是电脑。这并不是巧合。大量的办公室员工坐在联网的电脑前，分心经常导致拖延。</p>

<p>至少对我而言，电脑曾经只是为工作专用。我只是为了接收邮件或者ftp文件才拨号上网，大部分时间都离线。我所做的一切就是写代码和编程。现在我感觉到好比有人又把电视摆到了我的桌子上。一点鼠标就可以得到极易上瘾的东西。在工作中遇到问题了？嗯，我想知道网上有什么新消息。最好上网查一下。</p>

<p>多年以来我一直避开那些浪费时间的东西，电视，游戏和新闻组（Usernet），但是我还是受到了分心的干扰，因为我根本没有意识到分心的存在。上网本来是很安全的事情，但是慢慢地变得越来越危险。有时候，我一觉醒来，喝杯咖啡，看看新闻，然后查收邮件，接着再看看新闻，然后回复几封邮件，然后突然意识到快该吃午饭了，工作却没有什么实质进展。而且这种现象越来越严重。</p>

<p>我用了很长时间才发现互联网是多么让人分心，因为这个问题是断断续续的。我经常把它当作一个偶尔出现的问题忽略掉。在一个项目中期，分心倒不算大问题。但是当我完成项目，决定下一步做什么的时候，互联网尤其让我抓狂。</p>

<p>人们没有意识到这种危险的另外一个原因就是因为它尚未遭到社会否定。如果我整个上午都坐在沙发上看电视，我会很快意识到这一点。这是一种明显的危险信号，有点像一个人喝闷酒。但是使用互联网看上去依然和工作没什么两样。</p>

<p>但是，我终于意识到互联网太让我分心了，我不得不去改变它。说实话，我不得不在我的分心事物黑名单中增加一个新程序：firefox
这个问题很棘手，因为大部分人需要使用互联网工作。如果你酗酒严重，你可以通过戒酒来解决问题。但是你不能通过绝食来解决暴食的问题。我不能像对待其他分心事物一样完全戒掉互联网。</p>

<p>首先我尝试用规则约束自己。比如，我告诉自己一天只上两次网。但是这些计划都无法长期奏效。最后总会有一些事情让我打破这个规则，然后又重蹈覆辙。</p>

<p>你不得不把上瘾的东西当成是有知觉的对手，他好比是你大脑里的一个小家伙，他总能找到让你“再犯”的办法。只要你给他留下活路，他总会死灰复燃。</p>

<p>关键问题似乎是视觉。大部分坏习惯都是由于缺乏自制力养成的。所以你必须克制自己，不给自己偷偷犯错的机会。必须要设定警报。</p>

<p>从长期来看，应对互联网分心问题的有效办法将是监控互联网活动的软件。但是我还发现了一个更加有效的解决办法：使用单独的电脑上网。</p>

<p>现在，我常用电脑上的无线宽带处于关闭状态，除非传送文件或者编辑网页才使用，我使用放在另外一间屋子里的另一台笔记本电脑查收邮件或者浏览网页。（最有意思的是，这台电脑是Steve Huffman编写Reddit时使用的电脑。当Steve和Alexis慈善拍卖旧笔记本时，我为Y Combinator博物馆买下了这些旧笔记本。）</p>

<p>我的规则是我可以在网上停留很长时间，只要是在那台笔记本上。事实证明这足够了，当我不得不坐在另一间屋子里查收邮件或浏览网页时，我会很清楚自己在做什么。至少对我而言，非常清楚每天上网超过一个小时是多么的困难。</p>

<p>我的常用电脑只用于工作，如果你也这么做，你很可能会惊讶于电脑断网后的感觉。坐在一台只能用于工作目的的电脑前让我保持警觉，因为它告诉我已经浪费了多少时间。</p>

<h1>哇。我在这台电脑上只能工作。好吧，赶紧工作吧。</h1>

<p>Disconnecting Distration</p>

<p>Note: The strategy described at the end of this essay didn&#8217;t work. It would work for a while, and then I&#8217;d gradually find myself using the Internet on my work computer. I&#8217;m trying other strategies now, but I think this time I&#8217;ll wait till I&#8217;m sure they work before writing about them.</p>

<p>May 2008</p>

<p>Procrastination feeds on distractions. Most people find it uncomfortable just to sit and do nothing; you avoid work by doing something else.</p>

<p>So one way to beat procrastination is to starve it of distractions. But that&#8217;s not as straightforward as it sounds, because there are people working hard to distract you. Distraction is not a static obstacle that you avoid like you might avoid a rock in the road. Distraction seeks you out.</p>

<p>Chesterfield described dirt as matter out of place. Distracting is, similarly, desirable at the wrong time. And technology is continually being refined to produce more and more desirable things. Which means that as we learn to avoid one class of distractions, new ones constantly appear, like drug-resistant bacteria.</p>

<p>Television, for example, has after 50 years of refinement reached the point where it&#8217;s like visual crack. I realized when I was 13 that TV was addictive, so I stopped watching it. But I read recently that the average American watches 4 hours of TV a day. A quarter of their life.</p>

<p>TV is in decline now, but only because people have found even more addictive ways of wasting time. And what&#8217;s especially dangerous is that many happen at your computer. This is no accident. An ever larger percentage of office workers sit in front of computers connected to the Internet, and distractions always evolve toward the procrastinators.</p>

<p>I remember when computers were, for me at least, exclusively for work. I might occasionally dial up a server to get mail or ftp files, but most of the time I was offline. All I could do was write and program. Now I feel as if someone snuck a television onto my desk. Terribly addictive things are just a click away. Run into an obstacle in what you&#8217;re working on? Hmm, I wonder what&#8217;s new online. Better check.</p>

<p>After years of carefully avoiding classic time sinks like TV, games, and Usenet, I still managed to fall prey to distraction, because I didn&#8217;t realize that it evolves. Something that used to be safe, using the Internet, gradually became more and more dangerous. Some days I&#8217;d wake up, get a cup of tea and check the news, then check email, then check the news again, then answer a few emails, then suddenly notice it was almost lunchtime and I hadn&#8217;t gotten any real work done. And this started to happen more and more often.</p>

<p>It took me surprisingly long to realize how distracting the Internet had become, because the problem was intermittent. I ignored it the way you let yourself ignore a bug that only appears intermittently. When I was in the middle of a project, distractions weren&#8217;t really a problem. It was when I&#8217;d finished one project and was deciding what to do next that they always bit me.</p>

<p>Another reason it was hard to notice the danger of this new type of distraction was that social customs hadn&#8217;t yet caught up with it. If I&#8217;d spent a whole morning sitting on a sofa watching TV, I&#8217;d have noticed very quickly. That&#8217;s a known danger sign, like drinking alone. But using the Internet still looked and felt a lot like work.</p>

<p>Eventually, though, it became clear that the Internet had become so much more distracting that I had to start treating it differently. Basically, I had to add a new application to my list of known time sinks: Firefox.</p>

<hr />

<p>The problem is a hard one to solve because most people still need the Internet for some things. If you drink too much, you can solve that problem by stopping entirely. But you can&#8217;t solve the problem of overeating by stopping eating. I couldn&#8217;t simply avoid the Internet entirely, as I&#8217;d done with previous time sinks.</p>

<p>At first I tried rules. For example, I&#8217;d tell myself I was only going to use the Internet twice a day. But these schemes never worked for long. Eventually something would come up that required me to use it more than that. And then I&#8217;d gradually slip back into my old ways.</p>

<p>Addictive things have to be treated as if they were sentient adversaries—as if there were a little man in your head always cooking up the most plausible arguments for doing whatever you&#8217;re trying to stop doing. If you leave a path to it, he&#8217;ll find it.</p>

<p>The key seems to be visibility. The biggest ingredient in most bad habits is denial. So you have to make it so that you can&#8217;t merely slip into doing the thing you&#8217;re trying to avoid. It has to set off alarms.</p>

<p>Maybe in the long term the right answer for dealing with Internet distractions will be software that watches and controls them. But in the meantime I&#8217;ve found a more drastic solution that definitely works: to set up a separate computer for using the Internet.</p>

<p>I now leave wifi turned off on my main computer except when I need to transfer a file or edit a web page, and I have a separate laptop on the other side of the room that I use to check mail or browse the web. (Irony of ironies, it&#8217;s the computer Steve Huffman wrote Reddit on. When Steve and Alexis auctioned off their old laptops for charity, I bought them for the Y Combinator museum.)</p>

<p>My rule is that I can spend as much time online as I want, as long as I do it on that computer. And this turns out to be enough. When I have to sit on the other side of the room to check email or browse the web, I become much more aware of it. Sufficiently aware, in my case at least, that it&#8217;s hard to spend more than about an hour a day online.</p>

<p>And my main computer is now freed for work. If you try this trick, you&#8217;ll probably be struck by how different it feels when your computer is disconnected from the Internet. It was alarming to me how foreign it felt to sit in front of a computer that could only be used for work, because that showed how much time I must have been wasting.</p>

<p>Wow. All I can do at this computer is work. Ok, I better work then.</p>

<p>That&#8217;s the good part. Your old bad habits now help you to work. You&#8217;re used to sitting in front of that computer for hours at a time. But you can&#8217;t browse the web or check email now. What are you going to do? You can&#8217;t just sit there. So you start working.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/06/12/javafeng-pi/">Java封皮</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-06-12T23:00:00+08:00" pubdate data-updated="true">Jun 12<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.paulgrahamcn.com/article/javacover">Java封皮</a></p>

<p>译者：<a href="http://www.sophiazheng.com">郑思</a> 转载请注明</p>

<p>这篇文章脱胎于我跟几个程序员的聊天：为什么Java总让人感觉奇怪？先声明，本文绝无批判Java之意，这可是一篇关于黑客嗅觉的案例研究。</p>

<p>日积月累，黑客们逐渐进化出神秘而敏锐的嗅觉，他们能闻出愉悦身心的好技术，也能辨出乏味技术的臭味儿。</p>

<p>我想，试着思考为什么Java散发出一种令人不快的气味，并将述诸文字，或许会很有趣。</p>

<p>一些读者觉得我的尝试挺有趣，毕竟，我写的东西之前还没人写过。还有一些人建议，最好还是别去碰我不懂的领域，不然我会引火烧身。因此，让我再次澄清一下，下文的主题并不是Java（天哪，这门语言我竟然从来都没码过！），而是黑客的嗅觉（对此我深思熟虑，想了不少）。</p>

<p>格言有云：“不可从封面妄自揣测书的内容。”这句话语出有典。有段时期，为了满足不同书商的不同品位，书籍以定制的平装硬皮封面装订。在那些日子里，你无法从封面上辨别一本书。但是，出版业大大地发展了，现今出版商正致力于让你一眼就能从门面上看出书里讲了些什么。</p>

<p>我在书店花了很多时间，我觉得，自己似乎明白了出版商想要通过一本书告诉我的。我没花在书店的时间，大部分都花在电脑前。我同意，在某种程度上，我学会了通过技术的门面去辨别技术的含量。</p>

<p>这或许仅仅是运气，但是我还是成功地从不少技术手中给自己赢得了时间，那些技术已被证明不过是个臭蛋。</p>

<p>到目前为止，Java对我来说看上去都挺像个臭蛋。</p>

<p>我的程序没有一个是用Java写成的，从来没有看过Java的参考书。尽管如此，我还是有一种预感，那就是，Java不会成为一门非常成功的语言。未来或许将揭示我的愚蠢；企图预测科技的走向是门危险的生意。但是，我愿意写下为什么我不喜欢Java的门面，当做时间胶囊，交由未来检验。</p>

<p>1、Java炒作过度。实际标准却没有得到提升。没有人不得不推动C语言，或Unix 又或HTML。一个真正的标准趋势在大多数人听到它之前，往往已经建立了。在黑客第六感的扫描仪里，Perl与Java一样伟大，甚至要伟大的多，仅仅是凭借它自身的语言优势。</p>

<p>2、Java的目标很低。Gosling明确地说，Java为使用C语言的程序员而设计，设计的并不难。设计该门语言的目标是，让它成为另一个C++。C从更高级的语言中提取了一些概念。就像Sitcom的创建者，又或垃圾食品、三天两夜游的创建者那样，Java语言的创建者有意识地为一群不如他们聪明的人设计了一个产品。从历史上来说，那些为其他人使用的语言下场很惨淡：cobol、PL/I, Pascal, Ada,C++。优秀的语言都为自己的创建器所设计：比如C、Perl，Smalltalk，Lisp。</p>

<p>3、Java别有有心。有人曾经说过，如果人们只在有话要说的时候，才写书，而不是在他们想写的时候写书，世界将会美好得多。诚如此言，我们在大多数时间里听到Java，并不是因为它是一门编程语言，而是因为它是Sun打破微软统治地位的战略计划的一部分。</p>

<p>4、没有程序员喜欢Java。C语言、Perl、Python、Smalltalk还有Lisp的程序员都喜欢自己所使用的语言。我还没听人说过他们发自内心热爱Java。</p>

<p>【2001年就有Python了？我勒个去。无知家庭主妇再次被震撼了。】</p>

<p>5、人们被迫使用Java。我认识一些使用Java的人，他们使用Java出于被迫。要么是用Java写的程序容易融到资金，要么是客户希望他们用Java编写程序，要么是管理人员让他们使用Java。这些人都是聪明人。假如某项技术很不错，他们绝对会二话不说，主动采用。</p>

<p>6、设计Java的人太多了。最好的编程语言通常都是由开发的小团体设计出来的。而Java似乎是由某个委员会运行管理的。如果时间证明Java是门不错的语言，这将是历史上头一个由委员会设计出优秀语言。</p>

<p>7、Java带着官僚主义的习性。凭我对Java浅薄的了解，该门语言在执行时有许多协议。一门好的语言真的不需如此。好语言让你能做出你想要的东西，还不会挡你的路。</p>

<p>8、Java是个伪君子。 现在，Sun假设Java就是基层，努力让Java看上去像Perl或Python，是一门开源语言。实际上，它在巨型公司的控制之下。因此，这门语言的单调乏味与一家大公司如出一辙。</p>

<p>9、Java为大型企业而设计。大型组织与黑客的目标并不相同。大型企业需要适合于平庸程序员组成的大型团队所使用的语言。这样的语言拥有速度限制，防止傻瓜损害他们的进度，就好像跟在U型牵引卡车后面。而黑客们只想要权力。历史上，为大型机构设计的语言（PL/I, Ada)输给了黑客们所使用的语言（C，perl). 原因: 今日的年轻黑客就是明日的CTO。</p>

<p>10、喜欢Java的人有问题。基本上，我所钦佩的程序员没有一个人喜欢Java。谁喜欢Java？那些身穿西服的商务人士，他们甚至不懂一门语言与另一门语言的差别，但他们了解，他们持续不断地听到Java的名字；大公司的程序员，他们看到有比C + +更好语言就会惊讶；还有叽叽喳喳的本科生，他们随时准备喜欢上一门帮助他们得到工作的语言（考试究竟会考些什么？）。这些人的意见跟风摇摆。</p>

<p>11、Java的父公司已经风烛残年。Sun的商业模式在两方面都遭到了削弱。与台式机使用同一类型的英特尔处理器很便宜，而且运行速度也足够当服务器了。作为Solaris服务器操作系统，FreeBSD似乎是个不错的开放系统。Sun的广告暗示，你需要工业强度的Sun服务器。如果广告是真的，那么雅虎该第一个买下Sun。但我在那里工作的时候，这里服务器不过是使用了FreeBSD的英特尔盒。Sun的未来大有问题。如果Sun的运行陷入困境，Java也会被拖下水。</p>

<p>12、国防部喜欢Java。国防部鼓励开发人员使用Java。这在我看来，这糟的不能再糟了。国防部保卫国家的工作干得很不赖（虽然价格不菲），但他们喜欢计划、程序和协议。他们的文化是黑客文化的对立面; 软件的问题上，他们往往会赌错。上一次，国防部最喜欢的编程语言是Ada。</p>

<p>记住，本文对Java的内容并未置评，但我批评了它的门面。我对Java了解不多，因此谈不上喜欢或不喜欢。上文讲述了我丝毫不渴望了解它的原因。</p>

<p>本文可能看起来稍显傲慢，因为我在了解语言之前，就甚至试图评论它。但是，这是所有程序员都必须做的事情。我们有太多的技术，不可能每样都学习。你要学会花时间从外在的迹象判断，这一门技巧是否值得你花时间学习。我也同样傲慢地放弃了COBOL，ADA，Visual Basic，IBM AS400，VRML，ISO 9000，SET协议，VMS系统，Novell NetWare与CORBA等等。它们只是看起来很可疑。</p>

<h1>我对Java的判断可能并不正确。它或许是一门由某个大公司扳倒竞争对手的语言；是由委员会设计、符合“主流”口味、捧到天上的语言；是一门被国防部宠爱的语言，同时仍然是一个整洁，优美，功能强大的语言，让我发自内心地喜欢用它编程。确有此种可能。但看上去可能甚微。</h1>

<p>Java&#8217;s Cover April 2001</p>

<p>This essay developed out of conversations I&#8217;ve had with several other programmers about why Java smelled suspicious. It&#8217;s not a critique of Java! It is a case study of hacker&#8217;s radar.</p>

<p>Over time, hackers develop a nose for good (and bad) technology. I thought it might be interesting to try and write down what made Java seem suspect to me.</p>

<p>Some people who&#8217;ve read this think it&#8217;s an interesting attempt to write about something that hasn&#8217;t been written about before. Others say I will get in trouble for appearing to be writing about things I don&#8217;t understand. So, just in case it does any good, let me clarify that I&#8217;m not writing here about Java (which I have never used) but about hacker&#8217;s radar (which I have thought about a lot).</p>

<p>The aphorism &#8220;you can&#8217;t tell a book by its cover&#8221; originated in the times when books were sold in plain cardboard covers, to be bound by each purchaser according to his own taste. In those days, you couldn&#8217;t tell a book by its cover. But publishing has advanced since then: present-day publishers work hard to make the cover something you can tell a book by.</p>

<p>I spend a lot of time in bookshops and I feel as if I have by now learned to understand everything publishers mean to tell me about a book, and perhaps a bit more. The time I haven&#8217;t spent in bookshops I&#8217;ve spent mostly in front of computers, and I feel as if I&#8217;ve learned, to some degree, to judge technology by its cover as well. It may be just luck, but I&#8217;ve saved myself from a few technologies that turned out to be real stinkers.</p>

<p>So far, Java seems like a stinker to me. I&#8217;ve never written a Java program, never more than glanced over reference books about it, but I have a hunch that it won&#8217;t be a very successful language. I may turn out to be mistaken; making predictions about technology is a dangerous business. But for what it&#8217;s worth, as a sort of time capsule, here&#8217;s why I don&#8217;t like the look of Java:</p>

<ol>
<li><p>It has been so energetically hyped. Real standards don&#8217;t have to be promoted. No one had to promote C, or Unix, or HTML. A real standard tends to be already established by the time most people hear about it. On the hacker radar screen, Perl is as big as Java, or bigger, just on the strength of its own merits.</p></li>
<li><p>It&#8217;s aimed low. In the original Java white paper, Gosling explicitly says Java was designed not to be too difficult for programmers used to C. It was designed to be another C++: C plus a few ideas taken from more advanced languages. Like the creators of sitcoms or junk food or package tours, Java&#8217;s designers were consciously designing a product for people not as smart as them. Historically, languages designed for other people to use have been bad: Cobol, PL/I, Pascal, Ada, C++. The good languages have been those that were designed for their own creators: C, Perl, Smalltalk, Lisp.</p></li>
<li><p>It has ulterior motives. Someone once said that the world would be a better place if people only wrote books because they had something to say, rather than because they wanted to write a book. Likewise, the reason we hear about Java all the time is not because it has something to say about programming languages. We hear about Java as part of a plan by Sun to undermine Microsoft.</p></li>
<li><p>No one loves it. C, Perl, Python, Smalltalk, and Lisp programmers love their languages. I&#8217;ve never heard anyone say that they loved Java.</p></li>
<li><p>People are forced to use it. A lot of the people I know using Java are using it because they feel they have to. Either it&#8217;s something they felt they had to do to get funded, or something they thought customers would want, or something they were told to do by management. These are smart people; if the technology was good, they&#8217;d have used it voluntarily.</p></li>
<li><p>It has too many cooks. The best programming languages have been developed by small groups. Java seems to be run by a committee. If it turns out to be a good language, it will be the first time in history that a committee has designed a good language.</p></li>
<li><p>It&#8217;s bureaucratic. From what little I know about Java, there seem to be a lot of protocols for doing things. Really good languages aren&#8217;t like that. They let you do what you want and get out of the way.</p></li>
<li><p>It&#8217;s pseudo-hip. Sun now pretends that Java is a grassroots, open-source language effort like Perl or Python. This one just happens to be controlled by a giant company. So the language is likely to have the same drab clunkiness as anything else that comes out of a big company.</p></li>
<li><p>It&#8217;s designed for large organizations. Large organizations have different aims from hackers. They want languages that are (believed to be) suitable for use by large teams of mediocre programmers&#8211; languages with features that, like the speed limiters in U-Haul trucks, prevent fools from doing too much damage. Hackers don&#8217;t like a language that talks down to them. Hackers just want power. Historically, languages designed for large organizations (PL/I, Ada) have lost, while hacker languages (C, Perl) have won. The reason: today&#8217;s teenage hacker is tomorrow&#8217;s CTO.</p></li>
<li><p>The wrong people like it. The programmers I admire most are not, on the whole, captivated by Java. Who does like Java? Suits, who don&#8217;t know one language from another, but know that they keep hearing about Java in the press; programmers at big companies, who are amazed to find that there is something even better than C++; and plug-and-chug undergrads, who are ready to like anything that might get them a job (will this be on the test?). These people&#8217;s opinions change with every wind.</p></li>
<li><p>Its daddy is in a pinch. Sun&#8217;s business model is being undermined on two fronts. Cheap Intel processors, of the same type used in desktop machines, are now more than fast enough for servers. And FreeBSD seems to be at least as good an OS for servers as Solaris. Sun&#8217;s advertising implies that you need Sun servers for industrial strength applications. If this were true, Yahoo would be first in line to buy Suns; but when I worked there, the servers were all Intel boxes running FreeBSD. This bodes ill for Sun&#8217;s future. If Sun runs into trouble, they could drag Java down with them.</p></li>
<li><p>The DoD likes it. The Defense Department is encouraging developers to use Java. This seems to me the most damning sign of all. The Defense Department does a fine (though expensive) job of defending the country, but they love plans and procedures and protocols. Their culture is the opposite of hacker culture; on questions of software they will tend to bet wrong. The last time the DoD really liked a programming language, it was Ada.</p></li>
</ol>


<p>Bear in mind, this is not a critique of Java, but a critique of its cover. I don&#8217;t know Java well enough to like it or dislike it. This is just an explanation of why I don&#8217;t find that I&#8217;m eager to learn it.</p>

<p>It may seem cavalier to dismiss a language before you&#8217;ve even tried writing programs in it. But this is something all programmers have to do. There are too many technologies out there to learn them all. You have to learn to judge by outward signs which will be worth your time. I have likewise cavalierly dismissed Cobol, Ada, Visual Basic, the IBM AS400, VRML, ISO 9000, the SET protocol, VMS, Novell Netware, and CORBA, among others. They just smelled wrong.</p>

<p>It could be that in Java&#8217;s case I&#8217;m mistaken. It could be that a language promoted by one big company to undermine another, designed by a committee for a &#8220;mainstream&#8221; audience, hyped to the skies, and beloved of the DoD, happens nonetheless to be a clean, beautiful, powerful language that I would love programming in. It could be, but it seems very unlikely.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/06/12/hu-lian-wang-cheng-xu-zhong-de-lisp/">互联网程序中的lisp</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-06-12T22:58:00+08:00" pubdate data-updated="true">Jun 12<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.paulgrahamcn.com/article/lispinweb">互联网程序中的lisp</a></p>

<p>互联网程序中的lisp</p>

<p>摘录自2001年4月在剑桥，MA的BBNlabs所作演讲
理想的语言</p>

<p>一个使用lisp写互联网程序的原因是：你“能”使用lisp。 当你写下一个只会在个人服务器上运行的程序时，你想用什么语言，就用什么语言。</p>

<p>在很长一段时间里，并没有太多语言可供撰写应用程序的程序员选择。编写应用程序意味着编写运行在桌面上的软件。 有一种固执的偏见认为，桌面软件必须使用与操作系统相同的语言编写。 例如，十年前，所有的应用程序都是用C语言撰写的。</p>

<p>现在，基于Web的应用使得上述情况发生了改变。只要你控制得了服务器， 你就可以用任何你想用的语言来写软件。这对你来说心安理得：因为你同时拥有操作系统和编译器的源代码。 如果语言与操作系统之间出了问题，你可以自己修复。</p>

<p>然而，新的自由是一把双刃剑。自由意味着你必须做出选择。 在以前，选择语言很容易。如果你是一个软件项目的负责人，而有些讨厌的家伙建议你使用一种你从来没用的语言来写软件，你只需对他们说：“那种语言一点儿也不实用，”就能结束争论。</p>

<p>现在，基于互联网的应用改变了一切。此刻，你对语言的选择权不得不屈服于市场的力量。 如果你还想对这股改变的趋势装作视而不见，还使用c或c++， 就像我们竞争对手的选择一样，那你就是在准备被时代抛弃。创业小公司只有使用更强大的语言才能制胜。</p>

<p>渐进式开发</p>

<p>使用lisp语言开发的软件带着某种开发风格。它的传统之一是采用渐进式的发展：尽快开始编写程序，越快越好，哪怕该程序暂时什么事情也完成不了。然后逐渐为程序添加主要功能，每一次改写之前的代码还能继续运行。</p>

<p>我觉得，这种编写方式让你迅速高效地编写出软件。 Lisp能将迅速高效的工作方式带入了使用它编写出的程序里，因为Lisp程序员已经这么工作了30年之久。</p>

<p>Viaweb编辑器是一个典型的渐进开发的产物。它始于一个120行的小程序，目的是为了生成网站。在我刚刚写完的一本书里的需要以网站为例子，于是我写了Viaweb。 最终，Viaweb编辑器成长为有约25,000行代码的程序。 我并不认为我有一两天时间能让停止现有代码，好让自己坐下来，改写所有代码。</p>

<p>整个开发过程是一个逐渐变化的长期过程。 这种发展方式非常符合网络程序的滚动发行方式。 这也是更高效的泛型编程方法。</p>

<p>互动的TopLevel</p>

<p>Lisp的互动TopLevel有助于快速开发软件。 但对我们而言，Lisp最大的优势或许是发掘bug。 正如我之前所说，在网络程序中，用户数据存储在你的服务器上，通常会不断重现出bug。</p>

<p>当客服拿着编辑器的错误报告来找我的时候，我会把Lisp代码装入解释器中，并以用户的账号登陆。 如果我能重现错误，我会中断循环，看看到底问题出在哪里。 通常，我可以立即修复错误，并发布一个修复补丁。 当我说“立即”，我的意思是，投诉的用户还没有挂断他的手机呢。</p>

<p>迅速修复错误为我们占据了相当有利的竞争地位。 如果我们能够快速找到并修正错误，而用户仍在讲电话， 我们就给用户成功留下了这一印象：程序的错误不过是他们自己想象出来的罢了。所以，有时我们告诉客服，请让用户重新登录，检查一下问题是否存在。 当然，等用户重新登录，他们使用的已经是新发布的版本了，错误早已修复，程序运行良好。 我知道这么做有点“卑鄙”，但同时也很有趣。</p>

<p>HTML的宏</p>

<p>Lisp的宏是我们的另一制胜点。我们在viaweb编辑器中广泛的使用了宏。 准确地描述，我们所使用的是一个“大宏”。我们非常依赖lisp；而宏会告诉你这种依赖究竟达到了何种程度。 因为，根本没有其他语言能拥有这样的宏。</p>

<p>一个我们使用宏的目的是生成HTML。宏与HTML彼此有种天然的默契。因为HTML是一个前缀表达式，这一点很像Lisp。HTML是递归的，这一点也很像Lisp。 因此，我们能在宏调用中调用宏，从生成最复杂的HTML，并且进程仍然可控。</p>

<p>嵌入语言</p>

<p>我们使用宏的另一大用途是嵌入语言——我们称其为Rtml。 （关于Rtml究竟代表些什么，解释版本不一。其实我是以Robert Morris的名字为它命名的。Rober Morris是Viaweb的共同创始人，他的用户名是Rtm）(Robert Morris, the other founder of Viaweb, whose username is Rtm.) 。我们软件的每一页面都是由RTML所写的程序生成的。 我们将这些程序称为模版，这样听起来就没那么吓人。其实，它们是如假包换的Lisp程序。Rtml是一个宏与内置的Lisp操作符的组合。</p>

<p>用户可以编写自己的Rtml模板，来实现他们所期望的网页外观。 我们生成了一个结构编辑器来操纵模板，这个编辑器很像用户在Interlisp中所使用的结构化编辑器。 对用户来说，他不必在自由模式下输入，只需要把现成的代码剪切、粘贴起来即可，不必担心语法错误。 这同时意味着，我们不需要显示底层的S表达式的括号：我们通过缩进来表示。 这样，这门语言就更易懂了。</p>

<p>我们特意设计Rtml，让它避免了运行错误： 每个Rtml程序都会生成一些网页，你可以不断调试网页，直至最后生成你想要的前端效果。</p>

<p>最开始，我们设想我们的用户是网站顾问，还设想他们会频繁使用Rtml。 因此，我们提供了不少默认模板，内含分块与项目网页等等， 目的是用户可以使用、修改，从而生成他想要的页面。</p>

<p>事实上，网络顾问并不喜欢Viaweb。顾问们，通常来说，都喜欢使用一般人很难上手的产品，这才能保证顾问会得到持续雇佣。 顾问们会访问我们的网站，发现我们的软件很容易使用， 它能让任何人在五分钟内建立起网上商店，他们便会说，我怎么可能用这么简单的玩意儿呢？ 因此，我们没在顾问身上赚到钱。相反，用户大部分都是终端用户，他们自己就是商人。 他们喜欢设计自己网站的感觉。他们不想学编程。他们只使用默认模板。</p>

<p>因此，Rtml最终没有变成程序的主界面。 它扮演了两个角色。首先，对于老练的用户来说，Rtml是只安全阀，提供完成内置模板无法提供的功能。在做viaweb的过程中，有人提出了一个相当有用的意见：用户始终希望升级，即使他们永远不会真的去用。 Rtml就是我们的升级路线。如果你想，你就能绝对控制您网页的每一个角落。</p>

<p>几百个用户中只有一个人会真的撰写自己的模板。这就提供给Rtml第二个优势。 通过查看这些用户如何修改内置模板，我们就可以知道我们需要还能给他们添加些什么。 我们最终的目标是：用户不需要使用Rtml。我们的内置模板应该提供出人们想要的一切内容。 以新的视角来观察，Rtml担任了警告者，它告诉我们，软件中还缺些什么。</p>

<p>编写者——我们是从Rtml的第三个优点中受益最多的人。 即使我们是唯一使用Rtml的人，设计这门语言也值了。 在软件中设计这样的一个抽象层为我们挣得了竞争优势。 首先，它使我们软件的设计干净、简介。我们的竞争对手使用C或Perl代码生成网页，而我们拥有高层语言来生成网页，同时指定页面样式。 这使得代码更干净，更容易修改。 我已经提到过，网络程序是通过渐进式的修改来发布的，渐进式修改要求我们了解修改的严重性。通过将代码分层设计，我们能更优雅地处理修改。 底层修改（也就是修改Rtml本身）影响甚广，也很少发生，通常需要编程者深思熟虑。而修改上层（模板代码）可以快速执行，无需担心太多后果。</p>

<p>Rtml很像Lisp，主要由Lisp宏组成。它的在线编辑器操作S表达式。 当人们运行模板时，模板就被编译成lisp函数。</p>

<p>Rtml在很大程度上依赖于关键字参数，因为那时我一直在思考Common Lisp的关键字参数，这一部分颇为棘手。由于网络软件的发布方式，我们必须设计易修改的软件。 Rtml本身很容易修改，就像该软件的其他部分一样。 大多数Rtml操作符设计为采用关键字参数。这一设定帮了我们大忙。 如果我要添加一个操作符的行为方式，只需要添加一个新的关键字参数， 现有的模板仍然可用。少数的Rtml操作符没有采取关键字参数， 因为我没想到日后有改变这些操作符的需求，可是结果总让我悔不当初。 如果我能从头再来，我想修改的事情之一是，让一切Rtml操作符都采用关键字参数。</p>

<p>事实上，我们在编辑器里嵌入了好几门其他语言。 其中一门语言是用以描述图片的，我们并没有将其暴露给用户。 Viaweb包含由C语言撰写的图像生成器，能够接收对图像的描述、创建图像、 并返回它的URL。我们也是使用S表达式来描述这些图像的。</p>

<p>闭包模拟子程序</p>

<p>使用网页作为UI的问题之一，是web页面的无状态属性。 我们使用词法闭包来模拟子程序行为。 如果你理解延续，那么我们所做的事情可以解释为， 我们以延续传递风格编写软件。</p>

<p>当大多数网络软件生成一个页面上的链接时，往往设想， 假如用户点击该链接，那么程序将要调用该CGI脚本及其参数。 而我们的软件生成链接时，则设想假如用户点击该链接，程序将运行这段代码。 这一段代码可以是任意一段代码，可能（事实上，通常情况下）也可以包含任意变量，并从上下文获取值。</p>

<p>我们是通过宏做到这一点的。宏带着包含闭包的初始参数，紧跟着一段代码。 代码将通过一个唯一ID存储在全局散列表中，这段代码的输出将通过文中的代码生成，并出现在一个链接里，链接的url包含了散列键。假若链接被点击，我们的软件会找到并调用相应的代码，然后继续这一循环。假如代码是闭包，则引用其上下文。 我们飞快地编写了CGI脚本。</p>

<p>到目前为止，我所说的听起来还很空洞，所以让我给你举个例子， 感受一下这一技术带来的显著差异。</p>

<p>在网络程序中，用户经常需要编辑多属性的对象。多数属性都可以表示为表单域或菜单。 例如，假设你编辑的对象代表一个人，你可能得到一个域储存姓名； 一个选择职称的菜单框，等等。</p>

<p>现在，有些对象带有Color属性，我们该怎么办？ 假如沿用普通的CGI脚本，那么这些属性都将集中在一个表单里， 底部带着个”更新”按钮，这么一来操作就很麻烦了。 你也可以使用一个文本字段，让用户手动输入RGB值， 但终端用户都不喜欢这么操作。 要不然，你可以设置一个包含可选颜色的菜单，但你必须限制颜色的数量。又或者你可以提供标准的色彩表，那么你需要256个菜单项，每个菜单项的名字都需要独一无二的命名。</p>

<p>Viaweb能够将一个颜色作为样本来代表当前值， 并跟随一个“修改”按钮。假设用户点击“修改”按钮， 他们就会来到带有色彩表的页面进行选择。 选择后，他们可以回到编辑对象属性的页面，发现颜色已经改变。 这就是我所说的闭包模拟子程序行为。 看起来，软件让用户选择一个颜色，并返回。实际并非如此；程序生成一个新的CGI调用，但对用户而言，我们正在处理一个子程序。我们写代码的方式表达出，假如用户点击了链接，并前往颜色选择页面，最后返回原有页面。 我只举了我们使用该技术的一个例子。 总而言之，这一技术让我们的程序看起来远比竞争对手更复杂。</p>

<p>===================================</p>

<p>Lisp in Web-Based Applications</p>

<p>Paul Graham</p>

<p>(This is an excerpt of a talk given at BBN Labs in Cambridge, MA, in
April 2001.)</p>

<p>Any Language You Want</p>

<p>One of the reasons to use Lisp in writing Web-based applications
is that you <em>can</em> use Lisp.  When you&#8217;re writing software that is
only going to run on your own servers, you can use whatever language
you want.</p>

<p>For a long time programmers didn&#8217;t have a lot of choice about what
language to use for writing application programs.  Until recently,
writing application programs meant writing software to run on
desktop computers.  In desktop software there was a strong bias
toward writing the application in the same language as the operating
system.  Ten years ago, for all practical purposes, applications
were written in C.</p>

<p>With Web-based applications, that changes.  You control the servers,
and you can write your software in any language you want.  You can
take it for granted now that you have the source code of both your
operating system and your compilers.  If there does turn out to be
any kind of problem between the language and the OS, you can fix
it yourself.</p>

<p>This new freedom is a double-edged sword, however.  Having more
choices means that you now have to think about which choice to
make.  It was easier in the old days.  If you were in charge of a
software project, and some troublesome person suggested writing
the software in a different language from whatever you usually
used, you could just tell them that it would be impractical, and
that would be the end of it.</p>

<p>Now, with server-based applications, everything is changed.  You&#8217;re
now subject to market forces in what language you choose.  If you
try to pretend that nothing has changed, and just use C and C++,
like most of our competitors did, you are setting yourself up for
a fall.  A little startup using a more powerful language will eat
your lunch.</p>

<p>Incremental Development</p>

<p>There is a certain style of software development associated with
Lisp.  One of its traditions is incremental development:  you start
by writing, as quickly as possible, a program that does almost
nothing.  Then you gradually add features to it, but at every step
you have working code.</p>

<p>I think this way you get better software, written faster.  Everything
about Lisp is tuned to this style of programming, because Lisp
programmers have worked this way for at least thirty years.</p>

<p>The Viaweb editor must be one of the most extreme cases of incremental
development.  It began with a 120-line program for generating Web
sites that I had used in an example in a book that I finished just
before we started Viaweb.  The Viaweb editor, which eventually grew
to be about 25,000 lines of code, grew incrementally from this
program.  I never once sat down and rewrote the whole thing.  I
don&#8217;t think I was ever more than a day or two without running code.
The whole development process was one long series of gradual changes.</p>

<p>This style of development fits well with the rolling releases that
are possible with Web-based software.  It&#8217;s also a faster way to
get software written generally.</p>

<p>Interactive Toplevel</p>

<p>Lisp&#8217;s interactive toplevel is a great help in developing software
rapidly.  But the biggest advantage for us was probably in finding
bugs.  As I mentioned before, with Web-based applications you have
the users&#8217; data on your servers and can usually reproduce bugs.</p>

<p>When one of the customer support people came to me with a report
of a bug in the editor, I would load the code into the Lisp
interpreter and log into the user&#8217;s account.  If I was able to
reproduce the bug I&#8217;d get an actual break loop, telling me exactly
what was going wrong.  Often I could fix the code and release a
fix right away.  And when I say right away, I mean while the user
was still on the phone.</p>

<p>Such fast turnaround on bug fixes put us into an impossibly tempting
position.  If we could catch and fix a bug while the user was still
on the phone, it was very tempting for us to give the user the
impression that they were imagining it.  And so we sometimes (to
their delight) had the customer support people tell the user to
just try logging in again and see if they still had the problem.
And of course when the user logged back in they&#8217;d get the newly
released version of the software with the bug fixed, and everything
would work fine.  I realize this was a bit sneaky of us, but it
was also a lot of fun.</p>

<p>Macros for Html</p>

<p>Lisp macros were another big win for us.  We used them very
extensively in the Viaweb editor.  It could accurately be described
as one big macro.  And that gives you an idea of how much we depended
on Lisp, because no other language has macros in the sense that
Lisp does.</p>

<p>One way we used macros was to generate Html.  There is a very
natural fit between macros and Html, because Html is a prefix
notation like Lisp, and Html is recursive like Lisp.  So we had
macro calls within macro calls, generating the most complicated
Html, and it was all still very manageable.</p>

<p>Embedded Languages</p>

<p>Another big use for macros was the embedded language we had for
describing pages, called Rtml.  (We made up various explanations
for what Rtml was supposed to stand for, but actually I named it
after Robert Morris, the other founder of Viaweb, whose username
is Rtm.)</p>

<p>Every page made by our software was generated by a program written
in Rtml.  We called these programs templates to make them less
frightening, but they were real programs.  In fact, they were Lisp
programs.  Rtml was a combination of macros and the built-in Lisp
operators.</p>

<p>Users could write their own Rtml templates to describe what they
wanted their pages to look like.  We had a structure editor for
manipulating these templates, a lot like the structure editor they
had in Interlisp.  Instead of typing free-form text, you cut and
pasted bits of code together.  This meant that it was impossible
to get syntax errors.  It also meant that we didn&#8217;t have to display
the parentheses in the underlying s-expressions:  we could show
structure by indentation.  By this means we made the language look
a lot less threatening.</p>

<p>We also designed Rtml so that there could be no errors at runtime:
every Rtml program yielded some kind of Web page, and you could
debug it by hacking it until it produced the page you meant it to.</p>

<p>Initially we expected our users to be Web consultants, and we
expected them to use Rtml a lot.  We provided some default templates
for section pages and item pages and so on, and the idea was that
the users could take them and modify them to make whatever pages
they wanted.</p>

<p>In fact it turned out that Web consultants didn&#8217;t like Viaweb.
Consultants, as a general rule, like to use products that are too
hard for their clients to use, because it guarantees them ongoing
employment.  Consultants would come to our Web site, which said
all over it that our software was so easy to use that it would let
anyone make an online store in five minutes, and they&#8217;d say, there&#8217;s
no way we&#8217;re using that.  So we didn&#8217;t get a lot of interest from
Web consultants.  Instead the users all tended to be end-users,
the actual merchants themselves.  They loved the idea of being in
control of their own Web sites.  And this kind of user did not want
to do any kind of programming.  They just used the default templates.</p>

<p>So Rtml didn&#8217;t end up being the main interface to the program.  It
ended up playing two roles.  First of all, it was an escape valve
for the really sophisticated users, who wanted something our built-in
templates couldn&#8217;t provide.  Somewhere in the course of doing
Viaweb, someone gave me a very useful piece of advice: users always
want an upgrade path, even though as a rule they&#8217;ll never take it.
Rtml was our upgrade path.  If you wanted to, you could get absolute
control over everything on your pages.</p>

<p>Only one out of every couple hundred users actually wrote their
own templates.  And this led to the second advantage of Rtml.  By
looking at the way these users modified our built-in templates, we
knew what we needed to add to them.  Eventually we made it our goal
that no one should ever have to use Rtml.  Our built-in templates
should do everything people wanted.  In this new approach, Rtml
served us as a warning sign that something was missing in our
software.</p>

<p>The third and biggest win from using Rtml was the advantage we
ourselves got from it.  Even if we had been the only people who
used Rtml, it would have been very much worth while writing the
software that way.  Having that extra layer of abstraction in our
software gave us a big advantage over competitors.  It made the
design of our software much cleaner, for one thing.  Instead of
just having bits of actual C or Perl code that generated our Web
pages, like our competitors, we had a very high-level language for
generating Web pages, and our page styles specified in that.  It
made the code much cleaner and easier to modify.  I&#8217;ve already
mentioned that Web-based applications get released as a series of
many small modifications.  When you do that you want to be able to
know how serious any given modification is.  By dividing your code
into layers, you get a better handle on this.  Modifying stuff in
lower layers (Rtml itself) was a serious matter to be done rarely,
and after much thought.  Whereas modifying the top layers (template
code) was something you could do quickly without worrying too much
about the consequences.</p>

<p>Rtml was a very Lispy proposition.  It was mostly Lisp macros, to
start with.  The online editor was, behind the scenes, manipulating
s-expressions.  And when people ran templates, they got compiled
into Lisp functions by calling compile at runtime.</p>

<p>Rtml even depended heavily on keyword parameters, which up to that
time I had always considered one of the more dubious features of
Common Lisp.  Because of the way Web-based software gets released,
you have to design the software so that it&#8217;s easy to change.  And
Rtml itself had to be easy to change, just like any other part of
the software.  Most of the operators in Rtml were designed to take
keyword parameters, and what a help that turned out to be.  If I
wanted to add another dimension to the behavior of one of the
operators, I could just add a new keyword parameter, and everyone&#8217;s
existing templates would continue to work.  A few of the Rtml
operators didn&#8217;t take keyword parameters, because I didn&#8217;t think
I&#8217;d ever need to change them, and almost every one I ended up
kicking myself about later.  If I could go back and start over from
scratch, one of the things I&#8217;d change would be that I&#8217;d make every
Rtml operator take keyword parameters.</p>

<p>We had a couple embedded languages within the editor, in fact.
Another one, which we didn&#8217;t expose directly to the users, was for
describing images.  Viaweb included an image generator, written in
C, that could take a description of an image, create that image,
and return its url.  We used s-expressions to describe these images
as well.</p>

<p>Closures Simulate Subroutines</p>

<p>One of the problems with using Web pages as a UI is the inherent
statelessness of Web sessions.  We got around this by using lexical
closures to simulate subroutine-like behavior.  If you understand
about continuations, one way to explain what we did would be to
say that we wrote our software in continuation-passing style.</p>

<p>When most web-based software generates a link on a page, it tends
to be thinking, if the user clicks on this link, I want to call
this cgi script with these arguments.  When our software generated
a link, it could think, if the user clicks on this link, I want to
run this piece of code.  And the piece of code could an arbitrary
piece of code, possibly (in fact, usually) containing free variables
whose value came from the surrounding context.</p>

<p>The way we did this was to write a macro that took an initial
argument expected to be a closure, followed by a body of code.
The code would then get stored in a global hash table under a unique
id, and whatever output was generated by the code in the body would
appear within a link whose url contained that hash key.  If that
link was the next one clicked on, our software would find and call
the corresponding bit of code, and the chain would continue.
Effectively we were writing cgi scripts on the fly, except that
they were closures that could refer to the surrounding context.</p>

<p>So far this sounds very theoretical, so let me give you an example
of where this technique made an obvious difference.  One of the
things you often want to do in Web-based applications is edit an
object with various types of properties.  Many of the properties
of an object can be represented as form fields or menus.  If you&#8217;re
editing an object representing a person, for example, you might
get a field, for their name, a menu choice for their title, and so
on.</p>

<p>Now what happens when some object has a property that is a color?
If you use ordinary cgi scripts, where everything has to happen on
one form, with an Update button at the bottom, you are going to
have a hard time.  You could use a text field and make the user
type an rgb number into it, but end-users don&#8217;t like that.  Or you
could have a menu of possible colors, but then you have to limit
the possible colors, or otherwise even to offer just the standard
Web colormap, you&#8217;d need 256 menu items with barely distinguishable
names.</p>

<p>What we were able to do, in Viaweb, was display a color as a swatch
representing the current value, followed by a button that said
&#8220;Change.&#8221;  If the user clicked on the Change button they&#8217;d go to
a page with an imagemap of colors to choose among.  And after they
chose a color, they&#8217;d be back on the page where they were editing
the object&#8217;s properties, with that color changed.  This is what I
mean about simulating subroutine-like behavior.  The software could
behave as if it were returning from having chosen a color.  It
wasn&#8217;t, of course; it was making a new cgi call that looked like
going back up a stack.  But by using closures, we could make it
look to the user, and to ourselves, as if we were just doing a
subroutine call.  We could write the code to say, if the user clicks
on this link, go to the color selection page, and then come back
here.  This was just one of the places were we took advantage of
this possibility.  It made our software visibly more sophisticated
than that of our competitors.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/06/12/pythonde-shen-mi/">Python的神秘</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-06-12T22:57:00+08:00" pubdate data-updated="true">Jun 12<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.paulgrahamcn.com/article/pypar">Python的神秘</a></p>

<p>Python悖论——计算机也有方言？</p>

<p>在最近一次访谈中，我有个说法让很多人不爽：开发Python项目的程序员比搞Java项目的聪明。</p>

<p>我可不是说Java程序员就笨。我只是说Python程序员聪明。学一门新的编程语言费时费力。学Python的人绝不是为了找工作才学的，而是因为他们打心底里就喜欢编程，又不满意已经会的语言。</p>

<p>这正是那种公司需要的程序员。我找不到贴切地说法，姑且称之为Python悖论：如果一家公司刻意采用深奥的语言编程，就能招到更优秀的程序员，因为只有真心实意学编程语言的人才会来应聘。对于程序员，这个悖论更是显而易见：要想找个好工作，就要学一种不是仅仅为了找工作的语言。</p>

<p>迄今为止，只有少数几家聪明的公司意识到了这一点。但它们现在的确也用这种选拔方式：这些公司恰恰是程序员们趋之若鹜的。例如谷歌。发布Java编程招聘的时候，他们也要求有Python的经验。</p>

<p>我有个朋友，常用的语言几乎没有他不会的，但大部分项目他都用Python。他说，最主要的原因是喜欢其源代码。这种选择语言的理由貌似很无聊。不过还是有点道理的：编程的时候，读代码花的时间比写代码多。你堆砌源代码的方式就像雕塑家堆粘土一样。粘土里疙瘩太多，雕塑家就会抓狂，源代码太烂，严谨的程序员也会发疯。</p>

<p>说到源代码太烂，人们自然就会想到Perl。不过我所指的不是Perl那种肤浅的烂。句法僵化算不上真烂，基于错误概念编程才令人痛不欲生。Perl就像是卡通娃娃口吐秽语，但它也有Python所不及的理念。</p>

<p>点到为止。这两种语言当然都在发展。但它们，以及Ruby (还有Icon、Joy、J、Lisp和Smalltalk)，都有一个共同点，创造它们、使用它们的人都是真正关心编程的人。而这些人往往是编程高手。</p>

<p>================================</p>

<p>August 2004 In a recent talk I said something that upset a lot of people: that you could get smarter programmers to work on a Python project than you could to work on a Java project.</p>

<p>I didn&#8217;t mean by this that Java programmers are dumb. I meant that Python programmers are smart. It&#8217;s a lot of work to learn a new programming language. And people don&#8217;t learn Python because it will get them a job; they learn it because they genuinely like to program and aren&#8217;t satisfied with the languages they already know.</p>

<p>Which makes them exactly the kind of programmers companies should want to hire. Hence what, for lack of a better name, I&#8217;ll call the Python paradox: if a company chooses to write its software in a comparatively esoteric language, they&#8217;ll be able to hire better programmers, because they&#8217;ll attract only those who cared enough to learn it. And for programmers the paradox is even more pronounced: the language to learn, if you want to get a good job, is a language that people don&#8217;t learn merely to get a job.</p>

<p>Only a few companies have been smart enough to realize this so far. But there is a kind of selection going on here too: they&#8217;re exactly the companies programmers would most like to work for. Google, for example. When they advertise Java programming jobs, they also want Python experience.</p>

<p>A friend of mine who knows nearly all the widely used languages uses Python for most of his projects. He says the main reason is that he likes the way source code looks. That may seem a frivolous reason to choose one language over another. But it is not so frivolous as it sounds: when you program, you spend more time reading code than writing it. You push blobs of source code around the way a sculptor does blobs of clay. So a language that makes source code ugly is maddening to an exacting programmer, as clay full of lumps would be to a sculptor.</p>

<p>At the mention of ugly source code, people will of course think of Perl. But the superficial ugliness of Perl is not the sort I mean. Real ugliness is not harsh-looking syntax, but having to build programs out of the wrong concepts. Perl may look like a cartoon character swearing, but there are cases where it surpasses Python conceptually.</p>

<p>So far, anyway. Both languages are of course moving targets. But they share, along with Ruby (and Icon, and Joy, and J, and Lisp, and Smalltalk) the fact that they&#8217;re created by, and used by, people who really care about programming. And those tend to be the ones who do it well.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/06/12/chuang-ye-jiu-jing-shi-shen-ma/">创业究竟是神马</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-06-12T22:55:00+08:00" pubdate data-updated="true">Jun 12<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.paulgrahamcn.com/article/really">创业究竟是神马</a></p>

<p>我并不清楚对创业学校有什么要说的。所以我决定问问我们所资助的这些创业者，还有什么是我没有写过的？</p>

<p>我正处在一个不同寻常的位置，让我恰好可以来验证我所写的关于创业的那些文章。我希望我在其他话题上所写的文章也是正确的，可是我没有办法验证他们。但我写的关于创业的文章则每6个月就能被大约70人所验证。</p>

<p>所以我给每个创业者发了一份电子邮件，问他们在进行一次创业的过程中，什么最令他们感到意外？这么多人问我是不是哪里搞错了，因为如果我把每件事都解释清楚了，应该没有什么能让他们感到意外的。</p>

<p>我很自豪地告诉你们我收到这样一份回复：</p>

<p>最令我吃惊的是几乎所有的事情都能被准确的预计到。</p>

<p>但坏消息是我收到其他100多份回复列出了他们所遇到的惊喜。</p>

<p>这些回复都有非常相同的模式；很明显的，人们总是被相同的事实所惊讶道。以下是它们中最常见的。</p>

<p>1.小心你的合伙人</p>

<p>这一条被最多创业者提到。通常有两种反馈：你需要小心挑选你的合伙人，并且你需要努力维持你们之间的伙伴关系。</p>

<p>当人们选择合伙人时，他们总是希望花更多的时间在人品和性格上，而不是能力。而那些失败的创业案例中尤其能体现出这一点。从中我们能得到的教训就是：永远不要选那些会半途离开的人作为合伙人。</p>

<p>这里有个典型的回复：</p>

<p>只有当你和一个人一起创业后你才能看出一个人真正的面目。为什么说人品是那么重要呢，因为在创业这个环境中比其他任何环境都更能测试人性。一位创业者曾明确的说过，创业者之间的关系比能力更为重要：</p>

<p>我宁可和一个朋友创业，也不要和一个能力很强的陌生人合伙。创业是如此的艰难而又情绪化的一个事情，友谊所带来的感情的纽带和社交的支持足以弥补能力上的差异。</p>

<p>我们很早已经就意识到这一点了。如果你看看那些风投申请书你会发现，其中关于合伙人之间信任以及相互关系的问题要比他们能力的问题多得多。</p>

<p>在那些成功的创业案例中，创业者很少谈如何选择合伙人，而是更多的谈论如何努力维持他们之间的良好关系。</p>

<p>其中有件事让我很意外，那就是创业伙伴之间的关系如何从朋友进而成为夫妻。我和我合伙人的关系在最初的时候仅仅是每时每刻都会看得到的朋友而已，一起担忧公司的财务状况，一起清理垃圾，公司就像我们孩子一样。我曾经这样总结道：“这就像我们虽然已经结婚了但却没有做爱。”</p>

<p>很多人都用结婚这个词，创业者之间的关系要比你通常看到的同事之间的关系更为紧密。部分原因是因为两者之间，所承受的要压力，差得很多，而另一部分原因则是在最初的时候创业者就是公司的全部了。所以它们之间的关系式建立在物质之上而且小心的维系着的。这是一切的基础。</p>

<p>2.创业将会成为你生活的全部</p>

<p>就像创业者之间的感情要比普通同事之间的感情更紧密一样，创业者和公司之间的关系也更为紧密。创业并不像打工或者上学那样，因为一旦你开始了就再也停不下来了。其中经历对大多数人来说太过于陌生以至于直到事情发生了他们才意识到。</p>

<p>我当初并没有意识到我会将工作时间的每一分每一秒都花在创业上。当你的公司在和别人的公司PK时，你就会进入一个完全不同的生活方式。而这一情况也会因为创业阶段快速的生活节奏而愈演愈烈，甚至时间看上去都变慢了。</p>

<p>我认为最令我意外的事情就是一个人通过创业，他对时间的看法会发生很大的变化。就拿我的创业来讲吧，我记得时间看上去就像在慢慢蠕动，一个月对我来说就是很长一段时间了。</p>

<p>在最好的案例中，甚至存在达到忘我境界的人。连你自己也会对你沉浸其中的程度感到吃惊，你会不分日夜的考虑工作的事情，但却一点也不觉得是在工作。</p>

<p>虽然我不得不说明，这引用了我们今年夏天资助的一位创业着的讲话。再过几年也许他就没法那么高兴了。</p>

<p>3.这是一个大悲大喜的事</p>

<p>还有一个事也让很多人感到惊讶，情绪的波动要比他们预想的极端得多。</p>

<p>在创业中，事情一会看上去很完美，而下一刻又让人感觉毫无希望。这里的下一刻我指的是几个小时之后。对我来说情绪的波动是最大的意外。头一天我可能还想象自己的公司是下一个谷歌，做梦想着买小岛；之后又在想怎么和我们所爱的人说出自己即将到来失败。就这样不停的循环。</p>

<p>很明显的，最难熬过去的是那些失落的时候。对很多创业者来说如何在困难的日子里激励每一个人，是最大的挑战。比如，在经过一段时间后，如果你不能取得一些成功来激励你自己，那么失败就会将你淘汰出局。</p>

<p>我对创业者最基本的建议是“不要死”，但维持一个公司在困境中生存下去的能量并不是无穷无境的。这些能量都是从创业者身上压出来的。</p>

<p>你能承受的压力总是有个极限的。如果你达到了你的极限，那么你就不能再做更多的事了。但这并不是世界末日，很多著名的创业者在他们的创业路途上都曾经有过几次失败的经历。</p>

<p>4.创业可能很有意思</p>

<p>好消息是，在你情绪高潮的时候也的确是非常的快乐。几位创业者说最令他们吃惊的是创业居然可以如此有趣：</p>

<p>我想你可能忽略了创业是多么有趣这一事实。我比我任何一个没有创业的朋友都更能从工作中得到满足感。</p>

<p>而这些创业者最喜欢的是工作的自由性：</p>

<p>我最惊讶的是在与之前所做的那种普通雇员时相比，做一份如此有挑战性，创造性以及我所认同的工作，我会感觉如此良好。</p>

<p>坦白来说，如果我在这里误导了人们，那么我宁愿不去修改这个错误。我宁可人人都觉得创业是一项无聊且困难的工作，而不是让他们抱着一种有趣的期望来创业。因为几个月后，他们会说“这应该是有趣的？你在开玩笑么？”</p>

<p>事实是，对大多数人来说创业并不有趣。我们在申请程序中所极力想要做的，就是剔除那些不喜欢创业的人，不管是因为我们的原因还是他自己的原因使得他不喜欢。</p>

<p>最好的方式来看待这个问题可能是这样的：如果你沉浸到创业中，那么开始一次创业是有趣的，一次生存训练课程是有趣的。换句话说，如果你没有沉浸其中，那么它一点都不有趣。</p>

<p>5.坚持是关键</p>

<p>很多创业者对坚持在创业中的重要程度而感到惊讶。这既是一个正面的也是一个负面的意外。</p>

<p>每个人都说你需要下多大的决心，需要多大的弹性。但经历过这一切以后，我意识到，这些所宣称的程度还远远不够。</p>

<p>并且关于坚持能解决什么程度的问题：如果你坚持不懈，那么即使是你无法控制的问题，例如，移民问题，也能够迎刃而解。</p>

<p>几位创业者都提到了，坚持要比聪明重要得多。</p>

<p>而我呢，我一次又一次的意识到坚持比智力要重要得太多太多。 一般来说，在申请中这里指的不仅仅是智力也包括能力，这也是为什么很多人说个性在选择合伙人中最重要。</p>

<p>6.眼光要远</p>

<p>你需要坚持，因为所有的事都会花费比你预想的更多的时间。很多人则对此感到意外</p>

<p>就我自己而言，总是频繁地对每件事能花费那么多时间而感到意外。假设你的产品并没有像极个别产品那样发生爆炸性的增长。所有的事，从开发到销售（尤其是销售）看上去比你预期的要多花2到3倍的时间。</p>

<p>创业者对此感到意外的原因之一是他们自己工作得很快，他们希望其他人也能有这种速度。当一个创业公司接触到一个多分枝的组织，例如一个大公司和一个风投基金的时候，就有很大数量的公司被淘汰出局。这就是为什么很多集资和企业加市场扼杀了那么多创业公司的原因。</p>

<p>但我认为绝大多数创业者感到意外的原因是因为他们过于自信了。他们认为他们会像YouTube 和facebook一样马上就会取得成功。如果你告诉他们只有百分之一的创业企业能有那样的发展轨迹，那么他们会告诉你“我们就要成为那百分之一”</p>

<p>可能他们会愿意听听最成功的创业者之一：在我开始创业之前最让我不明白的事情就是，坚持到底是这场游戏的全部。对大多数成功的创业者来说，这是一个漫长的过程，最少也要3年而一般来说都要5年以上。</p>

<p>当然长期的考虑问题也有它积极的一面。你并不需要不停的修改重新设定你的计划，使每件事都花费更多的时间。如果你耐心地工作，那么你就不会那么有压力，也就能更好的完成工作。</p>

<p>因为在放松的情况下，我们就更容易从工作中获得乐趣。失败就是笨拙紧张能量的聚合，而这些能量则是由不能失败的绝望的需求产生的。我们应该把注意力放在怎样为我们的产品，公司，职员和客户做到最好。</p>

<p>这就是为什么当你达到你的预期收益率时，你会觉得一切都变得更顺利了，你会进入一种完全不同的工作模式。</p>

<p>7.很多琐碎的事情</p>

<p>我们常常强调很少有创业公司仅仅因为他们有一个很好的创意就获得成功的。我认为创业者现在就应该把这个刻进他们的脑子里。很多人创业以后才发现在创业中这条也是适用的。你必须做很多不同的事情：</p>

<p>与其说创业是一个富有吸引力的事不如说是件苦差事。如果你随机的挑个时间来找我，那我很有可能在在处理瑞典语windows中一个奇怪的DLL文件加载问题，或者在董事会的前一夜，处理EXCEL表单中金融模型的一个错误，而不是突然有一个公司策略的好主意。</p>

<p>绝大多数的IT创业者希望把他们所有的时间用在编写程序上。事实上你不可能做到这样，除非你的创业失败了。换句话说：如果你把你所有的时间都用在编程上， 你必定会失败。</p>

<p>当然，这条定律并不仅仅针对编程。很少有仅仅是一个聪明的程序员就能保证创业的成功：</p>

<p>我从我的经历中学到一点，永远不要将创业的成功赌在一个人的特长，一笔交易或者任何类似的东西上。创业从来就不是由一件事决定的。每件事对其都有所助益，而你要做的就是不停的做各种各样的事直到你达到一定程度。</p>

<p>即使在那些极少数案例中，因为一个出色的程序员而获得成功。你也不太可能在事前就知道。事实上根本就没有所谓的决定性的一点。或者至少你事先不会知道是哪一点。</p>

<p>所以最好的策略就是尝试很多不同的事情。不要把鸡蛋放在同一个篮子里，这个道理并不那么简单，即使在你知道哪个篮子是最好的，的情况下它也仍然适用，更何况在创业中你并不知道哪个是最好的。</p>

<p>8.从小事做起</p>

<p>很多创业者都提到要从最容易成功的事做起。到了这个时候，每个人都知道应该不断地快速发布产品。在我们风投行业更是如此。但依然有很多人因为没有这么做而被淘汰。完成一件最小的事也可以被认为是一次完整的应用然后把它装箱送出去。</p>

<p>为什么人们总是在第一版的时候花费那么多时间呢？主要是因为自豪，他们不愿意在还能有所改进的时候就把产品发布到市场上。他们担心人们可能会指责这些缺陷。但你必须克服这样的心理。在一开始做一些简单的事情，并不意味着你没有做有意义的，可辩解的或者有价值的事情。不要担心人么会讲什么。如果你的第一版做得很完美，那么改进它就会变得毫无乐趣。你会等得太久而无法发布你的产品。</p>

<p>一位创业者说对任何项目来说都应该遵循这一原则，并不仅仅是创业的时候。对此我也深有同感。</p>

<p>现在，当我在编程的时候，我努力想：“我怎么能写这样的程序呢，如果人们看到的话，会为其只有那么小而感到惊讶。”</p>

<p>过度设计对产品来说就是一剂毒药。这不像你为额外的信用而做额外的工作。这更像是你说了个慌，然后你不得不记住它，防止你自相矛盾。</p>

<p>9.使用户参与其中</p>

<p>产品开发就是一场与用户的对话，而通常这一过程并不会发生，直到你发布产品。在发布产品之前，你就像一个在把他第一稿的素描给目击人看之前的警察局的拼图师。</p>

<p>快速的发布产品是如此的重要以至于你可以考虑不要将你的第一版作为一个产品，而是作为一个引起用户谈论，关注的策略。</p>

<p>我从中学到，要把创业的初始阶段看做是一场巨大的实验。所有的产品都应该被纳入试验中。那些有市场的产品很快就会达到预期的结果。一旦你开始你与用户的对话，你会为他们和你说的感到意外。</p>

<p>当你让顾客告诉你他们在追逐什么的时候，他们通常会揭示出一些惊人的细节，这些是他们觉得有意义的，同时也是他们愿意付钱的部分。</p>

<p>当然这些意外既有正面的也有负面的。他们可能和你所预想的完全不同，但有些也可能很容易就能加入你原有的设计。只有当你通过发布一个错误的东西开始和客户的对话，他们才能表达出（或者意识到）什么是他们所盼望的。</p>

<p>10.改变你的想法</p>

<p>为了能从顾客参与的产品开发中获益，你必须愿意修改你的想法。我们常常鼓励创业者把创业的主意当做是一个假设而不是一个蓝图。但人们依然对做出改变后带来的好处感到惊讶。通常来说当你抱怨一件事很困难的时候，一般的建议就是更努力地工作。而在一个创业中，我认为你应该找出一个容易解决的问题。在答案中不断寻找完美的解决方案是我们所熟悉的。但如果你在问题的范围里多做点思考的话你会有巨大的收获。</p>

<p>但如果只有决心没有灵活变通的能力的话，创业只对你只能是一个贪婪的过程，然后得到一个不好不坏的结果。</p>

<p>当一个人下定决心以后，他仍然有走上一条又长又困难的不归路的风险。你想要有所进展，但在同时却不停的徘徊、游荡寻找一条最有希望的路。有一位创业者用非常简洁的语言归纳了这点：</p>

<p>现在我再也不会嘲笑别人的想法了，因为我意识到我分别一个主意是好是坏的能力太差了。</p>

<p>你永远不知道什么是行得通的。你只要在每一点上尽量做得最好就可以了。在YC中我们也执行这一条。我们依然不知道一个想法是否可行，但它看上去就像一连串的假设。</p>

<p>11.不要担心有竞争者</p>

<p>当你觉得你有一个很棒的想法时，这就像是对什么事有所愧疚一样。人们所做的就是看你的笑话，然后你就会想：“啊，他们知道”</p>

<p>这些警告几乎总是错的：那些你第一眼看上去像是你竞争对手的公司通常在你仔细研究后会发现他们并不是。即使他们和你的公司在相同领域里，但你们有着不同的目标。</p>

<p>人们对竞争反应过度的原因之一就是人们对创意的价值过分高估了。如果创意真的是成功的关键，那么有着相同创意的竞争者就会是一个真正的威胁。不过通常是执行力影响了最后的结果。：</p>

<p>所有的恐惧，包括对一个新竞争对手的出现的都会在几周后被遗忘。最终你还是要回到你的产品上，然后将它发布到市场中。通常情况下这一条都是适用的，即使竞争对手获得了很多的关注。</p>

<p>那些在博客排行榜上停留在前列的竞争者很少会成为最终的赢家，而且可能很快就从人么的视线中消失了。你所需要的最终也只是消费者而已，大肆宣传并不会带来满意的用户，至少对这么复杂的技术类产品商品不会。</p>

<p>12.争取用户很困难</p>

<p>很多创业者抱怨为了争取客户有多么困难。我也不知道吸引用户需要花费多少精力和时间。这是一个复杂的问题。当你没有用户的时候，很难说是否是缺乏宣传，或者仅仅是产品不够好。即使是好产品也可能因为置换成本和整合成本而不受欢迎。</p>

<p>让人们开始使用一种全新的服务更是困难重重。这一点对那种其他公司也能提供的服务尤其困难，因为这要求它的开发商做更多的工作。如果你是很小的公司，那么他们不会觉得这是很紧急的事情。我们在YC面临的最尖锐的危机，正如我们的一位创业者所说的那样，不够专注于客户的获取。YC鼓励的是“做客户想要的东西”的理念，不断的改进一个又一个产品特性，直到有足够人感到满意或者产品下架为止。我们很少关注在客户获取方面的花费。</p>

<p>这可能很严重；这可能是我们需要改进的地方，尤其对于游戏这一类的软件来说。如果你只是在技术上做一些有挑战的东西。那么你可以靠口口相传来争取你的用户，就像谷歌那样。一位创业者对这样做所取得的良好效果而感到意外：</p>

<p>在创业的过程中你可能会产生一种非理性的恐惧，担心人们不会买你的产品。但如果你努力工作并不断完善你的产品，那么这完全是一种多余的担忧。</p>

<p>但对其他类型的创业来说，关注交易和市场营销要比关注于产品更能给你带来成功。</p>

<p>13.在交易中做最坏的打算</p>

<p>生意失败。这是创业中的常事。创业总是很无力的，而好的创意看上去总是错的。所以每个人总是迫不及待地想要结束和你的交易，而你没办法改变他们。</p>

<p>对投资者来说尤其是这样：</p>

<p>回头来看，如果我们当初能以没有任何外部投资的假设去进行我们的创业的话，我们将会取得更大的成功。这样做会使我们更加专注于寻找利润来源。</p>

<p>关于这一点我的建议是尽量保持悲观。假设你自己不会得到任何投资，即使你得到了一些投资，假设你不会再有更多的投资。</p>

<p>如果一个人向你投资，那么接受它。你会谈论很多，但我觉得 你需要更重视它。去年我们曾有机会募集到比我们实际募集到的金额多得多钱。我真希望我们当时能抓住机会。</p>

<p>为什么创业者往往会忽视这一点？主要是因为他们天生就是乐观主义者。而错就错在你不该对不在你掌控中的事乐观。你可以对的产品和你的能力尽一切可能的保持乐观，但如果你对大公司或者投资人保持乐观的话，那么你只是自讨苦吃而已。</p>

<p>14.投资人都是无知的</p>

<p>很多创业者都提到当他们意识到投资者是无知的时候有多惊讶。</p>

<p>他们甚至都不了解他们所投资的东西到底是什么东西。我遇到过一些投资同一家硬件厂商的投资者，当我要求他们演示一下他们的产品时，他们居然连开关都有困难。</p>

<p>天使投资在这方面要比风险投资要好一点，至少他们还是有创业的经历的。</p>

<p>风投对他们所谈论的东西有一半以上是不懂的。而且他们的思想也远远落后于时代。只有一些是很好的，而我们所接触到的剩下的95%都是不专业的，看上去就不像是个做生意的料以及任何创造性的眼光。天使投资在这方面更值得交流。</p>

<p>为什么创业者对投资人的无知会感到意外呢？我认为是因为在创业者眼中，投资人的形象是如此高大。</p>

<p>而投资人看上去高大又是因为他们的专长就是如此。他们必须让资产经理信任他们，把几亿美元都委托给他们。如果是你你要怎么做？你必须显得很有自信，显得你很懂技术的样子。</p>

<p>15.你可能不得不耍些小手段</p>

<p>因为投资人在看人的时候太不准了。所以你不得不更加努力的推销你自己。一个创业者所说的最令他意外的经历是：你装的越自信，投资人就印象越好</p>

<p>在YC创业者经历中这是最令我意外的了。这个夏天我们邀请了一些校友来和新学员一起讨论资金募集。几乎100%他们给的意见都是关于投资者心理学的。我以前一直认为我对投资者已经都敷衍了。但这些创业者则更加敷衍，很多创业者所做的仅仅只是装装样子而已，但它的确管用。</p>

<p>风投自己并不知道他们所看中的那些创业者有多善于推销自己。而这又恰恰是我们在早先的阶段中所观察到的现象。风投通过在LP前装逼来拿到钱，创业者则在风投面前装逼来拿到钱。</p>

<p>16.运气是个很重要的因素</p>

<p>既然在创业者和钱之间的联系是如此的随机，那也就不应该奇怪运气在生意中式一个很重要的因素。但仍然有很多创业者对此感到意外。</p>

<p>我当时并没有意识到运气扮演了多重要的一个角色，以及它是多么的不可控。</p>

<p>如果你想想那些著名的创业公司，很明显运气都扮演了一个重要的角色。如果IBM坚持保有DOS系统的专利权，那么微软现在会在哪里呢？</p>

<p>为什么创业者会被这点所蒙蔽呢？生意人可能不会，但黑客们早就习惯了一个技术至上的世界，你得到你所应得的。当我们开始我们的创业的时候，我承载了我们夸张的梦想：这只是一场技术的竞争而已。从某种角度来说的确是这样。技术是有价值的，所以它们也是这样被定义的。但运气好才是决定性的因素。</p>

<p>准确来首，最好的模型会把一次创业的结局定义为技术，决心和运气的产物。无论你有多好的技巧，多大的决心，如果你的运气很差，那么结局也必然是失败的。</p>

<p>这些话并不是那些失败的创业者说的。那些很快就失败的创业者都倾向于责怪他们自己。而那些很快就获得成功的人也不会意识到它们自己是多幸运。处在两者之间的人则刚刚好能看清运气的重要性。</p>

<p>17.社区的价值</p>

<p>有惊人数量的创业者提高了社区的价值。一些指的是YC学员这个小圈子：</p>

<p>YC同辈学员之间的巨大价值，它们会在差不多相同的时间遇到相同的困难。但这并不应该让人感到意外，因为它就是这样被构建的。而其他人则在更大的范围内上感受创业社区的价值。住在硅谷有多大优势？在那里你会不断听到所有尖端的科学技术和创业消息，以及马上和有用的人面对面交流。而最令他们意外的是创业者之间普遍的慈善精神。</p>

<p>我所看到最令我意外的就是人们都愿意帮助我们。即使他们不能从中得到些什么，他们还是会抽出时间帮我们获得成功。</p>

<p>尤其是这一点如何无时无刻的伸展在你生活的每一处：</p>

<p>最令我意外就是接触重要和有趣的人有多容易。你很容易就能和他们碰到然后马上得到反馈。这也是我选择成为他们中一员的原因。创造财富并不是一场零和博弈，所以你不需要把人家拉下来，以确保自己的胜利。</p>

<p>18.你得不到尊重</p>

<p>有一个创业者提出的意外是我宁可忘记的：在创业者的世界之外，创业者不会得到任何尊敬。</p>

<p>在我们的社会设定中，我发现如果我说我在微软工作，会比说我在一家叫X的新创业的企业工作获得更多的尊敬。</p>

<p>一部分是因为剩下的人并不创业，而另一部分原因是因为绝大多数的好的创业的想法看上去就很坏。</p>

<p>如果你随机的向一个路人宣传你的想法，95%的人凭直觉会认为你的创意会失败，而你只是在浪费时间而已（虽然他们并不一定会那么直接的说出来）。</p>

<p>不幸的是，这甚至蔓延到约会上了：</p>

<p>让我感到意外的是，作为一个创业者并不能从女人那里获得更多的青睐。</p>

<p>我的确知道这一点，但我宁可忘记它。</p>

<p>19.你的事业和你一起在成长</p>

<p>创业者们提到的最后一个意外就是，事情会随着你的成长而发生翻天覆地的变化。最大的改变就是你会做更少的编程工作。</p>

<p>你作为一个技术型创业者或者CEO的角色，每6到12个月就会被重新定义一次。你将花更少的时间在编程上，花更多的时间在管理，计划，公司建设，人事，处理杂事以及在事情发生几个月前就安排好相关的事务。</p>

<p>尤其是你现在需要开始和不同的员工打交道，而他们往往各自抱着不同的动机。</p>

<p>我知道作为一个创业者需要关注什么方面，并且从我19岁想要创业的时候就已经开始关注了。但和一个雇员需要关注的东西是非常不同的，而这花了我一些时间来适应。幸运的是，在熟悉这些以后，你就不会觉得压力那么大了：</p>

<p>和最初开始创业的时候相比，现在我们所承受的压力只有当初的25%。现在经营一个公司变得越来越有趣。我们熬夜奋战的次数少了，我们睡眠的时间多了。</p>

<p>我希望我能够说所有成功的创业都是这样的，但75%的都是始终处在很大的压力之下的。</p>

<p>超级模式</p>

<p>当然还存在着许多其他的模式，但是这些是最重要的。任何一个人第一眼看到这些的时候都是问这是不是一个超级模式，模式中的模式。</p>

<p>我马上就意识到了这一点，同时我读给一位YC的创立者听，他也马上意识到了。如果这些都是我没有告诉过人们的话，这些的确可以是一种意外。但他们之间都有一些共通点，他们都是我曾经说过的。如果我用相同的大纲写一篇新的文章，那不会是一篇对创业者反馈的总结，每个人都会说我已经才思枯竭，并且在重复自己的东西而已。</p>

<p>然后呢？</p>

<p>当我看到这些回复的时候，通常的主题都是说创业绝大部分都像我所说的那样，但远不仅仅是那样。所以人们知道自己亲身去做才知道创业有多困难。为什么会这样呢？问题的关键就在于要问，和什么相比创业是困难的。一旦你开始这样想以后，答案就很明显了：和打工相比。每个人对工作的概念一开始都是打工。这一条是非常普遍的。即使你从来没有打过工，你的爸妈可能打过，即使他们也没有，你成长道路上遇到的每个成年人都可能打过。</p>

<p>无形中，人们就对创业抱有一种打工的期望，这就解释了绝大部分的意外。这一条解释了为什么人们对要多么仔细挑选合伙人，多努力去维持你们的关系而感到意外了。在同事之间你就不需要这样做。它也解释了为什么人们对情绪的波动感到极端的意外。在打工过程中，生活总是显得很沉闷。这也解释了为什么好的时候感觉会那么棒：大多数的人都无法想象这种自由。当你浏览这份列表的时候，几乎所有的意外都是对于创业和打工之间的区别的。</p>

<p>你似乎不能轻易的改变一些如此普遍而又随着你的成长不断加深的关于工作的期望。所以最好的解决办法就是不断有意识的提醒自己。当你走进创业的世界的时，你会觉得每个人讲的都很极端。然后你的下一个想法就是“但我不相信事情会那么差。”如果你想要避免被惊讶到，那么你下一个想法就应该是：“我不能相信事情会变得那么差是因为我对工作的期望是打工。”</p>

<p>===============================</p>

<p>What Startups Are Really Like</p>

<p>October 2009</p>

<p>(This essay is derived from a talk at the 2009 Startup School.)</p>

<p>I wasn&#8217;t sure what to talk about at Startup School, so I decided to ask the founders of the startups we&#8217;d funded. What hadn&#8217;t I written about yet?</p>

<p>I&#8217;m in the unusual position of being able to test the essays I write about startups. I hope the ones on other topics are right, but I have no way to test them. The ones on startups get tested by about 70 people every 6 months.</p>

<p>So I sent all the founders an email asking what surprised them about starting a startup. This amounts to asking what I got wrong, because if I&#8217;d explained things well enough, nothing should have surprised them.</p>

<p>I&#8217;m proud to report I got one response saying:</p>

<p>What surprised me the most is that everything was actually fairly predictable!</p>

<p>The bad news is that I got over 100 other responses listing the surprises they encountered.</p>

<p>There were very clear patterns in the responses; it was remarkable how often several people had been surprised by exactly the same thing. These were the biggest:</p>

<ol>
<li>Be Careful with Cofounders</li>
</ol>


<p>This was the surprise mentioned by the most founders. There were two types of responses: that you have to be careful who you pick as a cofounder, and that you have to work hard to maintain your relationship.</p>

<p>What people wished they&#8217;d paid more attention to when choosing cofounders was character and commitment, not ability. This was particularly true with startups that failed. The lesson: don&#8217;t pick cofounders who will flake.</p>

<p>Here&#8217;s a typical reponse:</p>

<p>You haven&#8217;t seen someone&#8217;s true colors unless you&#8217;ve worked with them on a startup.</p>

<p>The reason character is so important is that it&#8217;s tested more severely than in most other situations. One founder said explicitly that the relationship between founders was more important than ability:</p>

<p>I would rather cofound a startup with a friend than a stranger with higher output. Startups are so hard and emotional that the bonds and emotional and social support that come with friendship outweigh the extra output lost.</p>

<p>We learned this lesson a long time ago. If you look at the YC application, there are more questions about the commitment and relationship of the founders than their ability.</p>

<p>Founders of successful startups talked less about choosing cofounders and more about how hard they worked to maintain their relationship.</p>

<p>One thing that surprised me is how the relationship of startup founders goes from a friendship to a marriage. My relationship with my cofounder went from just being friends to seeing each other all the time, fretting over the finances and cleaning up shit. And the startup was our baby. I summed it up once like this: &#8220;It&#8217;s like we&#8217;re married, but we&#8217;re not fucking.&#8221;</p>

<p>Several people used that word &#8220;married.&#8221; It&#8217;s a far more intense relationship than you usually see between coworkers—partly because the stresses are so much greater, and partly because at first the founders are the whole company. So this relationship has to be built of top quality materials and carefully maintained. It&#8217;s the basis of everything.</p>

<ol>
<li>Startups Take Over Your Life</li>
</ol>


<p>Just as the relationship between cofounders is more intense than it usually is between coworkers, so is the relationship between the founders and the company. Running a startup is not like having a job or being a student, because it never stops. This is so foreign to most people&#8217;s experience that they don&#8217;t get it till it happens. [1]</p>

<p>I didn&#8217;t realize I would spend almost every waking moment either working or thinking about our startup. You enter a whole different way of life when it&#8217;s your company vs. working for someone else&#8217;s company.</p>

<p>It&#8217;s exacerbated by the fast pace of startups, which makes it seem like time slows down:</p>

<p>I think the thing that&#8217;s been most surprising to me is how one&#8217;s perspective on time shifts. Working on our startup, I remember time seeming to stretch out, so that a month was a huge interval.</p>

<p>In the best case, total immersion can be exciting:</p>

<p>It&#8217;s surprising how much you become consumed by your startup, in that you think about it day and night, but never once does it feel like &#8220;work.&#8221;</p>

<p>Though I have to say, that quote is from someone we funded this summer. In a couple years he may not sound so chipper.</p>

<ol>
<li>It&#8217;s an Emotional Roller-coaster</li>
</ol>


<p>This was another one lots of people were surprised about. The ups and downs were more extreme than they were prepared for.</p>

<p>In a startup, things seem great one moment and hopeless the next. And by next, I mean a couple hours later.</p>

<p>The emotional ups and downs were the biggest surprise for me. One day, we&#8217;d think of ourselves as the next Google and dream of buying islands; the next, we&#8217;d be pondering how to let our loved ones know of our utter failure; and on and on.</p>

<p>The hard part, obviously, is the lows. For a lot of founders that was the big surprise:</p>

<p>How hard it is to keep everyone motivated during rough days or weeks, i.e. how low the lows can be.</p>

<p>After a while, if you don&#8217;t have significant success to cheer you up, it wears you out:</p>

<p>Your most basic advice to founders is &#8220;just don&#8217;t die,&#8221; but the energy to keep a company going in lieu of unburdening success isn&#8217;t free; it is siphoned from the founders themselves.</p>

<p>There&#8217;s a limit to how much you can take. If you get to the point where you can&#8217;t keep working anymore, it&#8217;s not the end of the world. Plenty of famous founders have had some failures along the way.</p>

<ol>
<li>It Can Be Fun</li>
</ol>


<p>The good news is, the highs are also very high. Several founders said what surprised them most about doing a startup was how fun it was:</p>

<p>I think you&#8217;ve left out just how fun it is to do a startup. I am more fulfilled in my work than pretty much any of my friends who did not start companies.</p>

<p>What they like most is the freedom:</p>

<p>I&#8217;m surprised by how much better it feels to be working on something that is challenging and creative, something I believe in, as opposed to the hired-gun stuff I was doing before. I knew it would feel better; what&#8217;s surprising is how much better.</p>

<p>Frankly, though, if I&#8217;ve misled people here, I&#8217;m not eager to fix that. I&#8217;d rather have everyone think starting a startup is grim and hard than have founders go into it expecting it to be fun, and a few months later saying &#8220;This is supposed to be fun? Are you kidding?&#8221;</p>

<p>The truth is, it wouldn&#8217;t be fun for most people. A lot of what we try to do in the application process is to weed out the people who wouldn&#8217;t like it, both for our sake and theirs.</p>

<p>The best way to put it might be that starting a startup is fun the way a survivalist training course would be fun, if you&#8217;re into that sort of thing. Which is to say, not at all, if you&#8217;re not.</p>

<ol>
<li>Persistence Is the Key</li>
</ol>


<p>A lot of founders were surprised how important persistence was in startups. It was both a negative and a positive surprise: they were surprised both by the degree of persistence required</p>

<p>Everyone said how determined and resilient you must be, but going through it made me realize that the determination required was still understated.</p>

<p>and also by the degree to which persistence alone was able to dissolve obstacles:</p>

<p>If you are persistent, even problems that seem out of your control (i.e. immigration) seem to work themselves out.</p>

<p>Several founders mentioned specifically how much more important persistence was than intelligence.</p>

<p>I&#8217;ve been surprised again and again by just how much more important persistence is than raw intelligence.</p>

<p>This applies not just to intelligence but to ability in general, and that&#8217;s why so many people said character was more important in choosing cofounders.</p>

<ol>
<li>Think Long-Term</li>
</ol>


<p>You need persistence because everything takes longer than you expect. A lot of people were surprised by that.</p>

<p>I&#8217;m continually surprised by how long everything can take. Assuming your product doesn&#8217;t experience the explosive growth that very few products do, everything from development to dealmaking (especially dealmaking) seems to take 2-3x longer than I always imagine.</p>

<p>One reason founders are surprised is that because they work fast, they expect everyone else to. There&#8217;s a shocking amount of shear stress at every point where a startup touches a more bureaucratic organization, like a big company or a VC fund. That&#8217;s why fundraising and the enterprise market kill and maim so many startups. [2]</p>

<p>But I think the reason most founders are surprised by how long it takes is that they&#8217;re overconfident. They think they&#8217;re going to be an instant success, like YouTube or Facebook. You tell them only 1 out of 100 successful startups has a trajectory like that, and they all think &#8220;we&#8217;re going to be that 1.&#8221;</p>

<p>Maybe they&#8217;ll listen to one of the more successful founders:</p>

<p>The top thing I didn&#8217;t understand before going into it is that persistence is the name of the game. For the vast majority of startups that become successful, it&#8217;s going to be a really long journey, at least 3 years and probably 5+.</p>

<p>There is a positive side to thinking longer-term. It&#8217;s not just that you have to resign yourself to everything taking longer than it should. If you work patiently it&#8217;s less stressful, and you can do better work:</p>

<p>Because we&#8217;re relaxed, it&#8217;s so much easier to have fun doing what we do. Gone is the awkward nervous energy fueled by the desperate need to not fail guiding our actions. We can concentrate on doing what&#8217;s best for our company, product, employees and customers.</p>

<p>That&#8217;s why things get so much better when you hit ramen profitability. You can shift into a different mode of working.</p>

<ol>
<li>Lots of Little Things</li>
</ol>


<p>We often emphasize how rarely startups win simply because they hit on some magic idea. I think founders have now gotten that into their heads. But a lot were surprised to find this also applies within startups. You have to do lots of different things:</p>

<p>It&#8217;s much more of a grind than glamorous. A timeslice selected at random would more likely find me tracking down a weird DLL loading bug on Swedish Windows, or tracking down a bug in the financial model Excel spreadsheet the night before a board meeting, rather than having brilliant flashes of strategic insight.</p>

<p>Most hacker-founders would like to spend all their time programming. You won&#8217;t get to, unless you fail. Which can be transformed into: If you spend all your time programming, you will fail.</p>

<p>The principle extends even into programming. There is rarely a single brilliant hack that ensures success:</p>

<p>I learnt never to bet on any one feature or deal or anything to bring you success. It is never a single thing. Everything is just incremental and you just have to keep doing lots of those things until you strike something.</p>

<p>Even in the rare cases where a clever hack makes your fortune, you probably won&#8217;t know till later:</p>

<p>There is no such thing as a killer feature. Or at least you won&#8217;t know what it is.</p>

<p>So the best strategy is to try lots of different things. The reason not to put all your eggs in one basket is not the usual one, which applies even when you know which basket is best. In a startup you don&#8217;t even know that.</p>

<ol>
<li>Start with Something Minimal</li>
</ol>


<p>Lots of founders mentioned how important it was to launch with the simplest possible thing. By this point everyone knows you should release fast and iterate. It&#8217;s practically a mantra at YC. But even so a lot of people seem to have been burned by not doing it:</p>

<p>Build the absolute smallest thing that can be considered a complete application and ship it.</p>

<p>Why do people take too long on the first version? Pride, mostly. They hate to release something that could be better. They worry what people will say about them. But you have to overcome this:</p>

<p>Doing something &#8220;simple&#8221; at first glance does not mean you aren&#8217;t doing something meaningful, defensible, or valuable.</p>

<p>Don&#8217;t worry what people will say. If your first version is so impressive that trolls don&#8217;t make fun of it, you waited too long to launch. [3]</p>

<p>One founder said this should be your approach to all programming, not just startups, and I tend to agree.</p>

<p>Now, when coding, I try to think &#8220;How can I write this such that if people saw my code, they&#8217;d be amazed at how little there is and how little it does?&#8221;</p>

<p>Over-engineering is poison. It&#8217;s not like doing extra work for extra credit. It&#8217;s more like telling a lie that you then have to remember so you don&#8217;t contradict it.</p>

<ol>
<li>Engage Users</li>
</ol>


<p>Product development is a conversation with the user that doesn&#8217;t really start till you launch. Before you launch, you&#8217;re like a police artist before he&#8217;s shown the first version of his sketch to the witness.</p>

<p>It&#8217;s so important to launch fast that it may be better to think of your initial version not as a product, but as a trick for getting users to start talking to you.</p>

<p>I learned to think about the initial stages of a startup as a giant experiment. All products should be considered experiments, and those that have a market show promising results extremely quickly.</p>

<p>Once you start talking to users, I guarantee you&#8217;ll be surprised by what they tell you.</p>

<p>When you let customers tell you what they&#8217;re after, they will often reveal amazing details about what they find valuable as well what they&#8217;re willing to pay for.</p>

<p>The surprise is generally positive as well as negative. They won&#8217;t like what you&#8217;ve built, but there will be other things they would like that would be trivially easy to implement. It&#8217;s not till you start the conversation by launching the wrong thing that they can express (or perhaps even realize) what they&#8217;re looking for.</p>

<ol>
<li>Change Your Idea</li>
</ol>


<p>To benefit from engaging with users you have to be willing to change your idea. We&#8217;ve always encouraged founders to see a startup idea as a hypothesis rather than a blueprint. And yet they&#8217;re still surprised how well it works to change the idea.</p>

<p>Normally if you complain about something being hard, the general advice is to work harder. With a startup, I think you should find a problem that&#8217;s easy for you to solve. Optimizing in solution-space is familiar and straightforward, but you can make enormous gains playing around in problem-space.</p>

<p>Whereas mere determination, without flexibility, is a greedy algorithm that may get you nothing more than a mediocre local maximum:</p>

<p>When someone is determined, there&#8217;s still a danger that they&#8217;ll follow a long, hard path that ultimately leads nowhere.</p>

<p>You want to push forward, but at the same time twist and turn to find the most promising path. One founder put it very succinctly:</p>

<p>Fast iteration is the key to success.</p>

<p>One reason this advice is so hard to follow is that people don&#8217;t realize how hard it is to judge startup ideas, particularly their own. Experienced founders learn to keep an open mind:</p>

<p>Now I don&#8217;t laugh at ideas anymore, because I realized how terrible I was at knowing if they were good or not.</p>

<p>You can never tell what will work. You just have to do whatever seems best at each point. We do this with YC itself. We still don&#8217;t know if it will work, but it seems like a decent hypothesis.</p>

<ol>
<li>Don&#8217;t Worry about Competitors</li>
</ol>


<p>When you think you&#8217;ve got a great idea, it&#8217;s sort of like having a guilty conscience about something. All someone has to do is look at you funny, and you think &#8220;Oh my God, they know.&#8221;</p>

<p>These alarms are almost always false:</p>

<p>Companies that seemed like competitors and threats at first glance usually never were when you really looked at it. Even if they were operating in the same area, they had a different goal.</p>

<p>One reason people overreact to competitors is that they overvalue ideas. If ideas really were the key, a competitor with the same idea would be a real threat. But it&#8217;s usually execution that matters:</p>

<p>All the scares induced by seeing a new competitor pop up are forgotten weeks later. It always comes down to your own product and approach to the market.</p>

<p>This is generally true even if competitors get lots of attention.</p>

<p>Competitors riding on lots of good blogger perception aren&#8217;t really the winners and can disappear from the map quickly. You need consumers after all.</p>

<p>Hype doesn&#8217;t make satisfied users, at least not for something as complicated as technology.</p>

<ol>
<li>It&#8217;s Hard to Get Users</li>
</ol>


<p>A lot of founders complained about how hard it was to get users, though.</p>

<p>I had no idea how much time and effort needed to go into attaining users.</p>

<p>This is a complicated topic. When you can&#8217;t get users, it&#8217;s hard to say whether the problem is lack of exposure, or whether the product&#8217;s simply bad. Even good products can be blocked by switching or integration costs:</p>

<p>Getting people to use a new service is incredibly difficult. This is especially true for a service that other companies can use, because it requires their developers to do work. If you&#8217;re small, they don&#8217;t think it is urgent. [4]</p>

<p>The sharpest criticism of YC came from a founder who said we didn&#8217;t focus enough on customer acquisition:</p>

<p>YC preaches &#8220;make something people want&#8221; as an engineering task, a never ending stream of feature after feature until enough people are happy and the application takes off. There&#8217;s very little focus on the cost of customer acquisition.</p>

<p>This may be true; this may be something we need to fix, especially for applications like games. If you make something where the challenges are mostly technical, you can rely on word of mouth, like Google did. One founder was surprised by how well that worked for him:</p>

<p>There is an irrational fear that no one will buy your product. But if you work hard and incrementally make it better, there is no need to worry.</p>

<p>But with other types of startups you may win less by features and more by deals and marketing.</p>

<ol>
<li>Expect the Worst with Deals</li>
</ol>


<p>Deals fall through. That&#8217;s a constant of the startup world. Startups are powerless, and good startup ideas generally seem wrong. So everyone is nervous about closing deals with you, and you have no way to make them.</p>

<p>This is particularly true with investors:</p>

<p>In retrospect, it would have been much better if we had operated under the assumption that we would never get any additional outside investment. That would have focused us on finding revenue streams early.</p>

<p>My advice is generally pessimistic. Assume you won&#8217;t get money, and if someone does offer you any, assume you&#8217;ll never get any more.</p>

<p>If someone offers you money, take it. You say it a lot, but I think it needs even more emphasizing. We had the opportunity to raise a lot more money than we did last year and I wish we had.</p>

<p>Why do founders ignore me? Mostly because they&#8217;re optimistic by nature. The mistake is to be optimistic about things you can&#8217;t control. By all means be optimistic about your ability to make something great. But you&#8217;re asking for trouble if you&#8217;re optimistic about big companies or investors.</p>

<ol>
<li>Investors Are Clueless</li>
</ol>


<p>A lot of founders mentioned how surprised they were by the cluelessness of investors:</p>

<p>They don&#8217;t even know about the stuff they&#8217;ve invested in. I met some investors that had invested in a hardware device and when I asked them to demo the device they had difficulty switching it on.</p>

<p>Angels are a bit better than VCs, because they usually have startup experience themselves:</p>

<p>VC investors don&#8217;t know half the time what they are talking about and are years behind in their thinking. A few were great, but 95% of the investors we dealt with were unprofessional, didn&#8217;t seem to be very good at business or have any kind of creative vision. Angels were generally much better to talk to.</p>

<p>Why are founders surprised that VCs are clueless? I think it&#8217;s because they seem so formidable.</p>

<p>The reason VCs seem formidable is that it&#8217;s their profession to. You get to be a VC by convincing asset managers to trust you with hundreds of millions of dollars. How do you do that? You have to seem confident, and you have to seem like you understand technology. [5]</p>

<ol>
<li>You May Have to Play Games</li>
</ol>


<p>Because investors are so bad at judging you, you have to work harder than you should at selling yourself. One founder said the thing that surprised him most was</p>

<p>The degree to which feigning certitude impressed investors.</p>

<p>This is the thing that has surprised me most about YC founders&#8217; experiences. This summer we invited some of the alumni to talk to the new startups about fundraising, and pretty much 100% of their advice was about investor psychology. I thought I was cynical about VCs, but the founders were much more cynical.</p>

<p>A lot of what startup founders do is just posturing. It works.</p>

<p>VCs themselves have no idea of the extent to which the startups they like are the ones that are best at selling themselves to VCs. [6] It&#8217;s exactly the same phenomenon we saw a step earlier. VCs get money by seeming confident to LPs, and founders get money by seeming confident to VCs.</p>

<ol>
<li>Luck Is a Big Factor</li>
</ol>


<p>With two such random linkages in the path between startups and money, it shouldn&#8217;t be surprising that luck is a big factor in deals. And yet a lot of founders are surprised by it.</p>

<p>I didn&#8217;t realize how much of a role luck plays and how much is outside of our control.</p>

<p>If you think about famous startups, it&#8217;s pretty clear how big a role luck plays. Where would Microsoft be if IBM insisted on an exclusive license for DOS?</p>

<p>Why are founders fooled by this? Business guys probably aren&#8217;t, but hackers are used to a world where skill is paramount, and you get what you deserve.</p>

<p>When we started our startup, I had bought the hype of the startup founder dream: that this is a game of skill. It is, in some ways. Having skill is valuable. So is being determined as all hell. But being lucky is the critical ingredient.</p>

<p>Actually the best model would be to say that the outcome is the product of skill, determination, and luck. No matter how much skill and determination you have, if you roll a zero for luck, the outcome is zero.</p>

<p>These quotes about luck are not from founders whose startups failed. Founders who fail quickly tend to blame themselves. Founders who succeed quickly don&#8217;t usually realize how lucky they were. It&#8217;s the ones in the middle who see how important luck is.</p>

<ol>
<li>The Value of Community</li>
</ol>


<p>A surprising number of founders said what surprised them most about starting a startup was the value of community. Some meant the micro-community of YC founders:</p>

<p>The immense value of the peer group of YC companies, and facing similar obstacles at similar times.</p>

<p>which shouldn&#8217;t be that surprising, because that&#8217;s why it&#8217;s structured that way. Others were surprised at the value of the startup community in the larger sense:</p>

<p>How advantageous it is to live in Silicon Valley, where you can&#8217;t help but hear all the cutting-edge tech and startup news, and run into useful people constantly.</p>

<p>The specific thing that surprised them most was the general spirit of benevolence:</p>

<p>One of the most surprising things I saw was the willingness of people to help us. Even people who had nothing to gain went out of their way to help our startup succeed.</p>

<p>and particularly how it extended all the way to the top:</p>

<p>The surprise for me was how accessible important and interesting people are. It&#8217;s amazing how easily you can reach out to people and get immediate feedback.</p>

<p>This is one of the reasons I like being part of this world. Creating wealth is not a zero-sum game, so you don&#8217;t have to stab people in the back to win.</p>

<ol>
<li>You Get No Respect</li>
</ol>


<p>There was one surprise founders mentioned that I&#8217;d forgotten about: that outside the startup world, startup founders get no respect.</p>

<p>In social settings, I found that I got a lot more respect when I said, &#8220;I worked on Microsoft Office&#8221; instead of &#8220;I work at a small startup you&#8217;ve never heard of called x.&#8221;</p>

<p>Partly this is because the rest of the world just doesn&#8217;t get startups, and partly it&#8217;s yet another consequence of the fact that most good startup ideas seem bad:</p>

<p>If you pitch your idea to a random person, 95% of the time you&#8217;ll find the person instinctively thinks the idea will be a flop and you&#8217;re wasting your time (although they probably won&#8217;t say this directly).</p>

<p>Unfortunately this extends even to dating:</p>

<p>It surprised me that being a startup founder does not get you more admiration from women.</p>

<p>I did know about that, but I&#8217;d forgotten.</p>

<ol>
<li>Things Change as You Grow</li>
</ol>


<p>The last big surprise founders mentioned is how much things changed as they grew. The biggest change was that you got to program even less:</p>

<p>Your job description as technical founder/CEO is completely rewritten every 6-12 months. Less coding, more managing/planning/company building, hiring, cleaning up messes, and generally getting things in place for what needs to happen a few months from now.</p>

<p>In particular, you now have to deal with employees, who often have different motivations:</p>

<p>I knew the founder equation and had been focused on it since I knew I wanted to start a startup as a 19 year old. The employee equation is quite different so it took me a while to get it down.</p>

<p>Fortunately, it can become a lot less stressful once you reach cruising altitude:</p>

<p>I&#8217;d say 75% of the stress is gone now from when we first started. Running a business is so much more enjoyable now. We&#8217;re more confident. We&#8217;re more patient. We fight less. We sleep more.</p>

<p>I wish I could say it was this way for every startup that succeeded, but 75% is probably on the high side.</p>

<p>The Super-Pattern</p>

<p>There were a few other patterns, but these were the biggest. One&#8217;s first thought when looking at them all is to ask if there&#8217;s a super-pattern, a pattern to the patterns.</p>

<p>I saw it immediately, and so did a YC founder I read the list to. These are supposed to be the surprises, the things I didn&#8217;t tell people. What do they all have in common? They&#8217;re all things I tell people. If I wrote a new essay with the same outline as this that wasn&#8217;t summarizing the founders&#8217; responses, everyone would say I&#8217;d run out of ideas and was just repeating myself.</p>

<p>What is going on here?</p>

<p>When I look at the responses, the common theme is that starting a startup was like I said, but way more so. People just don&#8217;t seem to get how different it is till they do it. Why? The key to that mystery is to ask, how different from what? Once you phrase it that way, the answer is obvious: from a job. Everyone&#8217;s model of work is a job. It&#8217;s completely pervasive. Even if you&#8217;ve never had a job, your parents probably did, along with practically every other adult you&#8217;ve met.</p>

<p>Unconsciously, everyone expects a startup to be like a job, and that explains most of the surprises. It explains why people are surprised how carefully you have to choose cofounders and how hard you have to work to maintain your relationship. You don&#8217;t have to do that with coworkers. It explains why the ups and downs are surprisingly extreme. In a job there is much more damping. But it also explains why the good times are surprisingly good: most people can&#8217;t imagine such freedom. As you go down the list, almost all the surprises are surprising in how much a startup differs from a job.</p>

<p>You probably can&#8217;t overcome anything so pervasive as the model of work you grew up with. So the best solution is to be consciously aware of that. As you go into a startup, you&#8217;ll be thinking &#8220;everyone says it&#8217;s really extreme.&#8221; Your next thought will probably be &#8220;but I can&#8217;t believe it will be that bad.&#8221; If you want to avoid being surprised, the next thought after that should be: &#8220;and the reason I can&#8217;t believe it will be that bad is that my model of work is a job.&#8221;</p>

<p>Notes</p>

<p>[1] Graduate students might understand it. In grad school you always feel you should be working on your thesis. It doesn&#8217;t end every semester like classes do.</p>

<p>[2] The best way for a startup to engage with slow-moving organizations is to fork off separate processes to deal with them. It&#8217;s when they&#8217;re on the critical path that they kill you—when you depend on closing a deal to move forward. It&#8217;s worth taking extreme measures to avoid that.</p>

<p>[3] This is a variant of Reid Hoffman&#8217;s principle that if you aren&#8217;t embarrassed by what you launch with, you waited too long to launch.</p>

<p>[4] The question to ask about what you&#8217;ve built is not whether it&#8217;s good, but whether it&#8217;s good enough to supply the activation energy required.</p>

<p>[5] Some VCs seem to understand technology because they actually do, but that&#8217;s overkill; the defining test is whether you can talk about it well enough to convince limited partners.</p>

<p>[6] This is the same phenomenon you see with defense contractors or fashion brands. The dumber the customers, the more effort you expend on the process of selling things to them rather than making the things you sell.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/07/13/zai-vimzhong-pa-xing/">在Vim中爬行</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/07/11/dota2-valve-bram-cohen-bt/">dota2 valve Bram Cohen BT</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/07/04/paulgraham-dot-com/">PaulGraham.com</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/06/13/lispgen-yuan/">Lisp根源</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/06/12/chen-lun-yu-hai/">沉沦欲海</a>
      </li>
    
  </ul>
</section>





<section>
  <h1>About Me</h1>
  <p>MMO服务器程序</p>
  <p>主要使用C＋＋，配合各种脚本 </p>
  <p>Email: secondsquare@gmail.com </p>
  <p>QQ: 406344976 </p>
</section>

  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - zhuzhonghua -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
