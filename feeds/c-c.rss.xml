<?xml version="1.0" encoding="utf-8"?> 
<rss version="2.0">
 <channel>
  <title>好记性不如烂笔头: Posts tagged 'c/c++'</title>
  <description>好记性不如烂笔头: Posts tagged 'c/c++'</description>
  <link>https://zhuzhonghua.github.com/tags/c-c.html</link>
  <lastBuildDate>Tue, 17 Jul 2018 23:56:25 UT</lastBuildDate>
  <pubDate>Tue, 17 Jul 2018 23:56:25 UT</pubDate>
  <ttl>1800</ttl>
  <item>
   <title>c/c++与chibi-scheme互相调用</title>
   <link>https://zhuzhonghua.github.com/2018/07/c-c-%E4%B8%8Echibi-scheme%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8.html?utm_source=c-c&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:https-zhuzhonghua-github-com:-2018-07-c-c-E4-B8-8Echibi-scheme-E4-BA-92-E7-9B-B8-E8-B0-83-E7-94-A8-html</guid>
   <pubDate>Tue, 17 Jul 2018 23:56:25 UT</pubDate>
   <author>ZhongHua</author>
   <description>
&lt;p&gt;测试环境是mac&lt;/p&gt;

&lt;p&gt;chibi-scheme是scheme/lisp的一种实现，适合作为脚本语言嵌入到c/c++程序中&lt;/p&gt;

&lt;p&gt;&lt;a href="http://synthcode.com/scheme/chibi/#h2_EmbeddinginC"&gt;chibi-scheme官方文档&lt;/a&gt;写的很清楚，只是没有实例&lt;/p&gt;

&lt;p&gt;&lt;a href="http://klamp.works/2016/02/05/chibi-scheme-1.html"&gt;外国友人写的相关教程&lt;/a&gt;结合实例，写的很清楚&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/zhuzhonghua/chibi-scheme.git"&gt;代码库地址&lt;/a&gt; 里的c2scheme目录是示例代码&lt;/p&gt;

&lt;p&gt;大体分成三步&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;加载scheme文件
  &lt;br /&gt;&lt;/li&gt;
 &lt;li&gt;调用scheme函数代码，传递参数，接收返回值
  &lt;br /&gt;&lt;/li&gt;
 &lt;li&gt;scheme代码调用c/c++代码，传递参数，接收返回值&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;callme.scm&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(import (chibi))
(define (say-hello)
  (display "hello world from scheme")
  (newline))&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="加载scheme文件"&gt;加载scheme文件&lt;/h1&gt;

&lt;p&gt;obj1 = sexp_c_string(ctx, &amp;ldquo;callme.scm&amp;rdquo;, &amp;ndash;1);  sexp_load(ctx, obj1, NULL);&lt;/p&gt;

&lt;h1 id="调用scheme函数代码传递参数接收返回值"&gt;调用scheme函数代码，传递参数，接收返回值&lt;/h1&gt;

&lt;p&gt;调用scheme函数代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sexp_eval_string(ctx, "(say-hello)", -1, NULL);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;传递参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arg_val = sexp_make_fixnum(4);
arg_sym = sexp_intern(ctx, "arg", -1);
sexp_env_define(ctx, sexp_context_env(ctx), arg_sym, arg_val);

file_path = sexp_c_string(ctx, "callme.scm", -1);
sexp_load(ctx, file_path, NULL);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接收返回值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ret = sexp_eval_string(ctx, "(square arg)", -1, NULL);
int result = -1;
if (sexp_integerp(ret)) {
  result = sexp_unbox_fixnum(ret);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;callme.scm&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define (square a)
  (* a a))&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id="scheme代码调用cc代码传递参数接收返回值"&gt;scheme代码调用c/c++代码，传递参数，接收返回值&lt;/h1&gt;

&lt;p&gt;callme.scm&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define (say-hello)
	(display "hello world from scheme")
	(newline)
	(hello-user "chibi-scheme"))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;hello-user是c/c++函数，传递一个字符串
 &lt;br /&gt;在c/c++中横线会转换成下划线&lt;/p&gt;

&lt;p&gt;定义头文件&lt;/p&gt;

&lt;p&gt;c2scheme.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extern void hello_user(const char* tmp);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义stub文件&lt;/p&gt;

&lt;p&gt;c2scheme.stub&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(c-include "c2scheme.h")	
(define-c void hello-user (string))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;stub文件主要便于生成对应的c/c++文件&lt;/p&gt;

&lt;p&gt;然后运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DYLD_LIBRARY_PATH=. ./chibi-scheme ./tools/chibi-ffi c2scheme/c2scheme.stub&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会生成对应的c/c++文件，我们看下它的内容&lt;/p&gt;

&lt;p&gt;c2scheme.c&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* Automatically generated by chibi-ffi; version: 0.4 */

#include &amp;lt;chibi/eval.h&amp;gt;

#include "c2scheme.h"
/*
types: ()
enums: ()
*/

sexp sexp_hello_user_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  sexp res;
  if (! sexp_stringp(arg0))
    return sexp_type_exception(ctx, self, SEXP_STRING, arg0);
  res = ((hello_user(sexp_string_data(arg0))), SEXP_VOID);
  return res;
}


sexp sexp_init_library (sexp ctx, sexp self, sexp_sint_t n, sexp env, const char* version, const sexp_abi_identifier_t abi) {
  sexp_gc_var3(name, tmp, op);
  if (!(sexp_version_compatible(ctx, version, sexp_version)
        &amp;amp;&amp;amp; sexp_abi_compatible(ctx, abi, SEXP_ABI_IDENTIFIER)))
    return SEXP_ABI_ERROR;
  sexp_gc_preserve3(ctx, name, tmp, op);
  op = sexp_define_foreign(ctx, env, "hello-user", 1, sexp_hello_user_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = SEXP_VOID;
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_STRING);
  }
  sexp_gc_release3(ctx);
  return SEXP_VOID;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只需要实现hello_user这个函数即可.&lt;/p&gt;

&lt;p&gt;我们在main.cpp里实现这个方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void hello_user(const char* tmp){
	printf("in hello user %s \n", tmp);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将来可以把函数的声明和实现统一规划到别的文件去，这里只是做个示例。&lt;/p&gt;

&lt;p&gt;完整代码及编译运行脚本在上面的仓库地址。&lt;/p&gt;

&lt;p&gt;注意 (import (chibi)) 这是需要加载chibi-scheme的lib目录下的scm文件，默认搜索目录是./lib和.目录，所以当运行目录在别的地方时，需要添加module搜索目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sexp_add_module_directory(ctx, tmp=sexp_c_string(ctx,"../lib",-1), SEXP_TRUE);  &lt;/code&gt;&lt;/pre&gt;</description></item></channel></rss>